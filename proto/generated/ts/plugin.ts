// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: plugin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { BlockBreakEvent, ChatEvent, CommandEvent, PlayerJoinEvent, PlayerQuitEvent } from "./player_events";
import { WorldCloseEvent } from "./world_events";

export const protobufPackage = "df.plugin";

export enum EventType {
  EVENT_TYPE_UNSPECIFIED = 0,
  EVENT_TYPE_ALL = 1,
  PLAYER_JOIN = 10,
  PLAYER_QUIT = 11,
  PLAYER_MOVE = 12,
  PLAYER_JUMP = 13,
  PLAYER_TELEPORT = 14,
  PLAYER_CHANGE_WORLD = 15,
  PLAYER_TOGGLE_SPRINT = 16,
  PLAYER_TOGGLE_SNEAK = 17,
  CHAT = 18,
  PLAYER_FOOD_LOSS = 19,
  PLAYER_HEAL = 20,
  PLAYER_HURT = 21,
  PLAYER_DEATH = 22,
  PLAYER_RESPAWN = 23,
  PLAYER_SKIN_CHANGE = 24,
  PLAYER_FIRE_EXTINGUISH = 25,
  PLAYER_START_BREAK = 26,
  PLAYER_BLOCK_BREAK = 27,
  PLAYER_BLOCK_PLACE = 28,
  PLAYER_BLOCK_PICK = 29,
  PLAYER_ITEM_USE = 30,
  PLAYER_ITEM_USE_ON_BLOCK = 31,
  PLAYER_ITEM_USE_ON_ENTITY = 32,
  PLAYER_ITEM_RELEASE = 33,
  PLAYER_ITEM_CONSUME = 34,
  PLAYER_ATTACK_ENTITY = 35,
  PLAYER_EXPERIENCE_GAIN = 36,
  PLAYER_PUNCH_AIR = 37,
  PLAYER_SIGN_EDIT = 38,
  PLAYER_LECTERN_PAGE_TURN = 39,
  PLAYER_ITEM_DAMAGE = 40,
  PLAYER_ITEM_PICKUP = 41,
  PLAYER_HELD_SLOT_CHANGE = 42,
  PLAYER_ITEM_DROP = 43,
  PLAYER_TRANSFER = 44,
  COMMAND = 45,
  PLAYER_DIAGNOSTICS = 46,
  WORLD_LIQUID_FLOW = 70,
  WORLD_LIQUID_DECAY = 71,
  WORLD_LIQUID_HARDEN = 72,
  WORLD_SOUND = 73,
  WORLD_FIRE_SPREAD = 74,
  WORLD_BLOCK_BURN = 75,
  WORLD_CROP_TRAMPLE = 76,
  WORLD_LEAVES_DECAY = 77,
  WORLD_ENTITY_SPAWN = 78,
  WORLD_ENTITY_DESPAWN = 79,
  WORLD_EXPLOSION = 80,
  WORLD_CLOSE = 81,
  UNRECOGNIZED = -1,
}

export function eventTypeFromJSON(object: any): EventType {
  switch (object) {
    case 0:
    case "EVENT_TYPE_UNSPECIFIED":
      return EventType.EVENT_TYPE_UNSPECIFIED;
    case 1:
    case "EVENT_TYPE_ALL":
      return EventType.EVENT_TYPE_ALL;
    case 10:
    case "PLAYER_JOIN":
      return EventType.PLAYER_JOIN;
    case 11:
    case "PLAYER_QUIT":
      return EventType.PLAYER_QUIT;
    case 12:
    case "PLAYER_MOVE":
      return EventType.PLAYER_MOVE;
    case 13:
    case "PLAYER_JUMP":
      return EventType.PLAYER_JUMP;
    case 14:
    case "PLAYER_TELEPORT":
      return EventType.PLAYER_TELEPORT;
    case 15:
    case "PLAYER_CHANGE_WORLD":
      return EventType.PLAYER_CHANGE_WORLD;
    case 16:
    case "PLAYER_TOGGLE_SPRINT":
      return EventType.PLAYER_TOGGLE_SPRINT;
    case 17:
    case "PLAYER_TOGGLE_SNEAK":
      return EventType.PLAYER_TOGGLE_SNEAK;
    case 18:
    case "CHAT":
      return EventType.CHAT;
    case 19:
    case "PLAYER_FOOD_LOSS":
      return EventType.PLAYER_FOOD_LOSS;
    case 20:
    case "PLAYER_HEAL":
      return EventType.PLAYER_HEAL;
    case 21:
    case "PLAYER_HURT":
      return EventType.PLAYER_HURT;
    case 22:
    case "PLAYER_DEATH":
      return EventType.PLAYER_DEATH;
    case 23:
    case "PLAYER_RESPAWN":
      return EventType.PLAYER_RESPAWN;
    case 24:
    case "PLAYER_SKIN_CHANGE":
      return EventType.PLAYER_SKIN_CHANGE;
    case 25:
    case "PLAYER_FIRE_EXTINGUISH":
      return EventType.PLAYER_FIRE_EXTINGUISH;
    case 26:
    case "PLAYER_START_BREAK":
      return EventType.PLAYER_START_BREAK;
    case 27:
    case "PLAYER_BLOCK_BREAK":
      return EventType.PLAYER_BLOCK_BREAK;
    case 28:
    case "PLAYER_BLOCK_PLACE":
      return EventType.PLAYER_BLOCK_PLACE;
    case 29:
    case "PLAYER_BLOCK_PICK":
      return EventType.PLAYER_BLOCK_PICK;
    case 30:
    case "PLAYER_ITEM_USE":
      return EventType.PLAYER_ITEM_USE;
    case 31:
    case "PLAYER_ITEM_USE_ON_BLOCK":
      return EventType.PLAYER_ITEM_USE_ON_BLOCK;
    case 32:
    case "PLAYER_ITEM_USE_ON_ENTITY":
      return EventType.PLAYER_ITEM_USE_ON_ENTITY;
    case 33:
    case "PLAYER_ITEM_RELEASE":
      return EventType.PLAYER_ITEM_RELEASE;
    case 34:
    case "PLAYER_ITEM_CONSUME":
      return EventType.PLAYER_ITEM_CONSUME;
    case 35:
    case "PLAYER_ATTACK_ENTITY":
      return EventType.PLAYER_ATTACK_ENTITY;
    case 36:
    case "PLAYER_EXPERIENCE_GAIN":
      return EventType.PLAYER_EXPERIENCE_GAIN;
    case 37:
    case "PLAYER_PUNCH_AIR":
      return EventType.PLAYER_PUNCH_AIR;
    case 38:
    case "PLAYER_SIGN_EDIT":
      return EventType.PLAYER_SIGN_EDIT;
    case 39:
    case "PLAYER_LECTERN_PAGE_TURN":
      return EventType.PLAYER_LECTERN_PAGE_TURN;
    case 40:
    case "PLAYER_ITEM_DAMAGE":
      return EventType.PLAYER_ITEM_DAMAGE;
    case 41:
    case "PLAYER_ITEM_PICKUP":
      return EventType.PLAYER_ITEM_PICKUP;
    case 42:
    case "PLAYER_HELD_SLOT_CHANGE":
      return EventType.PLAYER_HELD_SLOT_CHANGE;
    case 43:
    case "PLAYER_ITEM_DROP":
      return EventType.PLAYER_ITEM_DROP;
    case 44:
    case "PLAYER_TRANSFER":
      return EventType.PLAYER_TRANSFER;
    case 45:
    case "COMMAND":
      return EventType.COMMAND;
    case 46:
    case "PLAYER_DIAGNOSTICS":
      return EventType.PLAYER_DIAGNOSTICS;
    case 70:
    case "WORLD_LIQUID_FLOW":
      return EventType.WORLD_LIQUID_FLOW;
    case 71:
    case "WORLD_LIQUID_DECAY":
      return EventType.WORLD_LIQUID_DECAY;
    case 72:
    case "WORLD_LIQUID_HARDEN":
      return EventType.WORLD_LIQUID_HARDEN;
    case 73:
    case "WORLD_SOUND":
      return EventType.WORLD_SOUND;
    case 74:
    case "WORLD_FIRE_SPREAD":
      return EventType.WORLD_FIRE_SPREAD;
    case 75:
    case "WORLD_BLOCK_BURN":
      return EventType.WORLD_BLOCK_BURN;
    case 76:
    case "WORLD_CROP_TRAMPLE":
      return EventType.WORLD_CROP_TRAMPLE;
    case 77:
    case "WORLD_LEAVES_DECAY":
      return EventType.WORLD_LEAVES_DECAY;
    case 78:
    case "WORLD_ENTITY_SPAWN":
      return EventType.WORLD_ENTITY_SPAWN;
    case 79:
    case "WORLD_ENTITY_DESPAWN":
      return EventType.WORLD_ENTITY_DESPAWN;
    case 80:
    case "WORLD_EXPLOSION":
      return EventType.WORLD_EXPLOSION;
    case 81:
    case "WORLD_CLOSE":
      return EventType.WORLD_CLOSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventType.UNRECOGNIZED;
  }
}

export function eventTypeToJSON(object: EventType): string {
  switch (object) {
    case EventType.EVENT_TYPE_UNSPECIFIED:
      return "EVENT_TYPE_UNSPECIFIED";
    case EventType.EVENT_TYPE_ALL:
      return "EVENT_TYPE_ALL";
    case EventType.PLAYER_JOIN:
      return "PLAYER_JOIN";
    case EventType.PLAYER_QUIT:
      return "PLAYER_QUIT";
    case EventType.PLAYER_MOVE:
      return "PLAYER_MOVE";
    case EventType.PLAYER_JUMP:
      return "PLAYER_JUMP";
    case EventType.PLAYER_TELEPORT:
      return "PLAYER_TELEPORT";
    case EventType.PLAYER_CHANGE_WORLD:
      return "PLAYER_CHANGE_WORLD";
    case EventType.PLAYER_TOGGLE_SPRINT:
      return "PLAYER_TOGGLE_SPRINT";
    case EventType.PLAYER_TOGGLE_SNEAK:
      return "PLAYER_TOGGLE_SNEAK";
    case EventType.CHAT:
      return "CHAT";
    case EventType.PLAYER_FOOD_LOSS:
      return "PLAYER_FOOD_LOSS";
    case EventType.PLAYER_HEAL:
      return "PLAYER_HEAL";
    case EventType.PLAYER_HURT:
      return "PLAYER_HURT";
    case EventType.PLAYER_DEATH:
      return "PLAYER_DEATH";
    case EventType.PLAYER_RESPAWN:
      return "PLAYER_RESPAWN";
    case EventType.PLAYER_SKIN_CHANGE:
      return "PLAYER_SKIN_CHANGE";
    case EventType.PLAYER_FIRE_EXTINGUISH:
      return "PLAYER_FIRE_EXTINGUISH";
    case EventType.PLAYER_START_BREAK:
      return "PLAYER_START_BREAK";
    case EventType.PLAYER_BLOCK_BREAK:
      return "PLAYER_BLOCK_BREAK";
    case EventType.PLAYER_BLOCK_PLACE:
      return "PLAYER_BLOCK_PLACE";
    case EventType.PLAYER_BLOCK_PICK:
      return "PLAYER_BLOCK_PICK";
    case EventType.PLAYER_ITEM_USE:
      return "PLAYER_ITEM_USE";
    case EventType.PLAYER_ITEM_USE_ON_BLOCK:
      return "PLAYER_ITEM_USE_ON_BLOCK";
    case EventType.PLAYER_ITEM_USE_ON_ENTITY:
      return "PLAYER_ITEM_USE_ON_ENTITY";
    case EventType.PLAYER_ITEM_RELEASE:
      return "PLAYER_ITEM_RELEASE";
    case EventType.PLAYER_ITEM_CONSUME:
      return "PLAYER_ITEM_CONSUME";
    case EventType.PLAYER_ATTACK_ENTITY:
      return "PLAYER_ATTACK_ENTITY";
    case EventType.PLAYER_EXPERIENCE_GAIN:
      return "PLAYER_EXPERIENCE_GAIN";
    case EventType.PLAYER_PUNCH_AIR:
      return "PLAYER_PUNCH_AIR";
    case EventType.PLAYER_SIGN_EDIT:
      return "PLAYER_SIGN_EDIT";
    case EventType.PLAYER_LECTERN_PAGE_TURN:
      return "PLAYER_LECTERN_PAGE_TURN";
    case EventType.PLAYER_ITEM_DAMAGE:
      return "PLAYER_ITEM_DAMAGE";
    case EventType.PLAYER_ITEM_PICKUP:
      return "PLAYER_ITEM_PICKUP";
    case EventType.PLAYER_HELD_SLOT_CHANGE:
      return "PLAYER_HELD_SLOT_CHANGE";
    case EventType.PLAYER_ITEM_DROP:
      return "PLAYER_ITEM_DROP";
    case EventType.PLAYER_TRANSFER:
      return "PLAYER_TRANSFER";
    case EventType.COMMAND:
      return "COMMAND";
    case EventType.PLAYER_DIAGNOSTICS:
      return "PLAYER_DIAGNOSTICS";
    case EventType.WORLD_LIQUID_FLOW:
      return "WORLD_LIQUID_FLOW";
    case EventType.WORLD_LIQUID_DECAY:
      return "WORLD_LIQUID_DECAY";
    case EventType.WORLD_LIQUID_HARDEN:
      return "WORLD_LIQUID_HARDEN";
    case EventType.WORLD_SOUND:
      return "WORLD_SOUND";
    case EventType.WORLD_FIRE_SPREAD:
      return "WORLD_FIRE_SPREAD";
    case EventType.WORLD_BLOCK_BURN:
      return "WORLD_BLOCK_BURN";
    case EventType.WORLD_CROP_TRAMPLE:
      return "WORLD_CROP_TRAMPLE";
    case EventType.WORLD_LEAVES_DECAY:
      return "WORLD_LEAVES_DECAY";
    case EventType.WORLD_ENTITY_SPAWN:
      return "WORLD_ENTITY_SPAWN";
    case EventType.WORLD_ENTITY_DESPAWN:
      return "WORLD_ENTITY_DESPAWN";
    case EventType.WORLD_EXPLOSION:
      return "WORLD_EXPLOSION";
    case EventType.WORLD_CLOSE:
      return "WORLD_CLOSE";
    case EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum GameMode {
  SURVIVAL = 0,
  CREATIVE = 1,
  ADVENTURE = 2,
  SPECTATOR = 3,
  UNRECOGNIZED = -1,
}

export function gameModeFromJSON(object: any): GameMode {
  switch (object) {
    case 0:
    case "SURVIVAL":
      return GameMode.SURVIVAL;
    case 1:
    case "CREATIVE":
      return GameMode.CREATIVE;
    case 2:
    case "ADVENTURE":
      return GameMode.ADVENTURE;
    case 3:
    case "SPECTATOR":
      return GameMode.SPECTATOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameMode.UNRECOGNIZED;
  }
}

export function gameModeToJSON(object: GameMode): string {
  switch (object) {
    case GameMode.SURVIVAL:
      return "SURVIVAL";
    case GameMode.CREATIVE:
      return "CREATIVE";
    case GameMode.ADVENTURE:
      return "ADVENTURE";
    case GameMode.SPECTATOR:
      return "SPECTATOR";
    case GameMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface HostToPlugin {
  pluginId: string;
  hello?: HostHello | undefined;
  shutdown?: HostShutdown | undefined;
  event?: EventEnvelope | undefined;
}

export interface HostHello {
  apiVersion: string;
}

export interface HostShutdown {
  reason: string;
}

export interface EventEnvelope {
  eventId: string;
  type: EventType;
  playerJoin?: PlayerJoinEvent | undefined;
  playerQuit?: PlayerQuitEvent | undefined;
  chat?: ChatEvent | undefined;
  command?: CommandEvent | undefined;
  blockBreak?: BlockBreakEvent | undefined;
  worldClose?: WorldCloseEvent | undefined;
}

export interface PluginToHost {
  pluginId: string;
  hello?: PluginHello | undefined;
  subscribe?: EventSubscribe | undefined;
  actions?: ActionBatch | undefined;
  log?: LogMessage | undefined;
  eventResult?: EventResult | undefined;
}

export interface PluginHello {
  name: string;
  version: string;
  apiVersion: string;
  commands: CommandSpec[];
}

export interface CommandSpec {
  name: string;
  description: string;
  aliases: string[];
}

export interface EventSubscribe {
  events: EventType[];
}

export interface ActionBatch {
  actions: Action[];
}

export interface Action {
  correlationId?: string | undefined;
  sendChat?: SendChatAction | undefined;
  teleport?: TeleportAction | undefined;
  kick?: KickAction | undefined;
  setGameMode?: SetGameModeAction | undefined;
}

export interface SendChatAction {
  targetUuid: string;
  message: string;
}

export interface TeleportAction {
  playerUuid: string;
  x: number;
  y: number;
  z: number;
  yaw: number;
  pitch: number;
}

export interface KickAction {
  playerUuid: string;
  reason: string;
}

export interface SetGameModeAction {
  playerUuid: string;
  gameMode: GameMode;
}

export interface LogMessage {
  level: string;
  message: string;
}

export interface EventResult {
  eventId: string;
  cancel?: boolean | undefined;
  chat?: ChatMutation | undefined;
  blockBreak?: BlockBreakMutation | undefined;
}

export interface ChatMutation {
  message: string;
}

export interface BlockBreakMutation {
  drops: ItemStack[];
  xp?: number | undefined;
}

export interface ItemStack {
  name: string;
  meta: number;
  count: number;
}

function createBaseHostToPlugin(): HostToPlugin {
  return { pluginId: "", hello: undefined, shutdown: undefined, event: undefined };
}

export const HostToPlugin: MessageFns<HostToPlugin> = {
  encode(message: HostToPlugin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pluginId !== "") {
      writer.uint32(10).string(message.pluginId);
    }
    if (message.hello !== undefined) {
      HostHello.encode(message.hello, writer.uint32(82).fork()).join();
    }
    if (message.shutdown !== undefined) {
      HostShutdown.encode(message.shutdown, writer.uint32(90).fork()).join();
    }
    if (message.event !== undefined) {
      EventEnvelope.encode(message.event, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostToPlugin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostToPlugin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pluginId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hello = HostHello.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.shutdown = HostShutdown.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.event = EventEnvelope.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostToPlugin {
    return {
      pluginId: isSet(object.pluginId) ? globalThis.String(object.pluginId) : "",
      hello: isSet(object.hello) ? HostHello.fromJSON(object.hello) : undefined,
      shutdown: isSet(object.shutdown) ? HostShutdown.fromJSON(object.shutdown) : undefined,
      event: isSet(object.event) ? EventEnvelope.fromJSON(object.event) : undefined,
    };
  },

  toJSON(message: HostToPlugin): unknown {
    const obj: any = {};
    if (message.pluginId !== "") {
      obj.pluginId = message.pluginId;
    }
    if (message.hello !== undefined) {
      obj.hello = HostHello.toJSON(message.hello);
    }
    if (message.shutdown !== undefined) {
      obj.shutdown = HostShutdown.toJSON(message.shutdown);
    }
    if (message.event !== undefined) {
      obj.event = EventEnvelope.toJSON(message.event);
    }
    return obj;
  },

  create(base?: DeepPartial<HostToPlugin>): HostToPlugin {
    return HostToPlugin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HostToPlugin>): HostToPlugin {
    const message = createBaseHostToPlugin();
    message.pluginId = object.pluginId ?? "";
    message.hello = (object.hello !== undefined && object.hello !== null)
      ? HostHello.fromPartial(object.hello)
      : undefined;
    message.shutdown = (object.shutdown !== undefined && object.shutdown !== null)
      ? HostShutdown.fromPartial(object.shutdown)
      : undefined;
    message.event = (object.event !== undefined && object.event !== null)
      ? EventEnvelope.fromPartial(object.event)
      : undefined;
    return message;
  },
};

function createBaseHostHello(): HostHello {
  return { apiVersion: "" };
}

export const HostHello: MessageFns<HostHello> = {
  encode(message: HostHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiVersion !== "") {
      writer.uint32(10).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostHello {
    return { apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "" };
  },

  toJSON(message: HostHello): unknown {
    const obj: any = {};
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<HostHello>): HostHello {
    return HostHello.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HostHello>): HostHello {
    const message = createBaseHostHello();
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseHostShutdown(): HostShutdown {
  return { reason: "" };
}

export const HostShutdown: MessageFns<HostShutdown> = {
  encode(message: HostShutdown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostShutdown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostShutdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostShutdown {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: HostShutdown): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<HostShutdown>): HostShutdown {
    return HostShutdown.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HostShutdown>): HostShutdown {
    const message = createBaseHostShutdown();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseEventEnvelope(): EventEnvelope {
  return {
    eventId: "",
    type: 0,
    playerJoin: undefined,
    playerQuit: undefined,
    chat: undefined,
    command: undefined,
    blockBreak: undefined,
    worldClose: undefined,
  };
}

export const EventEnvelope: MessageFns<EventEnvelope> = {
  encode(message: EventEnvelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.playerJoin !== undefined) {
      PlayerJoinEvent.encode(message.playerJoin, writer.uint32(82).fork()).join();
    }
    if (message.playerQuit !== undefined) {
      PlayerQuitEvent.encode(message.playerQuit, writer.uint32(90).fork()).join();
    }
    if (message.chat !== undefined) {
      ChatEvent.encode(message.chat, writer.uint32(98).fork()).join();
    }
    if (message.command !== undefined) {
      CommandEvent.encode(message.command, writer.uint32(106).fork()).join();
    }
    if (message.blockBreak !== undefined) {
      BlockBreakEvent.encode(message.blockBreak, writer.uint32(114).fork()).join();
    }
    if (message.worldClose !== undefined) {
      WorldCloseEvent.encode(message.worldClose, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEnvelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.playerJoin = PlayerJoinEvent.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.playerQuit = PlayerQuitEvent.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.chat = ChatEvent.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.command = CommandEvent.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.blockBreak = BlockBreakEvent.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.worldClose = WorldCloseEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEnvelope {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      type: isSet(object.type) ? eventTypeFromJSON(object.type) : 0,
      playerJoin: isSet(object.playerJoin) ? PlayerJoinEvent.fromJSON(object.playerJoin) : undefined,
      playerQuit: isSet(object.playerQuit) ? PlayerQuitEvent.fromJSON(object.playerQuit) : undefined,
      chat: isSet(object.chat) ? ChatEvent.fromJSON(object.chat) : undefined,
      command: isSet(object.command) ? CommandEvent.fromJSON(object.command) : undefined,
      blockBreak: isSet(object.blockBreak) ? BlockBreakEvent.fromJSON(object.blockBreak) : undefined,
      worldClose: isSet(object.worldClose) ? WorldCloseEvent.fromJSON(object.worldClose) : undefined,
    };
  },

  toJSON(message: EventEnvelope): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.type !== 0) {
      obj.type = eventTypeToJSON(message.type);
    }
    if (message.playerJoin !== undefined) {
      obj.playerJoin = PlayerJoinEvent.toJSON(message.playerJoin);
    }
    if (message.playerQuit !== undefined) {
      obj.playerQuit = PlayerQuitEvent.toJSON(message.playerQuit);
    }
    if (message.chat !== undefined) {
      obj.chat = ChatEvent.toJSON(message.chat);
    }
    if (message.command !== undefined) {
      obj.command = CommandEvent.toJSON(message.command);
    }
    if (message.blockBreak !== undefined) {
      obj.blockBreak = BlockBreakEvent.toJSON(message.blockBreak);
    }
    if (message.worldClose !== undefined) {
      obj.worldClose = WorldCloseEvent.toJSON(message.worldClose);
    }
    return obj;
  },

  create(base?: DeepPartial<EventEnvelope>): EventEnvelope {
    return EventEnvelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventEnvelope>): EventEnvelope {
    const message = createBaseEventEnvelope();
    message.eventId = object.eventId ?? "";
    message.type = object.type ?? 0;
    message.playerJoin = (object.playerJoin !== undefined && object.playerJoin !== null)
      ? PlayerJoinEvent.fromPartial(object.playerJoin)
      : undefined;
    message.playerQuit = (object.playerQuit !== undefined && object.playerQuit !== null)
      ? PlayerQuitEvent.fromPartial(object.playerQuit)
      : undefined;
    message.chat = (object.chat !== undefined && object.chat !== null) ? ChatEvent.fromPartial(object.chat) : undefined;
    message.command = (object.command !== undefined && object.command !== null)
      ? CommandEvent.fromPartial(object.command)
      : undefined;
    message.blockBreak = (object.blockBreak !== undefined && object.blockBreak !== null)
      ? BlockBreakEvent.fromPartial(object.blockBreak)
      : undefined;
    message.worldClose = (object.worldClose !== undefined && object.worldClose !== null)
      ? WorldCloseEvent.fromPartial(object.worldClose)
      : undefined;
    return message;
  },
};

function createBasePluginToHost(): PluginToHost {
  return {
    pluginId: "",
    hello: undefined,
    subscribe: undefined,
    actions: undefined,
    log: undefined,
    eventResult: undefined,
  };
}

export const PluginToHost: MessageFns<PluginToHost> = {
  encode(message: PluginToHost, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pluginId !== "") {
      writer.uint32(10).string(message.pluginId);
    }
    if (message.hello !== undefined) {
      PluginHello.encode(message.hello, writer.uint32(82).fork()).join();
    }
    if (message.subscribe !== undefined) {
      EventSubscribe.encode(message.subscribe, writer.uint32(90).fork()).join();
    }
    if (message.actions !== undefined) {
      ActionBatch.encode(message.actions, writer.uint32(162).fork()).join();
    }
    if (message.log !== undefined) {
      LogMessage.encode(message.log, writer.uint32(242).fork()).join();
    }
    if (message.eventResult !== undefined) {
      EventResult.encode(message.eventResult, writer.uint32(322).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginToHost {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginToHost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pluginId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hello = PluginHello.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.subscribe = EventSubscribe.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.actions = ActionBatch.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.log = LogMessage.decode(reader, reader.uint32());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.eventResult = EventResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginToHost {
    return {
      pluginId: isSet(object.pluginId) ? globalThis.String(object.pluginId) : "",
      hello: isSet(object.hello) ? PluginHello.fromJSON(object.hello) : undefined,
      subscribe: isSet(object.subscribe) ? EventSubscribe.fromJSON(object.subscribe) : undefined,
      actions: isSet(object.actions) ? ActionBatch.fromJSON(object.actions) : undefined,
      log: isSet(object.log) ? LogMessage.fromJSON(object.log) : undefined,
      eventResult: isSet(object.eventResult) ? EventResult.fromJSON(object.eventResult) : undefined,
    };
  },

  toJSON(message: PluginToHost): unknown {
    const obj: any = {};
    if (message.pluginId !== "") {
      obj.pluginId = message.pluginId;
    }
    if (message.hello !== undefined) {
      obj.hello = PluginHello.toJSON(message.hello);
    }
    if (message.subscribe !== undefined) {
      obj.subscribe = EventSubscribe.toJSON(message.subscribe);
    }
    if (message.actions !== undefined) {
      obj.actions = ActionBatch.toJSON(message.actions);
    }
    if (message.log !== undefined) {
      obj.log = LogMessage.toJSON(message.log);
    }
    if (message.eventResult !== undefined) {
      obj.eventResult = EventResult.toJSON(message.eventResult);
    }
    return obj;
  },

  create(base?: DeepPartial<PluginToHost>): PluginToHost {
    return PluginToHost.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PluginToHost>): PluginToHost {
    const message = createBasePluginToHost();
    message.pluginId = object.pluginId ?? "";
    message.hello = (object.hello !== undefined && object.hello !== null)
      ? PluginHello.fromPartial(object.hello)
      : undefined;
    message.subscribe = (object.subscribe !== undefined && object.subscribe !== null)
      ? EventSubscribe.fromPartial(object.subscribe)
      : undefined;
    message.actions = (object.actions !== undefined && object.actions !== null)
      ? ActionBatch.fromPartial(object.actions)
      : undefined;
    message.log = (object.log !== undefined && object.log !== null) ? LogMessage.fromPartial(object.log) : undefined;
    message.eventResult = (object.eventResult !== undefined && object.eventResult !== null)
      ? EventResult.fromPartial(object.eventResult)
      : undefined;
    return message;
  },
};

function createBasePluginHello(): PluginHello {
  return { name: "", version: "", apiVersion: "", commands: [] };
}

export const PluginHello: MessageFns<PluginHello> = {
  encode(message: PluginHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.apiVersion !== "") {
      writer.uint32(26).string(message.apiVersion);
    }
    for (const v of message.commands) {
      CommandSpec.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commands.push(CommandSpec.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginHello {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
      commands: globalThis.Array.isArray(object?.commands)
        ? object.commands.map((e: any) => CommandSpec.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PluginHello): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    if (message.commands?.length) {
      obj.commands = message.commands.map((e) => CommandSpec.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PluginHello>): PluginHello {
    return PluginHello.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PluginHello>): PluginHello {
    const message = createBasePluginHello();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.apiVersion = object.apiVersion ?? "";
    message.commands = object.commands?.map((e) => CommandSpec.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCommandSpec(): CommandSpec {
  return { name: "", description: "", aliases: [] };
}

export const CommandSpec: MessageFns<CommandSpec> = {
  encode(message: CommandSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.aliases) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aliases.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      aliases: globalThis.Array.isArray(object?.aliases) ? object.aliases.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CommandSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.aliases?.length) {
      obj.aliases = message.aliases;
    }
    return obj;
  },

  create(base?: DeepPartial<CommandSpec>): CommandSpec {
    return CommandSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandSpec>): CommandSpec {
    const message = createBaseCommandSpec();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.aliases = object.aliases?.map((e) => e) || [];
    return message;
  },
};

function createBaseEventSubscribe(): EventSubscribe {
  return { events: [] };
}

export const EventSubscribe: MessageFns<EventSubscribe> = {
  encode(message: EventSubscribe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.events) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubscribe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.events.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.events.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubscribe {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => eventTypeFromJSON(e)) : [],
    };
  },

  toJSON(message: EventSubscribe): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => eventTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubscribe>): EventSubscribe {
    return EventSubscribe.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubscribe>): EventSubscribe {
    const message = createBaseEventSubscribe();
    message.events = object.events?.map((e) => e) || [];
    return message;
  },
};

function createBaseActionBatch(): ActionBatch {
  return { actions: [] };
}

export const ActionBatch: MessageFns<ActionBatch> = {
  encode(message: ActionBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      Action.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actions.push(Action.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionBatch {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => Action.fromJSON(e)) : [],
    };
  },

  toJSON(message: ActionBatch): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => Action.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ActionBatch>): ActionBatch {
    return ActionBatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionBatch>): ActionBatch {
    const message = createBaseActionBatch();
    message.actions = object.actions?.map((e) => Action.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAction(): Action {
  return {
    correlationId: undefined,
    sendChat: undefined,
    teleport: undefined,
    kick: undefined,
    setGameMode: undefined,
  };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.correlationId !== undefined) {
      writer.uint32(10).string(message.correlationId);
    }
    if (message.sendChat !== undefined) {
      SendChatAction.encode(message.sendChat, writer.uint32(82).fork()).join();
    }
    if (message.teleport !== undefined) {
      TeleportAction.encode(message.teleport, writer.uint32(90).fork()).join();
    }
    if (message.kick !== undefined) {
      KickAction.encode(message.kick, writer.uint32(98).fork()).join();
    }
    if (message.setGameMode !== undefined) {
      SetGameModeAction.encode(message.setGameMode, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.sendChat = SendChatAction.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.teleport = TeleportAction.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.kick = KickAction.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.setGameMode = SetGameModeAction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : undefined,
      sendChat: isSet(object.sendChat) ? SendChatAction.fromJSON(object.sendChat) : undefined,
      teleport: isSet(object.teleport) ? TeleportAction.fromJSON(object.teleport) : undefined,
      kick: isSet(object.kick) ? KickAction.fromJSON(object.kick) : undefined,
      setGameMode: isSet(object.setGameMode) ? SetGameModeAction.fromJSON(object.setGameMode) : undefined,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.correlationId !== undefined) {
      obj.correlationId = message.correlationId;
    }
    if (message.sendChat !== undefined) {
      obj.sendChat = SendChatAction.toJSON(message.sendChat);
    }
    if (message.teleport !== undefined) {
      obj.teleport = TeleportAction.toJSON(message.teleport);
    }
    if (message.kick !== undefined) {
      obj.kick = KickAction.toJSON(message.kick);
    }
    if (message.setGameMode !== undefined) {
      obj.setGameMode = SetGameModeAction.toJSON(message.setGameMode);
    }
    return obj;
  },

  create(base?: DeepPartial<Action>): Action {
    return Action.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Action>): Action {
    const message = createBaseAction();
    message.correlationId = object.correlationId ?? undefined;
    message.sendChat = (object.sendChat !== undefined && object.sendChat !== null)
      ? SendChatAction.fromPartial(object.sendChat)
      : undefined;
    message.teleport = (object.teleport !== undefined && object.teleport !== null)
      ? TeleportAction.fromPartial(object.teleport)
      : undefined;
    message.kick = (object.kick !== undefined && object.kick !== null)
      ? KickAction.fromPartial(object.kick)
      : undefined;
    message.setGameMode = (object.setGameMode !== undefined && object.setGameMode !== null)
      ? SetGameModeAction.fromPartial(object.setGameMode)
      : undefined;
    return message;
  },
};

function createBaseSendChatAction(): SendChatAction {
  return { targetUuid: "", message: "" };
}

export const SendChatAction: MessageFns<SendChatAction> = {
  encode(message: SendChatAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetUuid !== "") {
      writer.uint32(10).string(message.targetUuid);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendChatAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendChatAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.targetUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendChatAction {
    return {
      targetUuid: isSet(object.targetUuid) ? globalThis.String(object.targetUuid) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SendChatAction): unknown {
    const obj: any = {};
    if (message.targetUuid !== "") {
      obj.targetUuid = message.targetUuid;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<SendChatAction>): SendChatAction {
    return SendChatAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendChatAction>): SendChatAction {
    const message = createBaseSendChatAction();
    message.targetUuid = object.targetUuid ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTeleportAction(): TeleportAction {
  return { playerUuid: "", x: 0, y: 0, z: 0, yaw: 0, pitch: 0 };
}

export const TeleportAction: MessageFns<TeleportAction> = {
  encode(message: TeleportAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.x !== 0) {
      writer.uint32(17).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(25).double(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(33).double(message.z);
    }
    if (message.yaw !== 0) {
      writer.uint32(45).float(message.yaw);
    }
    if (message.pitch !== 0) {
      writer.uint32(53).float(message.pitch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeleportAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeleportAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.x = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.y = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.z = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.yaw = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.pitch = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeleportAction {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      yaw: isSet(object.yaw) ? globalThis.Number(object.yaw) : 0,
      pitch: isSet(object.pitch) ? globalThis.Number(object.pitch) : 0,
    };
  },

  toJSON(message: TeleportAction): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    if (message.yaw !== 0) {
      obj.yaw = message.yaw;
    }
    if (message.pitch !== 0) {
      obj.pitch = message.pitch;
    }
    return obj;
  },

  create(base?: DeepPartial<TeleportAction>): TeleportAction {
    return TeleportAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TeleportAction>): TeleportAction {
    const message = createBaseTeleportAction();
    message.playerUuid = object.playerUuid ?? "";
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.yaw = object.yaw ?? 0;
    message.pitch = object.pitch ?? 0;
    return message;
  },
};

function createBaseKickAction(): KickAction {
  return { playerUuid: "", reason: "" };
}

export const KickAction: MessageFns<KickAction> = {
  encode(message: KickAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KickAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKickAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KickAction {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: KickAction): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<KickAction>): KickAction {
    return KickAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KickAction>): KickAction {
    const message = createBaseKickAction();
    message.playerUuid = object.playerUuid ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseSetGameModeAction(): SetGameModeAction {
  return { playerUuid: "", gameMode: 0 };
}

export const SetGameModeAction: MessageFns<SetGameModeAction> = {
  encode(message: SetGameModeAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.gameMode !== 0) {
      writer.uint32(16).int32(message.gameMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetGameModeAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGameModeAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetGameModeAction {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      gameMode: isSet(object.gameMode) ? gameModeFromJSON(object.gameMode) : 0,
    };
  },

  toJSON(message: SetGameModeAction): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.gameMode !== 0) {
      obj.gameMode = gameModeToJSON(message.gameMode);
    }
    return obj;
  },

  create(base?: DeepPartial<SetGameModeAction>): SetGameModeAction {
    return SetGameModeAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetGameModeAction>): SetGameModeAction {
    const message = createBaseSetGameModeAction();
    message.playerUuid = object.playerUuid ?? "";
    message.gameMode = object.gameMode ?? 0;
    return message;
  },
};

function createBaseLogMessage(): LogMessage {
  return { level: "", message: "" };
}

export const LogMessage: MessageFns<LogMessage> = {
  encode(message: LogMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== "") {
      writer.uint32(10).string(message.level);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.level = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogMessage {
    return {
      level: isSet(object.level) ? globalThis.String(object.level) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: LogMessage): unknown {
    const obj: any = {};
    if (message.level !== "") {
      obj.level = message.level;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<LogMessage>): LogMessage {
    return LogMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogMessage>): LogMessage {
    const message = createBaseLogMessage();
    message.level = object.level ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseEventResult(): EventResult {
  return { eventId: "", cancel: undefined, chat: undefined, blockBreak: undefined };
}

export const EventResult: MessageFns<EventResult> = {
  encode(message: EventResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.cancel !== undefined) {
      writer.uint32(16).bool(message.cancel);
    }
    if (message.chat !== undefined) {
      ChatMutation.encode(message.chat, writer.uint32(82).fork()).join();
    }
    if (message.blockBreak !== undefined) {
      BlockBreakMutation.encode(message.blockBreak, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cancel = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.chat = ChatMutation.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.blockBreak = BlockBreakMutation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventResult {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      cancel: isSet(object.cancel) ? globalThis.Boolean(object.cancel) : undefined,
      chat: isSet(object.chat) ? ChatMutation.fromJSON(object.chat) : undefined,
      blockBreak: isSet(object.blockBreak) ? BlockBreakMutation.fromJSON(object.blockBreak) : undefined,
    };
  },

  toJSON(message: EventResult): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.cancel !== undefined) {
      obj.cancel = message.cancel;
    }
    if (message.chat !== undefined) {
      obj.chat = ChatMutation.toJSON(message.chat);
    }
    if (message.blockBreak !== undefined) {
      obj.blockBreak = BlockBreakMutation.toJSON(message.blockBreak);
    }
    return obj;
  },

  create(base?: DeepPartial<EventResult>): EventResult {
    return EventResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventResult>): EventResult {
    const message = createBaseEventResult();
    message.eventId = object.eventId ?? "";
    message.cancel = object.cancel ?? undefined;
    message.chat = (object.chat !== undefined && object.chat !== null)
      ? ChatMutation.fromPartial(object.chat)
      : undefined;
    message.blockBreak = (object.blockBreak !== undefined && object.blockBreak !== null)
      ? BlockBreakMutation.fromPartial(object.blockBreak)
      : undefined;
    return message;
  },
};

function createBaseChatMutation(): ChatMutation {
  return { message: "" };
}

export const ChatMutation: MessageFns<ChatMutation> = {
  encode(message: ChatMutation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMutation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMutation {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ChatMutation): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<ChatMutation>): ChatMutation {
    return ChatMutation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChatMutation>): ChatMutation {
    const message = createBaseChatMutation();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseBlockBreakMutation(): BlockBreakMutation {
  return { drops: [], xp: undefined };
}

export const BlockBreakMutation: MessageFns<BlockBreakMutation> = {
  encode(message: BlockBreakMutation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.drops) {
      ItemStack.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.xp !== undefined) {
      writer.uint32(16).int32(message.xp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockBreakMutation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockBreakMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.drops.push(ItemStack.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.xp = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockBreakMutation {
    return {
      drops: globalThis.Array.isArray(object?.drops) ? object.drops.map((e: any) => ItemStack.fromJSON(e)) : [],
      xp: isSet(object.xp) ? globalThis.Number(object.xp) : undefined,
    };
  },

  toJSON(message: BlockBreakMutation): unknown {
    const obj: any = {};
    if (message.drops?.length) {
      obj.drops = message.drops.map((e) => ItemStack.toJSON(e));
    }
    if (message.xp !== undefined) {
      obj.xp = Math.round(message.xp);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockBreakMutation>): BlockBreakMutation {
    return BlockBreakMutation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockBreakMutation>): BlockBreakMutation {
    const message = createBaseBlockBreakMutation();
    message.drops = object.drops?.map((e) => ItemStack.fromPartial(e)) || [];
    message.xp = object.xp ?? undefined;
    return message;
  },
};

function createBaseItemStack(): ItemStack {
  return { name: "", meta: 0, count: 0 };
}

export const ItemStack: MessageFns<ItemStack> = {
  encode(message: ItemStack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.meta !== 0) {
      writer.uint32(16).int32(message.meta);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemStack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemStack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.meta = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemStack {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      meta: isSet(object.meta) ? globalThis.Number(object.meta) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: ItemStack): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.meta !== 0) {
      obj.meta = Math.round(message.meta);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<ItemStack>): ItemStack {
    return ItemStack.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ItemStack>): ItemStack {
    const message = createBaseItemStack();
    message.name = object.name ?? "";
    message.meta = object.meta ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

export type PluginDefinition = typeof PluginDefinition;
export const PluginDefinition = {
  name: "Plugin",
  fullName: "df.plugin.Plugin",
  methods: {
    eventStream: {
      name: "EventStream",
      requestType: PluginToHost,
      requestStream: true,
      responseType: HostToPlugin,
      responseStream: true,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
