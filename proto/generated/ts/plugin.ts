// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: plugin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "df.plugin";

export enum GameMode {
  SURVIVAL = 0,
  CREATIVE = 1,
  ADVENTURE = 2,
  SPECTATOR = 3,
  UNRECOGNIZED = -1,
}

export function gameModeFromJSON(object: any): GameMode {
  switch (object) {
    case 0:
    case "SURVIVAL":
      return GameMode.SURVIVAL;
    case 1:
    case "CREATIVE":
      return GameMode.CREATIVE;
    case 2:
    case "ADVENTURE":
      return GameMode.ADVENTURE;
    case 3:
    case "SPECTATOR":
      return GameMode.SPECTATOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameMode.UNRECOGNIZED;
  }
}

export function gameModeToJSON(object: GameMode): string {
  switch (object) {
    case GameMode.SURVIVAL:
      return "SURVIVAL";
    case GameMode.CREATIVE:
      return "CREATIVE";
    case GameMode.ADVENTURE:
      return "ADVENTURE";
    case GameMode.SPECTATOR:
      return "SPECTATOR";
    case GameMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface HostToPlugin {
  pluginId: string;
  hello?: HostHello | undefined;
  shutdown?: HostShutdown | undefined;
  event?: EventEnvelope | undefined;
}

export interface HostHello {
  apiVersion: string;
}

export interface HostShutdown {
  reason: string;
}

export interface EventEnvelope {
  eventId: string;
  type: string;
  playerJoin?: PlayerJoinEvent | undefined;
  playerQuit?: PlayerQuitEvent | undefined;
  chat?: ChatEvent | undefined;
  command?: CommandEvent | undefined;
  blockBreak?: BlockBreakEvent | undefined;
  worldClose?: WorldCloseEvent | undefined;
}

export interface PlayerJoinEvent {
  playerUuid: string;
  name: string;
}

export interface PlayerQuitEvent {
  playerUuid: string;
  name: string;
}

export interface ChatEvent {
  playerUuid: string;
  name: string;
  message: string;
}

export interface CommandEvent {
  playerUuid: string;
  name: string;
  /** Full command string like "/tp 100 64 200" */
  raw: string;
  /** Just the command name like "tp" */
  command: string;
  /** Parsed arguments like ["100", "64", "200"] */
  args: string[];
}

export interface BlockBreakEvent {
  playerUuid: string;
  name: string;
  world: string;
  x: number;
  y: number;
  z: number;
}

export interface WorldCloseEvent {
}

export interface PluginToHost {
  pluginId: string;
  hello?: PluginHello | undefined;
  subscribe?: EventSubscribe | undefined;
  actions?: ActionBatch | undefined;
  log?: LogMessage | undefined;
  eventResult?: EventResult | undefined;
}

export interface PluginHello {
  name: string;
  version: string;
  apiVersion: string;
  commands: CommandSpec[];
}

export interface CommandSpec {
  name: string;
  description: string;
  aliases: string[];
}

export interface EventSubscribe {
  events: string[];
}

export interface ActionBatch {
  actions: Action[];
}

export interface Action {
  correlationId?: string | undefined;
  sendChat?: SendChatAction | undefined;
  teleport?: TeleportAction | undefined;
  kick?: KickAction | undefined;
  setGameMode?: SetGameModeAction | undefined;
}

export interface SendChatAction {
  targetUuid: string;
  message: string;
}

export interface TeleportAction {
  playerUuid: string;
  x: number;
  y: number;
  z: number;
  yaw: number;
  pitch: number;
}

export interface KickAction {
  playerUuid: string;
  reason: string;
}

export interface SetGameModeAction {
  playerUuid: string;
  gameMode: GameMode;
}

export interface LogMessage {
  level: string;
  message: string;
}

export interface EventResult {
  eventId: string;
  cancel?: boolean | undefined;
  chat?: ChatMutation | undefined;
  blockBreak?: BlockBreakMutation | undefined;
}

export interface ChatMutation {
  message: string;
}

export interface BlockBreakMutation {
  drops: ItemStack[];
  xp?: number | undefined;
}

export interface ItemStack {
  name: string;
  meta: number;
  count: number;
}

function createBaseHostToPlugin(): HostToPlugin {
  return { pluginId: "", hello: undefined, shutdown: undefined, event: undefined };
}

export const HostToPlugin: MessageFns<HostToPlugin> = {
  encode(message: HostToPlugin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pluginId !== "") {
      writer.uint32(10).string(message.pluginId);
    }
    if (message.hello !== undefined) {
      HostHello.encode(message.hello, writer.uint32(82).fork()).join();
    }
    if (message.shutdown !== undefined) {
      HostShutdown.encode(message.shutdown, writer.uint32(90).fork()).join();
    }
    if (message.event !== undefined) {
      EventEnvelope.encode(message.event, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostToPlugin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostToPlugin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pluginId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hello = HostHello.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.shutdown = HostShutdown.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.event = EventEnvelope.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostToPlugin {
    return {
      pluginId: isSet(object.pluginId) ? globalThis.String(object.pluginId) : "",
      hello: isSet(object.hello) ? HostHello.fromJSON(object.hello) : undefined,
      shutdown: isSet(object.shutdown) ? HostShutdown.fromJSON(object.shutdown) : undefined,
      event: isSet(object.event) ? EventEnvelope.fromJSON(object.event) : undefined,
    };
  },

  toJSON(message: HostToPlugin): unknown {
    const obj: any = {};
    if (message.pluginId !== "") {
      obj.pluginId = message.pluginId;
    }
    if (message.hello !== undefined) {
      obj.hello = HostHello.toJSON(message.hello);
    }
    if (message.shutdown !== undefined) {
      obj.shutdown = HostShutdown.toJSON(message.shutdown);
    }
    if (message.event !== undefined) {
      obj.event = EventEnvelope.toJSON(message.event);
    }
    return obj;
  },

  create(base?: DeepPartial<HostToPlugin>): HostToPlugin {
    return HostToPlugin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HostToPlugin>): HostToPlugin {
    const message = createBaseHostToPlugin();
    message.pluginId = object.pluginId ?? "";
    message.hello = (object.hello !== undefined && object.hello !== null)
      ? HostHello.fromPartial(object.hello)
      : undefined;
    message.shutdown = (object.shutdown !== undefined && object.shutdown !== null)
      ? HostShutdown.fromPartial(object.shutdown)
      : undefined;
    message.event = (object.event !== undefined && object.event !== null)
      ? EventEnvelope.fromPartial(object.event)
      : undefined;
    return message;
  },
};

function createBaseHostHello(): HostHello {
  return { apiVersion: "" };
}

export const HostHello: MessageFns<HostHello> = {
  encode(message: HostHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiVersion !== "") {
      writer.uint32(10).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostHello {
    return { apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "" };
  },

  toJSON(message: HostHello): unknown {
    const obj: any = {};
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<HostHello>): HostHello {
    return HostHello.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HostHello>): HostHello {
    const message = createBaseHostHello();
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseHostShutdown(): HostShutdown {
  return { reason: "" };
}

export const HostShutdown: MessageFns<HostShutdown> = {
  encode(message: HostShutdown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostShutdown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostShutdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostShutdown {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: HostShutdown): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<HostShutdown>): HostShutdown {
    return HostShutdown.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HostShutdown>): HostShutdown {
    const message = createBaseHostShutdown();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseEventEnvelope(): EventEnvelope {
  return {
    eventId: "",
    type: "",
    playerJoin: undefined,
    playerQuit: undefined,
    chat: undefined,
    command: undefined,
    blockBreak: undefined,
    worldClose: undefined,
  };
}

export const EventEnvelope: MessageFns<EventEnvelope> = {
  encode(message: EventEnvelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.playerJoin !== undefined) {
      PlayerJoinEvent.encode(message.playerJoin, writer.uint32(82).fork()).join();
    }
    if (message.playerQuit !== undefined) {
      PlayerQuitEvent.encode(message.playerQuit, writer.uint32(90).fork()).join();
    }
    if (message.chat !== undefined) {
      ChatEvent.encode(message.chat, writer.uint32(98).fork()).join();
    }
    if (message.command !== undefined) {
      CommandEvent.encode(message.command, writer.uint32(106).fork()).join();
    }
    if (message.blockBreak !== undefined) {
      BlockBreakEvent.encode(message.blockBreak, writer.uint32(114).fork()).join();
    }
    if (message.worldClose !== undefined) {
      WorldCloseEvent.encode(message.worldClose, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEnvelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.playerJoin = PlayerJoinEvent.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.playerQuit = PlayerQuitEvent.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.chat = ChatEvent.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.command = CommandEvent.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.blockBreak = BlockBreakEvent.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.worldClose = WorldCloseEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEnvelope {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      playerJoin: isSet(object.playerJoin) ? PlayerJoinEvent.fromJSON(object.playerJoin) : undefined,
      playerQuit: isSet(object.playerQuit) ? PlayerQuitEvent.fromJSON(object.playerQuit) : undefined,
      chat: isSet(object.chat) ? ChatEvent.fromJSON(object.chat) : undefined,
      command: isSet(object.command) ? CommandEvent.fromJSON(object.command) : undefined,
      blockBreak: isSet(object.blockBreak) ? BlockBreakEvent.fromJSON(object.blockBreak) : undefined,
      worldClose: isSet(object.worldClose) ? WorldCloseEvent.fromJSON(object.worldClose) : undefined,
    };
  },

  toJSON(message: EventEnvelope): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.playerJoin !== undefined) {
      obj.playerJoin = PlayerJoinEvent.toJSON(message.playerJoin);
    }
    if (message.playerQuit !== undefined) {
      obj.playerQuit = PlayerQuitEvent.toJSON(message.playerQuit);
    }
    if (message.chat !== undefined) {
      obj.chat = ChatEvent.toJSON(message.chat);
    }
    if (message.command !== undefined) {
      obj.command = CommandEvent.toJSON(message.command);
    }
    if (message.blockBreak !== undefined) {
      obj.blockBreak = BlockBreakEvent.toJSON(message.blockBreak);
    }
    if (message.worldClose !== undefined) {
      obj.worldClose = WorldCloseEvent.toJSON(message.worldClose);
    }
    return obj;
  },

  create(base?: DeepPartial<EventEnvelope>): EventEnvelope {
    return EventEnvelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventEnvelope>): EventEnvelope {
    const message = createBaseEventEnvelope();
    message.eventId = object.eventId ?? "";
    message.type = object.type ?? "";
    message.playerJoin = (object.playerJoin !== undefined && object.playerJoin !== null)
      ? PlayerJoinEvent.fromPartial(object.playerJoin)
      : undefined;
    message.playerQuit = (object.playerQuit !== undefined && object.playerQuit !== null)
      ? PlayerQuitEvent.fromPartial(object.playerQuit)
      : undefined;
    message.chat = (object.chat !== undefined && object.chat !== null) ? ChatEvent.fromPartial(object.chat) : undefined;
    message.command = (object.command !== undefined && object.command !== null)
      ? CommandEvent.fromPartial(object.command)
      : undefined;
    message.blockBreak = (object.blockBreak !== undefined && object.blockBreak !== null)
      ? BlockBreakEvent.fromPartial(object.blockBreak)
      : undefined;
    message.worldClose = (object.worldClose !== undefined && object.worldClose !== null)
      ? WorldCloseEvent.fromPartial(object.worldClose)
      : undefined;
    return message;
  },
};

function createBasePlayerJoinEvent(): PlayerJoinEvent {
  return { playerUuid: "", name: "" };
}

export const PlayerJoinEvent: MessageFns<PlayerJoinEvent> = {
  encode(message: PlayerJoinEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerJoinEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerJoinEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerJoinEvent {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: PlayerJoinEvent): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<PlayerJoinEvent>): PlayerJoinEvent {
    return PlayerJoinEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayerJoinEvent>): PlayerJoinEvent {
    const message = createBasePlayerJoinEvent();
    message.playerUuid = object.playerUuid ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePlayerQuitEvent(): PlayerQuitEvent {
  return { playerUuid: "", name: "" };
}

export const PlayerQuitEvent: MessageFns<PlayerQuitEvent> = {
  encode(message: PlayerQuitEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerQuitEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerQuitEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerQuitEvent {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: PlayerQuitEvent): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<PlayerQuitEvent>): PlayerQuitEvent {
    return PlayerQuitEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayerQuitEvent>): PlayerQuitEvent {
    const message = createBasePlayerQuitEvent();
    message.playerUuid = object.playerUuid ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseChatEvent(): ChatEvent {
  return { playerUuid: "", name: "", message: "" };
}

export const ChatEvent: MessageFns<ChatEvent> = {
  encode(message: ChatEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatEvent {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ChatEvent): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<ChatEvent>): ChatEvent {
    return ChatEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChatEvent>): ChatEvent {
    const message = createBaseChatEvent();
    message.playerUuid = object.playerUuid ?? "";
    message.name = object.name ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCommandEvent(): CommandEvent {
  return { playerUuid: "", name: "", raw: "", command: "", args: [] };
}

export const CommandEvent: MessageFns<CommandEvent> = {
  encode(message: CommandEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.raw !== "") {
      writer.uint32(26).string(message.raw);
    }
    if (message.command !== "") {
      writer.uint32(34).string(message.command);
    }
    for (const v of message.args) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.raw = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandEvent {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      raw: isSet(object.raw) ? globalThis.String(object.raw) : "",
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CommandEvent): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.raw !== "") {
      obj.raw = message.raw;
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    return obj;
  },

  create(base?: DeepPartial<CommandEvent>): CommandEvent {
    return CommandEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandEvent>): CommandEvent {
    const message = createBaseCommandEvent();
    message.playerUuid = object.playerUuid ?? "";
    message.name = object.name ?? "";
    message.raw = object.raw ?? "";
    message.command = object.command ?? "";
    message.args = object.args?.map((e) => e) || [];
    return message;
  },
};

function createBaseBlockBreakEvent(): BlockBreakEvent {
  return { playerUuid: "", name: "", world: "", x: 0, y: 0, z: 0 };
}

export const BlockBreakEvent: MessageFns<BlockBreakEvent> = {
  encode(message: BlockBreakEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.world !== "") {
      writer.uint32(26).string(message.world);
    }
    if (message.x !== 0) {
      writer.uint32(32).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(40).int32(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(48).int32(message.z);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockBreakEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockBreakEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.z = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockBreakEvent {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      world: isSet(object.world) ? globalThis.String(object.world) : "",
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: BlockBreakEvent): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.world !== "") {
      obj.world = message.world;
    }
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.z !== 0) {
      obj.z = Math.round(message.z);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockBreakEvent>): BlockBreakEvent {
    return BlockBreakEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockBreakEvent>): BlockBreakEvent {
    const message = createBaseBlockBreakEvent();
    message.playerUuid = object.playerUuid ?? "";
    message.name = object.name ?? "";
    message.world = object.world ?? "";
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBaseWorldCloseEvent(): WorldCloseEvent {
  return {};
}

export const WorldCloseEvent: MessageFns<WorldCloseEvent> = {
  encode(_: WorldCloseEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldCloseEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldCloseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WorldCloseEvent {
    return {};
  },

  toJSON(_: WorldCloseEvent): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<WorldCloseEvent>): WorldCloseEvent {
    return WorldCloseEvent.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<WorldCloseEvent>): WorldCloseEvent {
    const message = createBaseWorldCloseEvent();
    return message;
  },
};

function createBasePluginToHost(): PluginToHost {
  return {
    pluginId: "",
    hello: undefined,
    subscribe: undefined,
    actions: undefined,
    log: undefined,
    eventResult: undefined,
  };
}

export const PluginToHost: MessageFns<PluginToHost> = {
  encode(message: PluginToHost, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pluginId !== "") {
      writer.uint32(10).string(message.pluginId);
    }
    if (message.hello !== undefined) {
      PluginHello.encode(message.hello, writer.uint32(82).fork()).join();
    }
    if (message.subscribe !== undefined) {
      EventSubscribe.encode(message.subscribe, writer.uint32(90).fork()).join();
    }
    if (message.actions !== undefined) {
      ActionBatch.encode(message.actions, writer.uint32(162).fork()).join();
    }
    if (message.log !== undefined) {
      LogMessage.encode(message.log, writer.uint32(242).fork()).join();
    }
    if (message.eventResult !== undefined) {
      EventResult.encode(message.eventResult, writer.uint32(322).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginToHost {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginToHost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pluginId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hello = PluginHello.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.subscribe = EventSubscribe.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.actions = ActionBatch.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.log = LogMessage.decode(reader, reader.uint32());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.eventResult = EventResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginToHost {
    return {
      pluginId: isSet(object.pluginId) ? globalThis.String(object.pluginId) : "",
      hello: isSet(object.hello) ? PluginHello.fromJSON(object.hello) : undefined,
      subscribe: isSet(object.subscribe) ? EventSubscribe.fromJSON(object.subscribe) : undefined,
      actions: isSet(object.actions) ? ActionBatch.fromJSON(object.actions) : undefined,
      log: isSet(object.log) ? LogMessage.fromJSON(object.log) : undefined,
      eventResult: isSet(object.eventResult) ? EventResult.fromJSON(object.eventResult) : undefined,
    };
  },

  toJSON(message: PluginToHost): unknown {
    const obj: any = {};
    if (message.pluginId !== "") {
      obj.pluginId = message.pluginId;
    }
    if (message.hello !== undefined) {
      obj.hello = PluginHello.toJSON(message.hello);
    }
    if (message.subscribe !== undefined) {
      obj.subscribe = EventSubscribe.toJSON(message.subscribe);
    }
    if (message.actions !== undefined) {
      obj.actions = ActionBatch.toJSON(message.actions);
    }
    if (message.log !== undefined) {
      obj.log = LogMessage.toJSON(message.log);
    }
    if (message.eventResult !== undefined) {
      obj.eventResult = EventResult.toJSON(message.eventResult);
    }
    return obj;
  },

  create(base?: DeepPartial<PluginToHost>): PluginToHost {
    return PluginToHost.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PluginToHost>): PluginToHost {
    const message = createBasePluginToHost();
    message.pluginId = object.pluginId ?? "";
    message.hello = (object.hello !== undefined && object.hello !== null)
      ? PluginHello.fromPartial(object.hello)
      : undefined;
    message.subscribe = (object.subscribe !== undefined && object.subscribe !== null)
      ? EventSubscribe.fromPartial(object.subscribe)
      : undefined;
    message.actions = (object.actions !== undefined && object.actions !== null)
      ? ActionBatch.fromPartial(object.actions)
      : undefined;
    message.log = (object.log !== undefined && object.log !== null) ? LogMessage.fromPartial(object.log) : undefined;
    message.eventResult = (object.eventResult !== undefined && object.eventResult !== null)
      ? EventResult.fromPartial(object.eventResult)
      : undefined;
    return message;
  },
};

function createBasePluginHello(): PluginHello {
  return { name: "", version: "", apiVersion: "", commands: [] };
}

export const PluginHello: MessageFns<PluginHello> = {
  encode(message: PluginHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.apiVersion !== "") {
      writer.uint32(26).string(message.apiVersion);
    }
    for (const v of message.commands) {
      CommandSpec.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commands.push(CommandSpec.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginHello {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
      commands: globalThis.Array.isArray(object?.commands)
        ? object.commands.map((e: any) => CommandSpec.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PluginHello): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    if (message.commands?.length) {
      obj.commands = message.commands.map((e) => CommandSpec.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PluginHello>): PluginHello {
    return PluginHello.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PluginHello>): PluginHello {
    const message = createBasePluginHello();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.apiVersion = object.apiVersion ?? "";
    message.commands = object.commands?.map((e) => CommandSpec.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCommandSpec(): CommandSpec {
  return { name: "", description: "", aliases: [] };
}

export const CommandSpec: MessageFns<CommandSpec> = {
  encode(message: CommandSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.aliases) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aliases.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      aliases: globalThis.Array.isArray(object?.aliases) ? object.aliases.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CommandSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.aliases?.length) {
      obj.aliases = message.aliases;
    }
    return obj;
  },

  create(base?: DeepPartial<CommandSpec>): CommandSpec {
    return CommandSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandSpec>): CommandSpec {
    const message = createBaseCommandSpec();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.aliases = object.aliases?.map((e) => e) || [];
    return message;
  },
};

function createBaseEventSubscribe(): EventSubscribe {
  return { events: [] };
}

export const EventSubscribe: MessageFns<EventSubscribe> = {
  encode(message: EventSubscribe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubscribe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubscribe {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: EventSubscribe): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events;
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubscribe>): EventSubscribe {
    return EventSubscribe.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubscribe>): EventSubscribe {
    const message = createBaseEventSubscribe();
    message.events = object.events?.map((e) => e) || [];
    return message;
  },
};

function createBaseActionBatch(): ActionBatch {
  return { actions: [] };
}

export const ActionBatch: MessageFns<ActionBatch> = {
  encode(message: ActionBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      Action.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actions.push(Action.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionBatch {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => Action.fromJSON(e)) : [],
    };
  },

  toJSON(message: ActionBatch): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => Action.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ActionBatch>): ActionBatch {
    return ActionBatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionBatch>): ActionBatch {
    const message = createBaseActionBatch();
    message.actions = object.actions?.map((e) => Action.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAction(): Action {
  return {
    correlationId: undefined,
    sendChat: undefined,
    teleport: undefined,
    kick: undefined,
    setGameMode: undefined,
  };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.correlationId !== undefined) {
      writer.uint32(10).string(message.correlationId);
    }
    if (message.sendChat !== undefined) {
      SendChatAction.encode(message.sendChat, writer.uint32(82).fork()).join();
    }
    if (message.teleport !== undefined) {
      TeleportAction.encode(message.teleport, writer.uint32(90).fork()).join();
    }
    if (message.kick !== undefined) {
      KickAction.encode(message.kick, writer.uint32(98).fork()).join();
    }
    if (message.setGameMode !== undefined) {
      SetGameModeAction.encode(message.setGameMode, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.sendChat = SendChatAction.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.teleport = TeleportAction.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.kick = KickAction.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.setGameMode = SetGameModeAction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : undefined,
      sendChat: isSet(object.sendChat) ? SendChatAction.fromJSON(object.sendChat) : undefined,
      teleport: isSet(object.teleport) ? TeleportAction.fromJSON(object.teleport) : undefined,
      kick: isSet(object.kick) ? KickAction.fromJSON(object.kick) : undefined,
      setGameMode: isSet(object.setGameMode) ? SetGameModeAction.fromJSON(object.setGameMode) : undefined,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.correlationId !== undefined) {
      obj.correlationId = message.correlationId;
    }
    if (message.sendChat !== undefined) {
      obj.sendChat = SendChatAction.toJSON(message.sendChat);
    }
    if (message.teleport !== undefined) {
      obj.teleport = TeleportAction.toJSON(message.teleport);
    }
    if (message.kick !== undefined) {
      obj.kick = KickAction.toJSON(message.kick);
    }
    if (message.setGameMode !== undefined) {
      obj.setGameMode = SetGameModeAction.toJSON(message.setGameMode);
    }
    return obj;
  },

  create(base?: DeepPartial<Action>): Action {
    return Action.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Action>): Action {
    const message = createBaseAction();
    message.correlationId = object.correlationId ?? undefined;
    message.sendChat = (object.sendChat !== undefined && object.sendChat !== null)
      ? SendChatAction.fromPartial(object.sendChat)
      : undefined;
    message.teleport = (object.teleport !== undefined && object.teleport !== null)
      ? TeleportAction.fromPartial(object.teleport)
      : undefined;
    message.kick = (object.kick !== undefined && object.kick !== null)
      ? KickAction.fromPartial(object.kick)
      : undefined;
    message.setGameMode = (object.setGameMode !== undefined && object.setGameMode !== null)
      ? SetGameModeAction.fromPartial(object.setGameMode)
      : undefined;
    return message;
  },
};

function createBaseSendChatAction(): SendChatAction {
  return { targetUuid: "", message: "" };
}

export const SendChatAction: MessageFns<SendChatAction> = {
  encode(message: SendChatAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetUuid !== "") {
      writer.uint32(10).string(message.targetUuid);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendChatAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendChatAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.targetUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendChatAction {
    return {
      targetUuid: isSet(object.targetUuid) ? globalThis.String(object.targetUuid) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SendChatAction): unknown {
    const obj: any = {};
    if (message.targetUuid !== "") {
      obj.targetUuid = message.targetUuid;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<SendChatAction>): SendChatAction {
    return SendChatAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendChatAction>): SendChatAction {
    const message = createBaseSendChatAction();
    message.targetUuid = object.targetUuid ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTeleportAction(): TeleportAction {
  return { playerUuid: "", x: 0, y: 0, z: 0, yaw: 0, pitch: 0 };
}

export const TeleportAction: MessageFns<TeleportAction> = {
  encode(message: TeleportAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.x !== 0) {
      writer.uint32(17).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(25).double(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(33).double(message.z);
    }
    if (message.yaw !== 0) {
      writer.uint32(45).float(message.yaw);
    }
    if (message.pitch !== 0) {
      writer.uint32(53).float(message.pitch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeleportAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeleportAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.x = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.y = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.z = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.yaw = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.pitch = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeleportAction {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      yaw: isSet(object.yaw) ? globalThis.Number(object.yaw) : 0,
      pitch: isSet(object.pitch) ? globalThis.Number(object.pitch) : 0,
    };
  },

  toJSON(message: TeleportAction): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    if (message.yaw !== 0) {
      obj.yaw = message.yaw;
    }
    if (message.pitch !== 0) {
      obj.pitch = message.pitch;
    }
    return obj;
  },

  create(base?: DeepPartial<TeleportAction>): TeleportAction {
    return TeleportAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TeleportAction>): TeleportAction {
    const message = createBaseTeleportAction();
    message.playerUuid = object.playerUuid ?? "";
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.yaw = object.yaw ?? 0;
    message.pitch = object.pitch ?? 0;
    return message;
  },
};

function createBaseKickAction(): KickAction {
  return { playerUuid: "", reason: "" };
}

export const KickAction: MessageFns<KickAction> = {
  encode(message: KickAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KickAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKickAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KickAction {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: KickAction): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<KickAction>): KickAction {
    return KickAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KickAction>): KickAction {
    const message = createBaseKickAction();
    message.playerUuid = object.playerUuid ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseSetGameModeAction(): SetGameModeAction {
  return { playerUuid: "", gameMode: 0 };
}

export const SetGameModeAction: MessageFns<SetGameModeAction> = {
  encode(message: SetGameModeAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.gameMode !== 0) {
      writer.uint32(16).int32(message.gameMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetGameModeAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGameModeAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetGameModeAction {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      gameMode: isSet(object.gameMode) ? gameModeFromJSON(object.gameMode) : 0,
    };
  },

  toJSON(message: SetGameModeAction): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.gameMode !== 0) {
      obj.gameMode = gameModeToJSON(message.gameMode);
    }
    return obj;
  },

  create(base?: DeepPartial<SetGameModeAction>): SetGameModeAction {
    return SetGameModeAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetGameModeAction>): SetGameModeAction {
    const message = createBaseSetGameModeAction();
    message.playerUuid = object.playerUuid ?? "";
    message.gameMode = object.gameMode ?? 0;
    return message;
  },
};

function createBaseLogMessage(): LogMessage {
  return { level: "", message: "" };
}

export const LogMessage: MessageFns<LogMessage> = {
  encode(message: LogMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== "") {
      writer.uint32(10).string(message.level);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.level = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogMessage {
    return {
      level: isSet(object.level) ? globalThis.String(object.level) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: LogMessage): unknown {
    const obj: any = {};
    if (message.level !== "") {
      obj.level = message.level;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<LogMessage>): LogMessage {
    return LogMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogMessage>): LogMessage {
    const message = createBaseLogMessage();
    message.level = object.level ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseEventResult(): EventResult {
  return { eventId: "", cancel: undefined, chat: undefined, blockBreak: undefined };
}

export const EventResult: MessageFns<EventResult> = {
  encode(message: EventResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.cancel !== undefined) {
      writer.uint32(16).bool(message.cancel);
    }
    if (message.chat !== undefined) {
      ChatMutation.encode(message.chat, writer.uint32(82).fork()).join();
    }
    if (message.blockBreak !== undefined) {
      BlockBreakMutation.encode(message.blockBreak, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cancel = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.chat = ChatMutation.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.blockBreak = BlockBreakMutation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventResult {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      cancel: isSet(object.cancel) ? globalThis.Boolean(object.cancel) : undefined,
      chat: isSet(object.chat) ? ChatMutation.fromJSON(object.chat) : undefined,
      blockBreak: isSet(object.blockBreak) ? BlockBreakMutation.fromJSON(object.blockBreak) : undefined,
    };
  },

  toJSON(message: EventResult): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.cancel !== undefined) {
      obj.cancel = message.cancel;
    }
    if (message.chat !== undefined) {
      obj.chat = ChatMutation.toJSON(message.chat);
    }
    if (message.blockBreak !== undefined) {
      obj.blockBreak = BlockBreakMutation.toJSON(message.blockBreak);
    }
    return obj;
  },

  create(base?: DeepPartial<EventResult>): EventResult {
    return EventResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventResult>): EventResult {
    const message = createBaseEventResult();
    message.eventId = object.eventId ?? "";
    message.cancel = object.cancel ?? undefined;
    message.chat = (object.chat !== undefined && object.chat !== null)
      ? ChatMutation.fromPartial(object.chat)
      : undefined;
    message.blockBreak = (object.blockBreak !== undefined && object.blockBreak !== null)
      ? BlockBreakMutation.fromPartial(object.blockBreak)
      : undefined;
    return message;
  },
};

function createBaseChatMutation(): ChatMutation {
  return { message: "" };
}

export const ChatMutation: MessageFns<ChatMutation> = {
  encode(message: ChatMutation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMutation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMutation {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ChatMutation): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<ChatMutation>): ChatMutation {
    return ChatMutation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChatMutation>): ChatMutation {
    const message = createBaseChatMutation();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseBlockBreakMutation(): BlockBreakMutation {
  return { drops: [], xp: undefined };
}

export const BlockBreakMutation: MessageFns<BlockBreakMutation> = {
  encode(message: BlockBreakMutation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.drops) {
      ItemStack.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.xp !== undefined) {
      writer.uint32(16).int32(message.xp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockBreakMutation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockBreakMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.drops.push(ItemStack.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.xp = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockBreakMutation {
    return {
      drops: globalThis.Array.isArray(object?.drops) ? object.drops.map((e: any) => ItemStack.fromJSON(e)) : [],
      xp: isSet(object.xp) ? globalThis.Number(object.xp) : undefined,
    };
  },

  toJSON(message: BlockBreakMutation): unknown {
    const obj: any = {};
    if (message.drops?.length) {
      obj.drops = message.drops.map((e) => ItemStack.toJSON(e));
    }
    if (message.xp !== undefined) {
      obj.xp = Math.round(message.xp);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockBreakMutation>): BlockBreakMutation {
    return BlockBreakMutation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockBreakMutation>): BlockBreakMutation {
    const message = createBaseBlockBreakMutation();
    message.drops = object.drops?.map((e) => ItemStack.fromPartial(e)) || [];
    message.xp = object.xp ?? undefined;
    return message;
  },
};

function createBaseItemStack(): ItemStack {
  return { name: "", meta: 0, count: 0 };
}

export const ItemStack: MessageFns<ItemStack> = {
  encode(message: ItemStack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.meta !== 0) {
      writer.uint32(16).int32(message.meta);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemStack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemStack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.meta = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemStack {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      meta: isSet(object.meta) ? globalThis.Number(object.meta) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: ItemStack): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.meta !== 0) {
      obj.meta = Math.round(message.meta);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<ItemStack>): ItemStack {
    return ItemStack.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ItemStack>): ItemStack {
    const message = createBaseItemStack();
    message.name = object.name ?? "";
    message.meta = object.meta ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

export type PluginDefinition = typeof PluginDefinition;
export const PluginDefinition = {
  name: "Plugin",
  fullName: "df.plugin.Plugin",
  methods: {
    eventStream: {
      name: "EventStream",
      requestType: HostToPlugin,
      requestStream: true,
      responseType: PluginToHost,
      responseStream: true,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
