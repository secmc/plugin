// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: plugin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ActionBatch } from "./actions";
import { EventResult } from "./mutations";
import { BlockBreakEvent, ChatEvent, CommandEvent, PlayerJoinEvent, PlayerQuitEvent } from "./player_events";
import { WorldCloseEvent } from "./world_events";

export const protobufPackage = "df.plugin";

export enum EventType {
  EVENT_TYPE_UNSPECIFIED = 0,
  EVENT_TYPE_ALL = 1,
  PLAYER_JOIN = 10,
  PLAYER_QUIT = 11,
  PLAYER_MOVE = 12,
  PLAYER_JUMP = 13,
  PLAYER_TELEPORT = 14,
  PLAYER_CHANGE_WORLD = 15,
  PLAYER_TOGGLE_SPRINT = 16,
  PLAYER_TOGGLE_SNEAK = 17,
  CHAT = 18,
  PLAYER_FOOD_LOSS = 19,
  PLAYER_HEAL = 20,
  PLAYER_HURT = 21,
  PLAYER_DEATH = 22,
  PLAYER_RESPAWN = 23,
  PLAYER_SKIN_CHANGE = 24,
  PLAYER_FIRE_EXTINGUISH = 25,
  PLAYER_START_BREAK = 26,
  PLAYER_BLOCK_BREAK = 27,
  PLAYER_BLOCK_PLACE = 28,
  PLAYER_BLOCK_PICK = 29,
  PLAYER_ITEM_USE = 30,
  PLAYER_ITEM_USE_ON_BLOCK = 31,
  PLAYER_ITEM_USE_ON_ENTITY = 32,
  PLAYER_ITEM_RELEASE = 33,
  PLAYER_ITEM_CONSUME = 34,
  PLAYER_ATTACK_ENTITY = 35,
  PLAYER_EXPERIENCE_GAIN = 36,
  PLAYER_PUNCH_AIR = 37,
  PLAYER_SIGN_EDIT = 38,
  PLAYER_LECTERN_PAGE_TURN = 39,
  PLAYER_ITEM_DAMAGE = 40,
  PLAYER_ITEM_PICKUP = 41,
  PLAYER_HELD_SLOT_CHANGE = 42,
  PLAYER_ITEM_DROP = 43,
  PLAYER_TRANSFER = 44,
  COMMAND = 45,
  PLAYER_DIAGNOSTICS = 46,
  WORLD_LIQUID_FLOW = 70,
  WORLD_LIQUID_DECAY = 71,
  WORLD_LIQUID_HARDEN = 72,
  WORLD_SOUND = 73,
  WORLD_FIRE_SPREAD = 74,
  WORLD_BLOCK_BURN = 75,
  WORLD_CROP_TRAMPLE = 76,
  WORLD_LEAVES_DECAY = 77,
  WORLD_ENTITY_SPAWN = 78,
  WORLD_ENTITY_DESPAWN = 79,
  WORLD_EXPLOSION = 80,
  WORLD_CLOSE = 81,
  UNRECOGNIZED = -1,
}

export function eventTypeFromJSON(object: any): EventType {
  switch (object) {
    case 0:
    case "EVENT_TYPE_UNSPECIFIED":
      return EventType.EVENT_TYPE_UNSPECIFIED;
    case 1:
    case "EVENT_TYPE_ALL":
      return EventType.EVENT_TYPE_ALL;
    case 10:
    case "PLAYER_JOIN":
      return EventType.PLAYER_JOIN;
    case 11:
    case "PLAYER_QUIT":
      return EventType.PLAYER_QUIT;
    case 12:
    case "PLAYER_MOVE":
      return EventType.PLAYER_MOVE;
    case 13:
    case "PLAYER_JUMP":
      return EventType.PLAYER_JUMP;
    case 14:
    case "PLAYER_TELEPORT":
      return EventType.PLAYER_TELEPORT;
    case 15:
    case "PLAYER_CHANGE_WORLD":
      return EventType.PLAYER_CHANGE_WORLD;
    case 16:
    case "PLAYER_TOGGLE_SPRINT":
      return EventType.PLAYER_TOGGLE_SPRINT;
    case 17:
    case "PLAYER_TOGGLE_SNEAK":
      return EventType.PLAYER_TOGGLE_SNEAK;
    case 18:
    case "CHAT":
      return EventType.CHAT;
    case 19:
    case "PLAYER_FOOD_LOSS":
      return EventType.PLAYER_FOOD_LOSS;
    case 20:
    case "PLAYER_HEAL":
      return EventType.PLAYER_HEAL;
    case 21:
    case "PLAYER_HURT":
      return EventType.PLAYER_HURT;
    case 22:
    case "PLAYER_DEATH":
      return EventType.PLAYER_DEATH;
    case 23:
    case "PLAYER_RESPAWN":
      return EventType.PLAYER_RESPAWN;
    case 24:
    case "PLAYER_SKIN_CHANGE":
      return EventType.PLAYER_SKIN_CHANGE;
    case 25:
    case "PLAYER_FIRE_EXTINGUISH":
      return EventType.PLAYER_FIRE_EXTINGUISH;
    case 26:
    case "PLAYER_START_BREAK":
      return EventType.PLAYER_START_BREAK;
    case 27:
    case "PLAYER_BLOCK_BREAK":
      return EventType.PLAYER_BLOCK_BREAK;
    case 28:
    case "PLAYER_BLOCK_PLACE":
      return EventType.PLAYER_BLOCK_PLACE;
    case 29:
    case "PLAYER_BLOCK_PICK":
      return EventType.PLAYER_BLOCK_PICK;
    case 30:
    case "PLAYER_ITEM_USE":
      return EventType.PLAYER_ITEM_USE;
    case 31:
    case "PLAYER_ITEM_USE_ON_BLOCK":
      return EventType.PLAYER_ITEM_USE_ON_BLOCK;
    case 32:
    case "PLAYER_ITEM_USE_ON_ENTITY":
      return EventType.PLAYER_ITEM_USE_ON_ENTITY;
    case 33:
    case "PLAYER_ITEM_RELEASE":
      return EventType.PLAYER_ITEM_RELEASE;
    case 34:
    case "PLAYER_ITEM_CONSUME":
      return EventType.PLAYER_ITEM_CONSUME;
    case 35:
    case "PLAYER_ATTACK_ENTITY":
      return EventType.PLAYER_ATTACK_ENTITY;
    case 36:
    case "PLAYER_EXPERIENCE_GAIN":
      return EventType.PLAYER_EXPERIENCE_GAIN;
    case 37:
    case "PLAYER_PUNCH_AIR":
      return EventType.PLAYER_PUNCH_AIR;
    case 38:
    case "PLAYER_SIGN_EDIT":
      return EventType.PLAYER_SIGN_EDIT;
    case 39:
    case "PLAYER_LECTERN_PAGE_TURN":
      return EventType.PLAYER_LECTERN_PAGE_TURN;
    case 40:
    case "PLAYER_ITEM_DAMAGE":
      return EventType.PLAYER_ITEM_DAMAGE;
    case 41:
    case "PLAYER_ITEM_PICKUP":
      return EventType.PLAYER_ITEM_PICKUP;
    case 42:
    case "PLAYER_HELD_SLOT_CHANGE":
      return EventType.PLAYER_HELD_SLOT_CHANGE;
    case 43:
    case "PLAYER_ITEM_DROP":
      return EventType.PLAYER_ITEM_DROP;
    case 44:
    case "PLAYER_TRANSFER":
      return EventType.PLAYER_TRANSFER;
    case 45:
    case "COMMAND":
      return EventType.COMMAND;
    case 46:
    case "PLAYER_DIAGNOSTICS":
      return EventType.PLAYER_DIAGNOSTICS;
    case 70:
    case "WORLD_LIQUID_FLOW":
      return EventType.WORLD_LIQUID_FLOW;
    case 71:
    case "WORLD_LIQUID_DECAY":
      return EventType.WORLD_LIQUID_DECAY;
    case 72:
    case "WORLD_LIQUID_HARDEN":
      return EventType.WORLD_LIQUID_HARDEN;
    case 73:
    case "WORLD_SOUND":
      return EventType.WORLD_SOUND;
    case 74:
    case "WORLD_FIRE_SPREAD":
      return EventType.WORLD_FIRE_SPREAD;
    case 75:
    case "WORLD_BLOCK_BURN":
      return EventType.WORLD_BLOCK_BURN;
    case 76:
    case "WORLD_CROP_TRAMPLE":
      return EventType.WORLD_CROP_TRAMPLE;
    case 77:
    case "WORLD_LEAVES_DECAY":
      return EventType.WORLD_LEAVES_DECAY;
    case 78:
    case "WORLD_ENTITY_SPAWN":
      return EventType.WORLD_ENTITY_SPAWN;
    case 79:
    case "WORLD_ENTITY_DESPAWN":
      return EventType.WORLD_ENTITY_DESPAWN;
    case 80:
    case "WORLD_EXPLOSION":
      return EventType.WORLD_EXPLOSION;
    case 81:
    case "WORLD_CLOSE":
      return EventType.WORLD_CLOSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventType.UNRECOGNIZED;
  }
}

export function eventTypeToJSON(object: EventType): string {
  switch (object) {
    case EventType.EVENT_TYPE_UNSPECIFIED:
      return "EVENT_TYPE_UNSPECIFIED";
    case EventType.EVENT_TYPE_ALL:
      return "EVENT_TYPE_ALL";
    case EventType.PLAYER_JOIN:
      return "PLAYER_JOIN";
    case EventType.PLAYER_QUIT:
      return "PLAYER_QUIT";
    case EventType.PLAYER_MOVE:
      return "PLAYER_MOVE";
    case EventType.PLAYER_JUMP:
      return "PLAYER_JUMP";
    case EventType.PLAYER_TELEPORT:
      return "PLAYER_TELEPORT";
    case EventType.PLAYER_CHANGE_WORLD:
      return "PLAYER_CHANGE_WORLD";
    case EventType.PLAYER_TOGGLE_SPRINT:
      return "PLAYER_TOGGLE_SPRINT";
    case EventType.PLAYER_TOGGLE_SNEAK:
      return "PLAYER_TOGGLE_SNEAK";
    case EventType.CHAT:
      return "CHAT";
    case EventType.PLAYER_FOOD_LOSS:
      return "PLAYER_FOOD_LOSS";
    case EventType.PLAYER_HEAL:
      return "PLAYER_HEAL";
    case EventType.PLAYER_HURT:
      return "PLAYER_HURT";
    case EventType.PLAYER_DEATH:
      return "PLAYER_DEATH";
    case EventType.PLAYER_RESPAWN:
      return "PLAYER_RESPAWN";
    case EventType.PLAYER_SKIN_CHANGE:
      return "PLAYER_SKIN_CHANGE";
    case EventType.PLAYER_FIRE_EXTINGUISH:
      return "PLAYER_FIRE_EXTINGUISH";
    case EventType.PLAYER_START_BREAK:
      return "PLAYER_START_BREAK";
    case EventType.PLAYER_BLOCK_BREAK:
      return "PLAYER_BLOCK_BREAK";
    case EventType.PLAYER_BLOCK_PLACE:
      return "PLAYER_BLOCK_PLACE";
    case EventType.PLAYER_BLOCK_PICK:
      return "PLAYER_BLOCK_PICK";
    case EventType.PLAYER_ITEM_USE:
      return "PLAYER_ITEM_USE";
    case EventType.PLAYER_ITEM_USE_ON_BLOCK:
      return "PLAYER_ITEM_USE_ON_BLOCK";
    case EventType.PLAYER_ITEM_USE_ON_ENTITY:
      return "PLAYER_ITEM_USE_ON_ENTITY";
    case EventType.PLAYER_ITEM_RELEASE:
      return "PLAYER_ITEM_RELEASE";
    case EventType.PLAYER_ITEM_CONSUME:
      return "PLAYER_ITEM_CONSUME";
    case EventType.PLAYER_ATTACK_ENTITY:
      return "PLAYER_ATTACK_ENTITY";
    case EventType.PLAYER_EXPERIENCE_GAIN:
      return "PLAYER_EXPERIENCE_GAIN";
    case EventType.PLAYER_PUNCH_AIR:
      return "PLAYER_PUNCH_AIR";
    case EventType.PLAYER_SIGN_EDIT:
      return "PLAYER_SIGN_EDIT";
    case EventType.PLAYER_LECTERN_PAGE_TURN:
      return "PLAYER_LECTERN_PAGE_TURN";
    case EventType.PLAYER_ITEM_DAMAGE:
      return "PLAYER_ITEM_DAMAGE";
    case EventType.PLAYER_ITEM_PICKUP:
      return "PLAYER_ITEM_PICKUP";
    case EventType.PLAYER_HELD_SLOT_CHANGE:
      return "PLAYER_HELD_SLOT_CHANGE";
    case EventType.PLAYER_ITEM_DROP:
      return "PLAYER_ITEM_DROP";
    case EventType.PLAYER_TRANSFER:
      return "PLAYER_TRANSFER";
    case EventType.COMMAND:
      return "COMMAND";
    case EventType.PLAYER_DIAGNOSTICS:
      return "PLAYER_DIAGNOSTICS";
    case EventType.WORLD_LIQUID_FLOW:
      return "WORLD_LIQUID_FLOW";
    case EventType.WORLD_LIQUID_DECAY:
      return "WORLD_LIQUID_DECAY";
    case EventType.WORLD_LIQUID_HARDEN:
      return "WORLD_LIQUID_HARDEN";
    case EventType.WORLD_SOUND:
      return "WORLD_SOUND";
    case EventType.WORLD_FIRE_SPREAD:
      return "WORLD_FIRE_SPREAD";
    case EventType.WORLD_BLOCK_BURN:
      return "WORLD_BLOCK_BURN";
    case EventType.WORLD_CROP_TRAMPLE:
      return "WORLD_CROP_TRAMPLE";
    case EventType.WORLD_LEAVES_DECAY:
      return "WORLD_LEAVES_DECAY";
    case EventType.WORLD_ENTITY_SPAWN:
      return "WORLD_ENTITY_SPAWN";
    case EventType.WORLD_ENTITY_DESPAWN:
      return "WORLD_ENTITY_DESPAWN";
    case EventType.WORLD_EXPLOSION:
      return "WORLD_EXPLOSION";
    case EventType.WORLD_CLOSE:
      return "WORLD_CLOSE";
    case EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface HostToPlugin {
  pluginId: string;
  hello?: HostHello | undefined;
  shutdown?: HostShutdown | undefined;
  event?: EventEnvelope | undefined;
}

export interface HostHello {
  apiVersion: string;
}

export interface HostShutdown {
  reason: string;
}

export interface EventEnvelope {
  eventId: string;
  type: EventType;
  playerJoin?: PlayerJoinEvent | undefined;
  playerQuit?: PlayerQuitEvent | undefined;
  chat?: ChatEvent | undefined;
  command?: CommandEvent | undefined;
  blockBreak?: BlockBreakEvent | undefined;
  worldClose?: WorldCloseEvent | undefined;
}

export interface PluginToHost {
  pluginId: string;
  hello?: PluginHello | undefined;
  subscribe?: EventSubscribe | undefined;
  actions?: ActionBatch | undefined;
  log?: LogMessage | undefined;
  eventResult?: EventResult | undefined;
}

export interface PluginHello {
  name: string;
  version: string;
  apiVersion: string;
  commands: CommandSpec[];
}

export interface CommandSpec {
  name: string;
  description: string;
  aliases: string[];
}

export interface LogMessage {
  level: string;
  message: string;
}

export interface EventSubscribe {
  events: EventType[];
}

function createBaseHostToPlugin(): HostToPlugin {
  return { pluginId: "", hello: undefined, shutdown: undefined, event: undefined };
}

export const HostToPlugin: MessageFns<HostToPlugin> = {
  encode(message: HostToPlugin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pluginId !== "") {
      writer.uint32(10).string(message.pluginId);
    }
    if (message.hello !== undefined) {
      HostHello.encode(message.hello, writer.uint32(82).fork()).join();
    }
    if (message.shutdown !== undefined) {
      HostShutdown.encode(message.shutdown, writer.uint32(90).fork()).join();
    }
    if (message.event !== undefined) {
      EventEnvelope.encode(message.event, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostToPlugin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostToPlugin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pluginId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hello = HostHello.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.shutdown = HostShutdown.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.event = EventEnvelope.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostToPlugin {
    return {
      pluginId: isSet(object.pluginId) ? globalThis.String(object.pluginId) : "",
      hello: isSet(object.hello) ? HostHello.fromJSON(object.hello) : undefined,
      shutdown: isSet(object.shutdown) ? HostShutdown.fromJSON(object.shutdown) : undefined,
      event: isSet(object.event) ? EventEnvelope.fromJSON(object.event) : undefined,
    };
  },

  toJSON(message: HostToPlugin): unknown {
    const obj: any = {};
    if (message.pluginId !== "") {
      obj.pluginId = message.pluginId;
    }
    if (message.hello !== undefined) {
      obj.hello = HostHello.toJSON(message.hello);
    }
    if (message.shutdown !== undefined) {
      obj.shutdown = HostShutdown.toJSON(message.shutdown);
    }
    if (message.event !== undefined) {
      obj.event = EventEnvelope.toJSON(message.event);
    }
    return obj;
  },

  create(base?: DeepPartial<HostToPlugin>): HostToPlugin {
    return HostToPlugin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HostToPlugin>): HostToPlugin {
    const message = createBaseHostToPlugin();
    message.pluginId = object.pluginId ?? "";
    message.hello = (object.hello !== undefined && object.hello !== null)
      ? HostHello.fromPartial(object.hello)
      : undefined;
    message.shutdown = (object.shutdown !== undefined && object.shutdown !== null)
      ? HostShutdown.fromPartial(object.shutdown)
      : undefined;
    message.event = (object.event !== undefined && object.event !== null)
      ? EventEnvelope.fromPartial(object.event)
      : undefined;
    return message;
  },
};

function createBaseHostHello(): HostHello {
  return { apiVersion: "" };
}

export const HostHello: MessageFns<HostHello> = {
  encode(message: HostHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiVersion !== "") {
      writer.uint32(10).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostHello {
    return { apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "" };
  },

  toJSON(message: HostHello): unknown {
    const obj: any = {};
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<HostHello>): HostHello {
    return HostHello.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HostHello>): HostHello {
    const message = createBaseHostHello();
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseHostShutdown(): HostShutdown {
  return { reason: "" };
}

export const HostShutdown: MessageFns<HostShutdown> = {
  encode(message: HostShutdown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostShutdown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostShutdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostShutdown {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: HostShutdown): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<HostShutdown>): HostShutdown {
    return HostShutdown.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HostShutdown>): HostShutdown {
    const message = createBaseHostShutdown();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseEventEnvelope(): EventEnvelope {
  return {
    eventId: "",
    type: 0,
    playerJoin: undefined,
    playerQuit: undefined,
    chat: undefined,
    command: undefined,
    blockBreak: undefined,
    worldClose: undefined,
  };
}

export const EventEnvelope: MessageFns<EventEnvelope> = {
  encode(message: EventEnvelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.playerJoin !== undefined) {
      PlayerJoinEvent.encode(message.playerJoin, writer.uint32(82).fork()).join();
    }
    if (message.playerQuit !== undefined) {
      PlayerQuitEvent.encode(message.playerQuit, writer.uint32(90).fork()).join();
    }
    if (message.chat !== undefined) {
      ChatEvent.encode(message.chat, writer.uint32(98).fork()).join();
    }
    if (message.command !== undefined) {
      CommandEvent.encode(message.command, writer.uint32(106).fork()).join();
    }
    if (message.blockBreak !== undefined) {
      BlockBreakEvent.encode(message.blockBreak, writer.uint32(114).fork()).join();
    }
    if (message.worldClose !== undefined) {
      WorldCloseEvent.encode(message.worldClose, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEnvelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.playerJoin = PlayerJoinEvent.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.playerQuit = PlayerQuitEvent.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.chat = ChatEvent.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.command = CommandEvent.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.blockBreak = BlockBreakEvent.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.worldClose = WorldCloseEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEnvelope {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      type: isSet(object.type) ? eventTypeFromJSON(object.type) : 0,
      playerJoin: isSet(object.playerJoin) ? PlayerJoinEvent.fromJSON(object.playerJoin) : undefined,
      playerQuit: isSet(object.playerQuit) ? PlayerQuitEvent.fromJSON(object.playerQuit) : undefined,
      chat: isSet(object.chat) ? ChatEvent.fromJSON(object.chat) : undefined,
      command: isSet(object.command) ? CommandEvent.fromJSON(object.command) : undefined,
      blockBreak: isSet(object.blockBreak) ? BlockBreakEvent.fromJSON(object.blockBreak) : undefined,
      worldClose: isSet(object.worldClose) ? WorldCloseEvent.fromJSON(object.worldClose) : undefined,
    };
  },

  toJSON(message: EventEnvelope): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.type !== 0) {
      obj.type = eventTypeToJSON(message.type);
    }
    if (message.playerJoin !== undefined) {
      obj.playerJoin = PlayerJoinEvent.toJSON(message.playerJoin);
    }
    if (message.playerQuit !== undefined) {
      obj.playerQuit = PlayerQuitEvent.toJSON(message.playerQuit);
    }
    if (message.chat !== undefined) {
      obj.chat = ChatEvent.toJSON(message.chat);
    }
    if (message.command !== undefined) {
      obj.command = CommandEvent.toJSON(message.command);
    }
    if (message.blockBreak !== undefined) {
      obj.blockBreak = BlockBreakEvent.toJSON(message.blockBreak);
    }
    if (message.worldClose !== undefined) {
      obj.worldClose = WorldCloseEvent.toJSON(message.worldClose);
    }
    return obj;
  },

  create(base?: DeepPartial<EventEnvelope>): EventEnvelope {
    return EventEnvelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventEnvelope>): EventEnvelope {
    const message = createBaseEventEnvelope();
    message.eventId = object.eventId ?? "";
    message.type = object.type ?? 0;
    message.playerJoin = (object.playerJoin !== undefined && object.playerJoin !== null)
      ? PlayerJoinEvent.fromPartial(object.playerJoin)
      : undefined;
    message.playerQuit = (object.playerQuit !== undefined && object.playerQuit !== null)
      ? PlayerQuitEvent.fromPartial(object.playerQuit)
      : undefined;
    message.chat = (object.chat !== undefined && object.chat !== null) ? ChatEvent.fromPartial(object.chat) : undefined;
    message.command = (object.command !== undefined && object.command !== null)
      ? CommandEvent.fromPartial(object.command)
      : undefined;
    message.blockBreak = (object.blockBreak !== undefined && object.blockBreak !== null)
      ? BlockBreakEvent.fromPartial(object.blockBreak)
      : undefined;
    message.worldClose = (object.worldClose !== undefined && object.worldClose !== null)
      ? WorldCloseEvent.fromPartial(object.worldClose)
      : undefined;
    return message;
  },
};

function createBasePluginToHost(): PluginToHost {
  return {
    pluginId: "",
    hello: undefined,
    subscribe: undefined,
    actions: undefined,
    log: undefined,
    eventResult: undefined,
  };
}

export const PluginToHost: MessageFns<PluginToHost> = {
  encode(message: PluginToHost, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pluginId !== "") {
      writer.uint32(10).string(message.pluginId);
    }
    if (message.hello !== undefined) {
      PluginHello.encode(message.hello, writer.uint32(82).fork()).join();
    }
    if (message.subscribe !== undefined) {
      EventSubscribe.encode(message.subscribe, writer.uint32(90).fork()).join();
    }
    if (message.actions !== undefined) {
      ActionBatch.encode(message.actions, writer.uint32(162).fork()).join();
    }
    if (message.log !== undefined) {
      LogMessage.encode(message.log, writer.uint32(242).fork()).join();
    }
    if (message.eventResult !== undefined) {
      EventResult.encode(message.eventResult, writer.uint32(322).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginToHost {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginToHost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pluginId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hello = PluginHello.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.subscribe = EventSubscribe.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.actions = ActionBatch.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.log = LogMessage.decode(reader, reader.uint32());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.eventResult = EventResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginToHost {
    return {
      pluginId: isSet(object.pluginId) ? globalThis.String(object.pluginId) : "",
      hello: isSet(object.hello) ? PluginHello.fromJSON(object.hello) : undefined,
      subscribe: isSet(object.subscribe) ? EventSubscribe.fromJSON(object.subscribe) : undefined,
      actions: isSet(object.actions) ? ActionBatch.fromJSON(object.actions) : undefined,
      log: isSet(object.log) ? LogMessage.fromJSON(object.log) : undefined,
      eventResult: isSet(object.eventResult) ? EventResult.fromJSON(object.eventResult) : undefined,
    };
  },

  toJSON(message: PluginToHost): unknown {
    const obj: any = {};
    if (message.pluginId !== "") {
      obj.pluginId = message.pluginId;
    }
    if (message.hello !== undefined) {
      obj.hello = PluginHello.toJSON(message.hello);
    }
    if (message.subscribe !== undefined) {
      obj.subscribe = EventSubscribe.toJSON(message.subscribe);
    }
    if (message.actions !== undefined) {
      obj.actions = ActionBatch.toJSON(message.actions);
    }
    if (message.log !== undefined) {
      obj.log = LogMessage.toJSON(message.log);
    }
    if (message.eventResult !== undefined) {
      obj.eventResult = EventResult.toJSON(message.eventResult);
    }
    return obj;
  },

  create(base?: DeepPartial<PluginToHost>): PluginToHost {
    return PluginToHost.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PluginToHost>): PluginToHost {
    const message = createBasePluginToHost();
    message.pluginId = object.pluginId ?? "";
    message.hello = (object.hello !== undefined && object.hello !== null)
      ? PluginHello.fromPartial(object.hello)
      : undefined;
    message.subscribe = (object.subscribe !== undefined && object.subscribe !== null)
      ? EventSubscribe.fromPartial(object.subscribe)
      : undefined;
    message.actions = (object.actions !== undefined && object.actions !== null)
      ? ActionBatch.fromPartial(object.actions)
      : undefined;
    message.log = (object.log !== undefined && object.log !== null) ? LogMessage.fromPartial(object.log) : undefined;
    message.eventResult = (object.eventResult !== undefined && object.eventResult !== null)
      ? EventResult.fromPartial(object.eventResult)
      : undefined;
    return message;
  },
};

function createBasePluginHello(): PluginHello {
  return { name: "", version: "", apiVersion: "", commands: [] };
}

export const PluginHello: MessageFns<PluginHello> = {
  encode(message: PluginHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.apiVersion !== "") {
      writer.uint32(26).string(message.apiVersion);
    }
    for (const v of message.commands) {
      CommandSpec.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commands.push(CommandSpec.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginHello {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
      commands: globalThis.Array.isArray(object?.commands)
        ? object.commands.map((e: any) => CommandSpec.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PluginHello): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    if (message.commands?.length) {
      obj.commands = message.commands.map((e) => CommandSpec.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PluginHello>): PluginHello {
    return PluginHello.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PluginHello>): PluginHello {
    const message = createBasePluginHello();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.apiVersion = object.apiVersion ?? "";
    message.commands = object.commands?.map((e) => CommandSpec.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCommandSpec(): CommandSpec {
  return { name: "", description: "", aliases: [] };
}

export const CommandSpec: MessageFns<CommandSpec> = {
  encode(message: CommandSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.aliases) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aliases.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      aliases: globalThis.Array.isArray(object?.aliases) ? object.aliases.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CommandSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.aliases?.length) {
      obj.aliases = message.aliases;
    }
    return obj;
  },

  create(base?: DeepPartial<CommandSpec>): CommandSpec {
    return CommandSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandSpec>): CommandSpec {
    const message = createBaseCommandSpec();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.aliases = object.aliases?.map((e) => e) || [];
    return message;
  },
};

function createBaseLogMessage(): LogMessage {
  return { level: "", message: "" };
}

export const LogMessage: MessageFns<LogMessage> = {
  encode(message: LogMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== "") {
      writer.uint32(10).string(message.level);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.level = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogMessage {
    return {
      level: isSet(object.level) ? globalThis.String(object.level) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: LogMessage): unknown {
    const obj: any = {};
    if (message.level !== "") {
      obj.level = message.level;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<LogMessage>): LogMessage {
    return LogMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogMessage>): LogMessage {
    const message = createBaseLogMessage();
    message.level = object.level ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseEventSubscribe(): EventSubscribe {
  return { events: [] };
}

export const EventSubscribe: MessageFns<EventSubscribe> = {
  encode(message: EventSubscribe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.events) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubscribe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.events.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.events.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubscribe {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => eventTypeFromJSON(e)) : [],
    };
  },

  toJSON(message: EventSubscribe): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => eventTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubscribe>): EventSubscribe {
    return EventSubscribe.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubscribe>): EventSubscribe {
    const message = createBaseEventSubscribe();
    message.events = object.events?.map((e) => e) || [];
    return message;
  },
};

export type PluginDefinition = typeof PluginDefinition;
export const PluginDefinition = {
  name: "Plugin",
  fullName: "df.plugin.Plugin",
  methods: {
    eventStream: {
      name: "EventStream",
      requestType: PluginToHost,
      requestStream: true,
      responseType: HostToPlugin,
      responseStream: true,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
