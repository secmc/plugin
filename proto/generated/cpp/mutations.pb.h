// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: mutations.proto
// Protobuf C++ Version: 6.33.1

#ifndef mutations_2eproto_2epb_2eh
#define mutations_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "actions.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_mutations_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_mutations_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_mutations_2eproto;
}  // extern "C"
namespace df {
namespace plugin {
class BlockBreakMutation;
struct BlockBreakMutationDefaultTypeInternal;
extern BlockBreakMutationDefaultTypeInternal _BlockBreakMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BlockBreakMutation_class_data_;
class BlockPosList;
struct BlockPosListDefaultTypeInternal;
extern BlockPosListDefaultTypeInternal _BlockPosList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BlockPosList_class_data_;
class ChatMutation;
struct ChatMutationDefaultTypeInternal;
extern ChatMutationDefaultTypeInternal _ChatMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ChatMutation_class_data_;
class EventResult;
struct EventResultDefaultTypeInternal;
extern EventResultDefaultTypeInternal _EventResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EventResult_class_data_;
class ItemStackList;
struct ItemStackListDefaultTypeInternal;
extern ItemStackListDefaultTypeInternal _ItemStackList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ItemStackList_class_data_;
class PlayerAttackEntityMutation;
struct PlayerAttackEntityMutationDefaultTypeInternal;
extern PlayerAttackEntityMutationDefaultTypeInternal _PlayerAttackEntityMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerAttackEntityMutation_class_data_;
class PlayerDeathMutation;
struct PlayerDeathMutationDefaultTypeInternal;
extern PlayerDeathMutationDefaultTypeInternal _PlayerDeathMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerDeathMutation_class_data_;
class PlayerExperienceGainMutation;
struct PlayerExperienceGainMutationDefaultTypeInternal;
extern PlayerExperienceGainMutationDefaultTypeInternal _PlayerExperienceGainMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerExperienceGainMutation_class_data_;
class PlayerFoodLossMutation;
struct PlayerFoodLossMutationDefaultTypeInternal;
extern PlayerFoodLossMutationDefaultTypeInternal _PlayerFoodLossMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerFoodLossMutation_class_data_;
class PlayerHealMutation;
struct PlayerHealMutationDefaultTypeInternal;
extern PlayerHealMutationDefaultTypeInternal _PlayerHealMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerHealMutation_class_data_;
class PlayerHurtMutation;
struct PlayerHurtMutationDefaultTypeInternal;
extern PlayerHurtMutationDefaultTypeInternal _PlayerHurtMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerHurtMutation_class_data_;
class PlayerItemPickupMutation;
struct PlayerItemPickupMutationDefaultTypeInternal;
extern PlayerItemPickupMutationDefaultTypeInternal _PlayerItemPickupMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerItemPickupMutation_class_data_;
class PlayerLecternPageTurnMutation;
struct PlayerLecternPageTurnMutationDefaultTypeInternal;
extern PlayerLecternPageTurnMutationDefaultTypeInternal _PlayerLecternPageTurnMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerLecternPageTurnMutation_class_data_;
class PlayerRespawnMutation;
struct PlayerRespawnMutationDefaultTypeInternal;
extern PlayerRespawnMutationDefaultTypeInternal _PlayerRespawnMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerRespawnMutation_class_data_;
class PlayerTransferMutation;
struct PlayerTransferMutationDefaultTypeInternal;
extern PlayerTransferMutationDefaultTypeInternal _PlayerTransferMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerTransferMutation_class_data_;
class StringList;
struct StringListDefaultTypeInternal;
extern StringListDefaultTypeInternal _StringList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StringList_class_data_;
class WorldExplosionMutation;
struct WorldExplosionMutationDefaultTypeInternal;
extern WorldExplosionMutationDefaultTypeInternal _WorldExplosionMutation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WorldExplosionMutation_class_data_;
}  // namespace plugin
}  // namespace df
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace df {
namespace plugin {

// ===================================================================


// -------------------------------------------------------------------

class StringList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.StringList) */ {
 public:
  inline StringList() : StringList(nullptr) {}
  ~StringList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StringList* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StringList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StringList(::google::protobuf::internal::ConstantInitialized);

  inline StringList(const StringList& from) : StringList(nullptr, from) {}
  inline StringList(StringList&& from) noexcept
      : StringList(nullptr, ::std::move(from)) {}
  inline StringList& operator=(const StringList& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringList& operator=(StringList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringList& default_instance() {
    return *reinterpret_cast<const StringList*>(
        &_StringList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(StringList& a, StringList& b) { a.Swap(&b); }
  inline void Swap(StringList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StringList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StringList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StringList& from) { StringList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StringList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.StringList"; }

  explicit StringList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StringList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StringList& from);
  StringList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StringList&& from) noexcept
      : StringList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1 [json_name = "values"];
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  const ::std::string& values(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_values(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_values(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_values();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_values(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.StringList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 35,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StringList& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> values_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StringList_class_data_;
// -------------------------------------------------------------------

class PlayerLecternPageTurnMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PlayerLecternPageTurnMutation) */ {
 public:
  inline PlayerLecternPageTurnMutation() : PlayerLecternPageTurnMutation(nullptr) {}
  ~PlayerLecternPageTurnMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerLecternPageTurnMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerLecternPageTurnMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerLecternPageTurnMutation(::google::protobuf::internal::ConstantInitialized);

  inline PlayerLecternPageTurnMutation(const PlayerLecternPageTurnMutation& from) : PlayerLecternPageTurnMutation(nullptr, from) {}
  inline PlayerLecternPageTurnMutation(PlayerLecternPageTurnMutation&& from) noexcept
      : PlayerLecternPageTurnMutation(nullptr, ::std::move(from)) {}
  inline PlayerLecternPageTurnMutation& operator=(const PlayerLecternPageTurnMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerLecternPageTurnMutation& operator=(PlayerLecternPageTurnMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerLecternPageTurnMutation& default_instance() {
    return *reinterpret_cast<const PlayerLecternPageTurnMutation*>(
        &_PlayerLecternPageTurnMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(PlayerLecternPageTurnMutation& a, PlayerLecternPageTurnMutation& b) { a.Swap(&b); }
  inline void Swap(PlayerLecternPageTurnMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerLecternPageTurnMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerLecternPageTurnMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerLecternPageTurnMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerLecternPageTurnMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerLecternPageTurnMutation& from) { PlayerLecternPageTurnMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerLecternPageTurnMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PlayerLecternPageTurnMutation"; }

  explicit PlayerLecternPageTurnMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerLecternPageTurnMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerLecternPageTurnMutation& from);
  PlayerLecternPageTurnMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerLecternPageTurnMutation&& from) noexcept
      : PlayerLecternPageTurnMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewPageFieldNumber = 1,
  };
  // optional int32 new_page = 1 [json_name = "newPage"];
  bool has_new_page() const;
  void clear_new_page() ;
  ::int32_t new_page() const;
  void set_new_page(::int32_t value);

  private:
  ::int32_t _internal_new_page() const;
  void _internal_set_new_page(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.PlayerLecternPageTurnMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerLecternPageTurnMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t new_page_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerLecternPageTurnMutation_class_data_;
// -------------------------------------------------------------------

class PlayerHurtMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PlayerHurtMutation) */ {
 public:
  inline PlayerHurtMutation() : PlayerHurtMutation(nullptr) {}
  ~PlayerHurtMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerHurtMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerHurtMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerHurtMutation(::google::protobuf::internal::ConstantInitialized);

  inline PlayerHurtMutation(const PlayerHurtMutation& from) : PlayerHurtMutation(nullptr, from) {}
  inline PlayerHurtMutation(PlayerHurtMutation&& from) noexcept
      : PlayerHurtMutation(nullptr, ::std::move(from)) {}
  inline PlayerHurtMutation& operator=(const PlayerHurtMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerHurtMutation& operator=(PlayerHurtMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerHurtMutation& default_instance() {
    return *reinterpret_cast<const PlayerHurtMutation*>(
        &_PlayerHurtMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(PlayerHurtMutation& a, PlayerHurtMutation& b) { a.Swap(&b); }
  inline void Swap(PlayerHurtMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerHurtMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerHurtMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerHurtMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerHurtMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerHurtMutation& from) { PlayerHurtMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerHurtMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PlayerHurtMutation"; }

  explicit PlayerHurtMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerHurtMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerHurtMutation& from);
  PlayerHurtMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerHurtMutation&& from) noexcept
      : PlayerHurtMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDamageFieldNumber = 1,
    kAttackImmunityMsFieldNumber = 2,
  };
  // optional double damage = 1 [json_name = "damage"];
  bool has_damage() const;
  void clear_damage() ;
  double damage() const;
  void set_damage(double value);

  private:
  double _internal_damage() const;
  void _internal_set_damage(double value);

  public:
  // optional int64 attack_immunity_ms = 2 [json_name = "attackImmunityMs"];
  bool has_attack_immunity_ms() const;
  void clear_attack_immunity_ms() ;
  ::int64_t attack_immunity_ms() const;
  void set_attack_immunity_ms(::int64_t value);

  private:
  ::int64_t _internal_attack_immunity_ms() const;
  void _internal_set_attack_immunity_ms(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.PlayerHurtMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerHurtMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double damage_;
    ::int64_t attack_immunity_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerHurtMutation_class_data_;
// -------------------------------------------------------------------

class PlayerHealMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PlayerHealMutation) */ {
 public:
  inline PlayerHealMutation() : PlayerHealMutation(nullptr) {}
  ~PlayerHealMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerHealMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerHealMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerHealMutation(::google::protobuf::internal::ConstantInitialized);

  inline PlayerHealMutation(const PlayerHealMutation& from) : PlayerHealMutation(nullptr, from) {}
  inline PlayerHealMutation(PlayerHealMutation&& from) noexcept
      : PlayerHealMutation(nullptr, ::std::move(from)) {}
  inline PlayerHealMutation& operator=(const PlayerHealMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerHealMutation& operator=(PlayerHealMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerHealMutation& default_instance() {
    return *reinterpret_cast<const PlayerHealMutation*>(
        &_PlayerHealMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(PlayerHealMutation& a, PlayerHealMutation& b) { a.Swap(&b); }
  inline void Swap(PlayerHealMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerHealMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerHealMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerHealMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerHealMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerHealMutation& from) { PlayerHealMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerHealMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PlayerHealMutation"; }

  explicit PlayerHealMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerHealMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerHealMutation& from);
  PlayerHealMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerHealMutation&& from) noexcept
      : PlayerHealMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAmountFieldNumber = 1,
  };
  // optional double amount = 1 [json_name = "amount"];
  bool has_amount() const;
  void clear_amount() ;
  double amount() const;
  void set_amount(double value);

  private:
  double _internal_amount() const;
  void _internal_set_amount(double value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.PlayerHealMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerHealMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double amount_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerHealMutation_class_data_;
// -------------------------------------------------------------------

class PlayerFoodLossMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PlayerFoodLossMutation) */ {
 public:
  inline PlayerFoodLossMutation() : PlayerFoodLossMutation(nullptr) {}
  ~PlayerFoodLossMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerFoodLossMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerFoodLossMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerFoodLossMutation(::google::protobuf::internal::ConstantInitialized);

  inline PlayerFoodLossMutation(const PlayerFoodLossMutation& from) : PlayerFoodLossMutation(nullptr, from) {}
  inline PlayerFoodLossMutation(PlayerFoodLossMutation&& from) noexcept
      : PlayerFoodLossMutation(nullptr, ::std::move(from)) {}
  inline PlayerFoodLossMutation& operator=(const PlayerFoodLossMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerFoodLossMutation& operator=(PlayerFoodLossMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerFoodLossMutation& default_instance() {
    return *reinterpret_cast<const PlayerFoodLossMutation*>(
        &_PlayerFoodLossMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PlayerFoodLossMutation& a, PlayerFoodLossMutation& b) { a.Swap(&b); }
  inline void Swap(PlayerFoodLossMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerFoodLossMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerFoodLossMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerFoodLossMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerFoodLossMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerFoodLossMutation& from) { PlayerFoodLossMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerFoodLossMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PlayerFoodLossMutation"; }

  explicit PlayerFoodLossMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerFoodLossMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerFoodLossMutation& from);
  PlayerFoodLossMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerFoodLossMutation&& from) noexcept
      : PlayerFoodLossMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kToFieldNumber = 1,
  };
  // optional int32 to = 1 [json_name = "to"];
  bool has_to() const;
  void clear_to() ;
  ::int32_t to() const;
  void set_to(::int32_t value);

  private:
  ::int32_t _internal_to() const;
  void _internal_set_to(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.PlayerFoodLossMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerFoodLossMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t to_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerFoodLossMutation_class_data_;
// -------------------------------------------------------------------

class PlayerExperienceGainMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PlayerExperienceGainMutation) */ {
 public:
  inline PlayerExperienceGainMutation() : PlayerExperienceGainMutation(nullptr) {}
  ~PlayerExperienceGainMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerExperienceGainMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerExperienceGainMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerExperienceGainMutation(::google::protobuf::internal::ConstantInitialized);

  inline PlayerExperienceGainMutation(const PlayerExperienceGainMutation& from) : PlayerExperienceGainMutation(nullptr, from) {}
  inline PlayerExperienceGainMutation(PlayerExperienceGainMutation&& from) noexcept
      : PlayerExperienceGainMutation(nullptr, ::std::move(from)) {}
  inline PlayerExperienceGainMutation& operator=(const PlayerExperienceGainMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerExperienceGainMutation& operator=(PlayerExperienceGainMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerExperienceGainMutation& default_instance() {
    return *reinterpret_cast<const PlayerExperienceGainMutation*>(
        &_PlayerExperienceGainMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(PlayerExperienceGainMutation& a, PlayerExperienceGainMutation& b) { a.Swap(&b); }
  inline void Swap(PlayerExperienceGainMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerExperienceGainMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerExperienceGainMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerExperienceGainMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerExperienceGainMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerExperienceGainMutation& from) { PlayerExperienceGainMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerExperienceGainMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PlayerExperienceGainMutation"; }

  explicit PlayerExperienceGainMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerExperienceGainMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerExperienceGainMutation& from);
  PlayerExperienceGainMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerExperienceGainMutation&& from) noexcept
      : PlayerExperienceGainMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAmountFieldNumber = 1,
  };
  // optional int32 amount = 1 [json_name = "amount"];
  bool has_amount() const;
  void clear_amount() ;
  ::int32_t amount() const;
  void set_amount(::int32_t value);

  private:
  ::int32_t _internal_amount() const;
  void _internal_set_amount(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.PlayerExperienceGainMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerExperienceGainMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t amount_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerExperienceGainMutation_class_data_;
// -------------------------------------------------------------------

class PlayerDeathMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PlayerDeathMutation) */ {
 public:
  inline PlayerDeathMutation() : PlayerDeathMutation(nullptr) {}
  ~PlayerDeathMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerDeathMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerDeathMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerDeathMutation(::google::protobuf::internal::ConstantInitialized);

  inline PlayerDeathMutation(const PlayerDeathMutation& from) : PlayerDeathMutation(nullptr, from) {}
  inline PlayerDeathMutation(PlayerDeathMutation&& from) noexcept
      : PlayerDeathMutation(nullptr, ::std::move(from)) {}
  inline PlayerDeathMutation& operator=(const PlayerDeathMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerDeathMutation& operator=(PlayerDeathMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerDeathMutation& default_instance() {
    return *reinterpret_cast<const PlayerDeathMutation*>(
        &_PlayerDeathMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(PlayerDeathMutation& a, PlayerDeathMutation& b) { a.Swap(&b); }
  inline void Swap(PlayerDeathMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerDeathMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerDeathMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerDeathMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerDeathMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerDeathMutation& from) { PlayerDeathMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerDeathMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PlayerDeathMutation"; }

  explicit PlayerDeathMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerDeathMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerDeathMutation& from);
  PlayerDeathMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerDeathMutation&& from) noexcept
      : PlayerDeathMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeepInventoryFieldNumber = 1,
  };
  // optional bool keep_inventory = 1 [json_name = "keepInventory"];
  bool has_keep_inventory() const;
  void clear_keep_inventory() ;
  bool keep_inventory() const;
  void set_keep_inventory(bool value);

  private:
  bool _internal_keep_inventory() const;
  void _internal_set_keep_inventory(bool value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.PlayerDeathMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerDeathMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool keep_inventory_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerDeathMutation_class_data_;
// -------------------------------------------------------------------

class PlayerAttackEntityMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PlayerAttackEntityMutation) */ {
 public:
  inline PlayerAttackEntityMutation() : PlayerAttackEntityMutation(nullptr) {}
  ~PlayerAttackEntityMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerAttackEntityMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerAttackEntityMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerAttackEntityMutation(::google::protobuf::internal::ConstantInitialized);

  inline PlayerAttackEntityMutation(const PlayerAttackEntityMutation& from) : PlayerAttackEntityMutation(nullptr, from) {}
  inline PlayerAttackEntityMutation(PlayerAttackEntityMutation&& from) noexcept
      : PlayerAttackEntityMutation(nullptr, ::std::move(from)) {}
  inline PlayerAttackEntityMutation& operator=(const PlayerAttackEntityMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAttackEntityMutation& operator=(PlayerAttackEntityMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerAttackEntityMutation& default_instance() {
    return *reinterpret_cast<const PlayerAttackEntityMutation*>(
        &_PlayerAttackEntityMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(PlayerAttackEntityMutation& a, PlayerAttackEntityMutation& b) { a.Swap(&b); }
  inline void Swap(PlayerAttackEntityMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerAttackEntityMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerAttackEntityMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerAttackEntityMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerAttackEntityMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerAttackEntityMutation& from) { PlayerAttackEntityMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerAttackEntityMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PlayerAttackEntityMutation"; }

  explicit PlayerAttackEntityMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerAttackEntityMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerAttackEntityMutation& from);
  PlayerAttackEntityMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerAttackEntityMutation&& from) noexcept
      : PlayerAttackEntityMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kForceFieldNumber = 1,
    kHeightFieldNumber = 2,
    kCriticalFieldNumber = 3,
  };
  // optional double force = 1 [json_name = "force"];
  bool has_force() const;
  void clear_force() ;
  double force() const;
  void set_force(double value);

  private:
  double _internal_force() const;
  void _internal_set_force(double value);

  public:
  // optional double height = 2 [json_name = "height"];
  bool has_height() const;
  void clear_height() ;
  double height() const;
  void set_height(double value);

  private:
  double _internal_height() const;
  void _internal_set_height(double value);

  public:
  // optional bool critical = 3 [json_name = "critical"];
  bool has_critical() const;
  void clear_critical() ;
  bool critical() const;
  void set_critical(bool value);

  private:
  bool _internal_critical() const;
  void _internal_set_critical(bool value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.PlayerAttackEntityMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerAttackEntityMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double force_;
    double height_;
    bool critical_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerAttackEntityMutation_class_data_;
// -------------------------------------------------------------------

class ChatMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.ChatMutation) */ {
 public:
  inline ChatMutation() : ChatMutation(nullptr) {}
  ~ChatMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChatMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChatMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChatMutation(::google::protobuf::internal::ConstantInitialized);

  inline ChatMutation(const ChatMutation& from) : ChatMutation(nullptr, from) {}
  inline ChatMutation(ChatMutation&& from) noexcept
      : ChatMutation(nullptr, ::std::move(from)) {}
  inline ChatMutation& operator=(const ChatMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMutation& operator=(ChatMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMutation& default_instance() {
    return *reinterpret_cast<const ChatMutation*>(
        &_ChatMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ChatMutation& a, ChatMutation& b) { a.Swap(&b); }
  inline void Swap(ChatMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChatMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChatMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChatMutation& from) { ChatMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChatMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.ChatMutation"; }

  explicit ChatMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ChatMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChatMutation& from);
  ChatMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ChatMutation&& from) noexcept
      : ChatMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 1,
  };
  // optional string message = 1 [json_name = "message"];
  bool has_message() const;
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.ChatMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 38,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ChatMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ChatMutation_class_data_;
// -------------------------------------------------------------------

class PlayerTransferMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PlayerTransferMutation) */ {
 public:
  inline PlayerTransferMutation() : PlayerTransferMutation(nullptr) {}
  ~PlayerTransferMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerTransferMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerTransferMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerTransferMutation(::google::protobuf::internal::ConstantInitialized);

  inline PlayerTransferMutation(const PlayerTransferMutation& from) : PlayerTransferMutation(nullptr, from) {}
  inline PlayerTransferMutation(PlayerTransferMutation&& from) noexcept
      : PlayerTransferMutation(nullptr, ::std::move(from)) {}
  inline PlayerTransferMutation& operator=(const PlayerTransferMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerTransferMutation& operator=(PlayerTransferMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerTransferMutation& default_instance() {
    return *reinterpret_cast<const PlayerTransferMutation*>(
        &_PlayerTransferMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(PlayerTransferMutation& a, PlayerTransferMutation& b) { a.Swap(&b); }
  inline void Swap(PlayerTransferMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerTransferMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerTransferMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerTransferMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerTransferMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerTransferMutation& from) { PlayerTransferMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerTransferMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PlayerTransferMutation"; }

  explicit PlayerTransferMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerTransferMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerTransferMutation& from);
  PlayerTransferMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerTransferMutation&& from) noexcept
      : PlayerTransferMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddressFieldNumber = 1,
  };
  // optional .df.plugin.Address address = 1 [json_name = "address"];
  bool has_address() const;
  void clear_address() ;
  const ::df::plugin::Address& address() const;
  [[nodiscard]] ::df::plugin::Address* PROTOBUF_NULLABLE release_address();
  ::df::plugin::Address* PROTOBUF_NONNULL mutable_address();
  void set_allocated_address(::df::plugin::Address* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_address(::df::plugin::Address* PROTOBUF_NULLABLE value);
  ::df::plugin::Address* PROTOBUF_NULLABLE unsafe_arena_release_address();

  private:
  const ::df::plugin::Address& _internal_address() const;
  ::df::plugin::Address* PROTOBUF_NONNULL _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.PlayerTransferMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerTransferMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::df::plugin::Address* PROTOBUF_NULLABLE address_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerTransferMutation_class_data_;
// -------------------------------------------------------------------

class PlayerRespawnMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PlayerRespawnMutation) */ {
 public:
  inline PlayerRespawnMutation() : PlayerRespawnMutation(nullptr) {}
  ~PlayerRespawnMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerRespawnMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerRespawnMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerRespawnMutation(::google::protobuf::internal::ConstantInitialized);

  inline PlayerRespawnMutation(const PlayerRespawnMutation& from) : PlayerRespawnMutation(nullptr, from) {}
  inline PlayerRespawnMutation(PlayerRespawnMutation&& from) noexcept
      : PlayerRespawnMutation(nullptr, ::std::move(from)) {}
  inline PlayerRespawnMutation& operator=(const PlayerRespawnMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerRespawnMutation& operator=(PlayerRespawnMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerRespawnMutation& default_instance() {
    return *reinterpret_cast<const PlayerRespawnMutation*>(
        &_PlayerRespawnMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(PlayerRespawnMutation& a, PlayerRespawnMutation& b) { a.Swap(&b); }
  inline void Swap(PlayerRespawnMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerRespawnMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerRespawnMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerRespawnMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerRespawnMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerRespawnMutation& from) { PlayerRespawnMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerRespawnMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PlayerRespawnMutation"; }

  explicit PlayerRespawnMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerRespawnMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerRespawnMutation& from);
  PlayerRespawnMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerRespawnMutation&& from) noexcept
      : PlayerRespawnMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kWorldFieldNumber = 2,
  };
  // optional .df.plugin.Vec3 position = 1 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::df::plugin::Vec3& position() const;
  [[nodiscard]] ::df::plugin::Vec3* PROTOBUF_NULLABLE release_position();
  ::df::plugin::Vec3* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::df::plugin::Vec3* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::df::plugin::Vec3* PROTOBUF_NULLABLE value);
  ::df::plugin::Vec3* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::df::plugin::Vec3& _internal_position() const;
  ::df::plugin::Vec3* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // optional .df.plugin.WorldRef world = 2 [json_name = "world"];
  bool has_world() const;
  void clear_world() ;
  const ::df::plugin::WorldRef& world() const;
  [[nodiscard]] ::df::plugin::WorldRef* PROTOBUF_NULLABLE release_world();
  ::df::plugin::WorldRef* PROTOBUF_NONNULL mutable_world();
  void set_allocated_world(::df::plugin::WorldRef* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world(::df::plugin::WorldRef* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldRef* PROTOBUF_NULLABLE unsafe_arena_release_world();

  private:
  const ::df::plugin::WorldRef& _internal_world() const;
  ::df::plugin::WorldRef* PROTOBUF_NONNULL _internal_mutable_world();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.PlayerRespawnMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerRespawnMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::df::plugin::Vec3* PROTOBUF_NULLABLE position_;
    ::df::plugin::WorldRef* PROTOBUF_NULLABLE world_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerRespawnMutation_class_data_;
// -------------------------------------------------------------------

class PlayerItemPickupMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PlayerItemPickupMutation) */ {
 public:
  inline PlayerItemPickupMutation() : PlayerItemPickupMutation(nullptr) {}
  ~PlayerItemPickupMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerItemPickupMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerItemPickupMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerItemPickupMutation(::google::protobuf::internal::ConstantInitialized);

  inline PlayerItemPickupMutation(const PlayerItemPickupMutation& from) : PlayerItemPickupMutation(nullptr, from) {}
  inline PlayerItemPickupMutation(PlayerItemPickupMutation&& from) noexcept
      : PlayerItemPickupMutation(nullptr, ::std::move(from)) {}
  inline PlayerItemPickupMutation& operator=(const PlayerItemPickupMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerItemPickupMutation& operator=(PlayerItemPickupMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerItemPickupMutation& default_instance() {
    return *reinterpret_cast<const PlayerItemPickupMutation*>(
        &_PlayerItemPickupMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(PlayerItemPickupMutation& a, PlayerItemPickupMutation& b) { a.Swap(&b); }
  inline void Swap(PlayerItemPickupMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerItemPickupMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerItemPickupMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerItemPickupMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerItemPickupMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerItemPickupMutation& from) { PlayerItemPickupMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerItemPickupMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PlayerItemPickupMutation"; }

  explicit PlayerItemPickupMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerItemPickupMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerItemPickupMutation& from);
  PlayerItemPickupMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerItemPickupMutation&& from) noexcept
      : PlayerItemPickupMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemFieldNumber = 1,
  };
  // optional .df.plugin.ItemStack item = 1 [json_name = "item"];
  bool has_item() const;
  void clear_item() ;
  const ::df::plugin::ItemStack& item() const;
  [[nodiscard]] ::df::plugin::ItemStack* PROTOBUF_NULLABLE release_item();
  ::df::plugin::ItemStack* PROTOBUF_NONNULL mutable_item();
  void set_allocated_item(::df::plugin::ItemStack* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_item(::df::plugin::ItemStack* PROTOBUF_NULLABLE value);
  ::df::plugin::ItemStack* PROTOBUF_NULLABLE unsafe_arena_release_item();

  private:
  const ::df::plugin::ItemStack& _internal_item() const;
  ::df::plugin::ItemStack* PROTOBUF_NONNULL _internal_mutable_item();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.PlayerItemPickupMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerItemPickupMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::df::plugin::ItemStack* PROTOBUF_NULLABLE item_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerItemPickupMutation_class_data_;
// -------------------------------------------------------------------

class ItemStackList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.ItemStackList) */ {
 public:
  inline ItemStackList() : ItemStackList(nullptr) {}
  ~ItemStackList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ItemStackList* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ItemStackList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ItemStackList(::google::protobuf::internal::ConstantInitialized);

  inline ItemStackList(const ItemStackList& from) : ItemStackList(nullptr, from) {}
  inline ItemStackList(ItemStackList&& from) noexcept
      : ItemStackList(nullptr, ::std::move(from)) {}
  inline ItemStackList& operator=(const ItemStackList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemStackList& operator=(ItemStackList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemStackList& default_instance() {
    return *reinterpret_cast<const ItemStackList*>(
        &_ItemStackList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ItemStackList& a, ItemStackList& b) { a.Swap(&b); }
  inline void Swap(ItemStackList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemStackList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemStackList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ItemStackList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ItemStackList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ItemStackList& from) { ItemStackList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ItemStackList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.ItemStackList"; }

  explicit ItemStackList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ItemStackList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ItemStackList& from);
  ItemStackList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ItemStackList&& from) noexcept
      : ItemStackList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .df.plugin.ItemStack items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::df::plugin::ItemStack* PROTOBUF_NONNULL mutable_items(int index);
  ::google::protobuf::RepeatedPtrField<::df::plugin::ItemStack>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::df::plugin::ItemStack>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::df::plugin::ItemStack>* PROTOBUF_NONNULL _internal_mutable_items();
  public:
  const ::df::plugin::ItemStack& items(int index) const;
  ::df::plugin::ItemStack* PROTOBUF_NONNULL add_items();
  const ::google::protobuf::RepeatedPtrField<::df::plugin::ItemStack>& items() const;
  // @@protoc_insertion_point(class_scope:df.plugin.ItemStackList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ItemStackList& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::df::plugin::ItemStack > items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ItemStackList_class_data_;
// -------------------------------------------------------------------

class BlockPosList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.BlockPosList) */ {
 public:
  inline BlockPosList() : BlockPosList(nullptr) {}
  ~BlockPosList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockPosList* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockPosList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockPosList(::google::protobuf::internal::ConstantInitialized);

  inline BlockPosList(const BlockPosList& from) : BlockPosList(nullptr, from) {}
  inline BlockPosList(BlockPosList&& from) noexcept
      : BlockPosList(nullptr, ::std::move(from)) {}
  inline BlockPosList& operator=(const BlockPosList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockPosList& operator=(BlockPosList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockPosList& default_instance() {
    return *reinterpret_cast<const BlockPosList*>(
        &_BlockPosList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(BlockPosList& a, BlockPosList& b) { a.Swap(&b); }
  inline void Swap(BlockPosList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockPosList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockPosList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockPosList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockPosList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockPosList& from) { BlockPosList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockPosList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.BlockPosList"; }

  explicit BlockPosList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BlockPosList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BlockPosList& from);
  BlockPosList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BlockPosList&& from) noexcept
      : BlockPosList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionsFieldNumber = 1,
  };
  // repeated .df.plugin.BlockPos positions = 1 [json_name = "positions"];
  int positions_size() const;
  private:
  int _internal_positions_size() const;

  public:
  void clear_positions() ;
  ::df::plugin::BlockPos* PROTOBUF_NONNULL mutable_positions(int index);
  ::google::protobuf::RepeatedPtrField<::df::plugin::BlockPos>* PROTOBUF_NONNULL mutable_positions();

  private:
  const ::google::protobuf::RepeatedPtrField<::df::plugin::BlockPos>& _internal_positions() const;
  ::google::protobuf::RepeatedPtrField<::df::plugin::BlockPos>* PROTOBUF_NONNULL _internal_mutable_positions();
  public:
  const ::df::plugin::BlockPos& positions(int index) const;
  ::df::plugin::BlockPos* PROTOBUF_NONNULL add_positions();
  const ::google::protobuf::RepeatedPtrField<::df::plugin::BlockPos>& positions() const;
  // @@protoc_insertion_point(class_scope:df.plugin.BlockPosList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BlockPosList& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::df::plugin::BlockPos > positions_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BlockPosList_class_data_;
// -------------------------------------------------------------------

class WorldExplosionMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.WorldExplosionMutation) */ {
 public:
  inline WorldExplosionMutation() : WorldExplosionMutation(nullptr) {}
  ~WorldExplosionMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WorldExplosionMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WorldExplosionMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldExplosionMutation(::google::protobuf::internal::ConstantInitialized);

  inline WorldExplosionMutation(const WorldExplosionMutation& from) : WorldExplosionMutation(nullptr, from) {}
  inline WorldExplosionMutation(WorldExplosionMutation&& from) noexcept
      : WorldExplosionMutation(nullptr, ::std::move(from)) {}
  inline WorldExplosionMutation& operator=(const WorldExplosionMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldExplosionMutation& operator=(WorldExplosionMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldExplosionMutation& default_instance() {
    return *reinterpret_cast<const WorldExplosionMutation*>(
        &_WorldExplosionMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(WorldExplosionMutation& a, WorldExplosionMutation& b) { a.Swap(&b); }
  inline void Swap(WorldExplosionMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldExplosionMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldExplosionMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WorldExplosionMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorldExplosionMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorldExplosionMutation& from) { WorldExplosionMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WorldExplosionMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.WorldExplosionMutation"; }

  explicit WorldExplosionMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WorldExplosionMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WorldExplosionMutation& from);
  WorldExplosionMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WorldExplosionMutation&& from) noexcept
      : WorldExplosionMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityUuidsFieldNumber = 1,
    kBlocksFieldNumber = 2,
    kItemDropChanceFieldNumber = 3,
    kSpawnFireFieldNumber = 4,
  };
  // optional .df.plugin.StringList entity_uuids = 1 [json_name = "entityUuids"];
  bool has_entity_uuids() const;
  void clear_entity_uuids() ;
  const ::df::plugin::StringList& entity_uuids() const;
  [[nodiscard]] ::df::plugin::StringList* PROTOBUF_NULLABLE release_entity_uuids();
  ::df::plugin::StringList* PROTOBUF_NONNULL mutable_entity_uuids();
  void set_allocated_entity_uuids(::df::plugin::StringList* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_entity_uuids(::df::plugin::StringList* PROTOBUF_NULLABLE value);
  ::df::plugin::StringList* PROTOBUF_NULLABLE unsafe_arena_release_entity_uuids();

  private:
  const ::df::plugin::StringList& _internal_entity_uuids() const;
  ::df::plugin::StringList* PROTOBUF_NONNULL _internal_mutable_entity_uuids();

  public:
  // optional .df.plugin.BlockPosList blocks = 2 [json_name = "blocks"];
  bool has_blocks() const;
  void clear_blocks() ;
  const ::df::plugin::BlockPosList& blocks() const;
  [[nodiscard]] ::df::plugin::BlockPosList* PROTOBUF_NULLABLE release_blocks();
  ::df::plugin::BlockPosList* PROTOBUF_NONNULL mutable_blocks();
  void set_allocated_blocks(::df::plugin::BlockPosList* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_blocks(::df::plugin::BlockPosList* PROTOBUF_NULLABLE value);
  ::df::plugin::BlockPosList* PROTOBUF_NULLABLE unsafe_arena_release_blocks();

  private:
  const ::df::plugin::BlockPosList& _internal_blocks() const;
  ::df::plugin::BlockPosList* PROTOBUF_NONNULL _internal_mutable_blocks();

  public:
  // optional double item_drop_chance = 3 [json_name = "itemDropChance"];
  bool has_item_drop_chance() const;
  void clear_item_drop_chance() ;
  double item_drop_chance() const;
  void set_item_drop_chance(double value);

  private:
  double _internal_item_drop_chance() const;
  void _internal_set_item_drop_chance(double value);

  public:
  // optional bool spawn_fire = 4 [json_name = "spawnFire"];
  bool has_spawn_fire() const;
  void clear_spawn_fire() ;
  bool spawn_fire() const;
  void set_spawn_fire(bool value);

  private:
  bool _internal_spawn_fire() const;
  void _internal_set_spawn_fire(bool value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.WorldExplosionMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WorldExplosionMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::df::plugin::StringList* PROTOBUF_NULLABLE entity_uuids_;
    ::df::plugin::BlockPosList* PROTOBUF_NULLABLE blocks_;
    double item_drop_chance_;
    bool spawn_fire_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WorldExplosionMutation_class_data_;
// -------------------------------------------------------------------

class BlockBreakMutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.BlockBreakMutation) */ {
 public:
  inline BlockBreakMutation() : BlockBreakMutation(nullptr) {}
  ~BlockBreakMutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockBreakMutation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockBreakMutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockBreakMutation(::google::protobuf::internal::ConstantInitialized);

  inline BlockBreakMutation(const BlockBreakMutation& from) : BlockBreakMutation(nullptr, from) {}
  inline BlockBreakMutation(BlockBreakMutation&& from) noexcept
      : BlockBreakMutation(nullptr, ::std::move(from)) {}
  inline BlockBreakMutation& operator=(const BlockBreakMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBreakMutation& operator=(BlockBreakMutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBreakMutation& default_instance() {
    return *reinterpret_cast<const BlockBreakMutation*>(
        &_BlockBreakMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(BlockBreakMutation& a, BlockBreakMutation& b) { a.Swap(&b); }
  inline void Swap(BlockBreakMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBreakMutation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBreakMutation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockBreakMutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockBreakMutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockBreakMutation& from) { BlockBreakMutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockBreakMutation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.BlockBreakMutation"; }

  explicit BlockBreakMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BlockBreakMutation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BlockBreakMutation& from);
  BlockBreakMutation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BlockBreakMutation&& from) noexcept
      : BlockBreakMutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDropsFieldNumber = 1,
    kXpFieldNumber = 2,
  };
  // optional .df.plugin.ItemStackList drops = 1 [json_name = "drops"];
  bool has_drops() const;
  void clear_drops() ;
  const ::df::plugin::ItemStackList& drops() const;
  [[nodiscard]] ::df::plugin::ItemStackList* PROTOBUF_NULLABLE release_drops();
  ::df::plugin::ItemStackList* PROTOBUF_NONNULL mutable_drops();
  void set_allocated_drops(::df::plugin::ItemStackList* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_drops(::df::plugin::ItemStackList* PROTOBUF_NULLABLE value);
  ::df::plugin::ItemStackList* PROTOBUF_NULLABLE unsafe_arena_release_drops();

  private:
  const ::df::plugin::ItemStackList& _internal_drops() const;
  ::df::plugin::ItemStackList* PROTOBUF_NONNULL _internal_mutable_drops();

  public:
  // optional int32 xp = 2 [json_name = "xp"];
  bool has_xp() const;
  void clear_xp() ;
  ::int32_t xp() const;
  void set_xp(::int32_t value);

  private:
  ::int32_t _internal_xp() const;
  void _internal_set_xp(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.BlockBreakMutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BlockBreakMutation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::df::plugin::ItemStackList* PROTOBUF_NULLABLE drops_;
    ::int32_t xp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BlockBreakMutation_class_data_;
// -------------------------------------------------------------------

class EventResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.EventResult) */ {
 public:
  inline EventResult() : EventResult(nullptr) {}
  ~EventResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EventResult* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EventResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EventResult(::google::protobuf::internal::ConstantInitialized);

  inline EventResult(const EventResult& from) : EventResult(nullptr, from) {}
  inline EventResult(EventResult&& from) noexcept
      : EventResult(nullptr, ::std::move(from)) {}
  inline EventResult& operator=(const EventResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventResult& operator=(EventResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventResult& default_instance() {
    return *reinterpret_cast<const EventResult*>(
        &_EventResult_default_instance_);
  }
  enum UpdateCase {
    kChat = 10,
    kBlockBreak = 11,
    kPlayerFoodLoss = 12,
    kPlayerHeal = 13,
    kPlayerHurt = 14,
    kPlayerDeath = 15,
    kPlayerRespawn = 16,
    kPlayerAttackEntity = 17,
    kPlayerExperienceGain = 18,
    kPlayerLecternPageTurn = 19,
    kPlayerItemPickup = 20,
    kPlayerTransfer = 21,
    kWorldExplosion = 30,
    UPDATE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(EventResult& a, EventResult& b) { a.Swap(&b); }
  inline void Swap(EventResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EventResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EventResult& from) { EventResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EventResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.EventResult"; }

  explicit EventResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EventResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EventResult& from);
  EventResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EventResult&& from) noexcept
      : EventResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventIdFieldNumber = 1,
    kCancelFieldNumber = 2,
    kChatFieldNumber = 10,
    kBlockBreakFieldNumber = 11,
    kPlayerFoodLossFieldNumber = 12,
    kPlayerHealFieldNumber = 13,
    kPlayerHurtFieldNumber = 14,
    kPlayerDeathFieldNumber = 15,
    kPlayerRespawnFieldNumber = 16,
    kPlayerAttackEntityFieldNumber = 17,
    kPlayerExperienceGainFieldNumber = 18,
    kPlayerLecternPageTurnFieldNumber = 19,
    kPlayerItemPickupFieldNumber = 20,
    kPlayerTransferFieldNumber = 21,
    kWorldExplosionFieldNumber = 30,
  };
  // string event_id = 1 [json_name = "eventId"];
  void clear_event_id() ;
  const ::std::string& event_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_event_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_event_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_event_id();
  void set_allocated_event_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_event_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_event_id();

  public:
  // optional bool cancel = 2 [json_name = "cancel"];
  bool has_cancel() const;
  void clear_cancel() ;
  bool cancel() const;
  void set_cancel(bool value);

  private:
  bool _internal_cancel() const;
  void _internal_set_cancel(bool value);

  public:
  // .df.plugin.ChatMutation chat = 10 [json_name = "chat"];
  bool has_chat() const;
  private:
  bool _internal_has_chat() const;

  public:
  void clear_chat() ;
  const ::df::plugin::ChatMutation& chat() const;
  [[nodiscard]] ::df::plugin::ChatMutation* PROTOBUF_NULLABLE release_chat();
  ::df::plugin::ChatMutation* PROTOBUF_NONNULL mutable_chat();
  void set_allocated_chat(::df::plugin::ChatMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chat(::df::plugin::ChatMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::ChatMutation* PROTOBUF_NULLABLE unsafe_arena_release_chat();

  private:
  const ::df::plugin::ChatMutation& _internal_chat() const;
  ::df::plugin::ChatMutation* PROTOBUF_NONNULL _internal_mutable_chat();

  public:
  // .df.plugin.BlockBreakMutation block_break = 11 [json_name = "blockBreak"];
  bool has_block_break() const;
  private:
  bool _internal_has_block_break() const;

  public:
  void clear_block_break() ;
  const ::df::plugin::BlockBreakMutation& block_break() const;
  [[nodiscard]] ::df::plugin::BlockBreakMutation* PROTOBUF_NULLABLE release_block_break();
  ::df::plugin::BlockBreakMutation* PROTOBUF_NONNULL mutable_block_break();
  void set_allocated_block_break(::df::plugin::BlockBreakMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_block_break(::df::plugin::BlockBreakMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::BlockBreakMutation* PROTOBUF_NULLABLE unsafe_arena_release_block_break();

  private:
  const ::df::plugin::BlockBreakMutation& _internal_block_break() const;
  ::df::plugin::BlockBreakMutation* PROTOBUF_NONNULL _internal_mutable_block_break();

  public:
  // .df.plugin.PlayerFoodLossMutation player_food_loss = 12 [json_name = "playerFoodLoss"];
  bool has_player_food_loss() const;
  private:
  bool _internal_has_player_food_loss() const;

  public:
  void clear_player_food_loss() ;
  const ::df::plugin::PlayerFoodLossMutation& player_food_loss() const;
  [[nodiscard]] ::df::plugin::PlayerFoodLossMutation* PROTOBUF_NULLABLE release_player_food_loss();
  ::df::plugin::PlayerFoodLossMutation* PROTOBUF_NONNULL mutable_player_food_loss();
  void set_allocated_player_food_loss(::df::plugin::PlayerFoodLossMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_food_loss(::df::plugin::PlayerFoodLossMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerFoodLossMutation* PROTOBUF_NULLABLE unsafe_arena_release_player_food_loss();

  private:
  const ::df::plugin::PlayerFoodLossMutation& _internal_player_food_loss() const;
  ::df::plugin::PlayerFoodLossMutation* PROTOBUF_NONNULL _internal_mutable_player_food_loss();

  public:
  // .df.plugin.PlayerHealMutation player_heal = 13 [json_name = "playerHeal"];
  bool has_player_heal() const;
  private:
  bool _internal_has_player_heal() const;

  public:
  void clear_player_heal() ;
  const ::df::plugin::PlayerHealMutation& player_heal() const;
  [[nodiscard]] ::df::plugin::PlayerHealMutation* PROTOBUF_NULLABLE release_player_heal();
  ::df::plugin::PlayerHealMutation* PROTOBUF_NONNULL mutable_player_heal();
  void set_allocated_player_heal(::df::plugin::PlayerHealMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_heal(::df::plugin::PlayerHealMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerHealMutation* PROTOBUF_NULLABLE unsafe_arena_release_player_heal();

  private:
  const ::df::plugin::PlayerHealMutation& _internal_player_heal() const;
  ::df::plugin::PlayerHealMutation* PROTOBUF_NONNULL _internal_mutable_player_heal();

  public:
  // .df.plugin.PlayerHurtMutation player_hurt = 14 [json_name = "playerHurt"];
  bool has_player_hurt() const;
  private:
  bool _internal_has_player_hurt() const;

  public:
  void clear_player_hurt() ;
  const ::df::plugin::PlayerHurtMutation& player_hurt() const;
  [[nodiscard]] ::df::plugin::PlayerHurtMutation* PROTOBUF_NULLABLE release_player_hurt();
  ::df::plugin::PlayerHurtMutation* PROTOBUF_NONNULL mutable_player_hurt();
  void set_allocated_player_hurt(::df::plugin::PlayerHurtMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_hurt(::df::plugin::PlayerHurtMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerHurtMutation* PROTOBUF_NULLABLE unsafe_arena_release_player_hurt();

  private:
  const ::df::plugin::PlayerHurtMutation& _internal_player_hurt() const;
  ::df::plugin::PlayerHurtMutation* PROTOBUF_NONNULL _internal_mutable_player_hurt();

  public:
  // .df.plugin.PlayerDeathMutation player_death = 15 [json_name = "playerDeath"];
  bool has_player_death() const;
  private:
  bool _internal_has_player_death() const;

  public:
  void clear_player_death() ;
  const ::df::plugin::PlayerDeathMutation& player_death() const;
  [[nodiscard]] ::df::plugin::PlayerDeathMutation* PROTOBUF_NULLABLE release_player_death();
  ::df::plugin::PlayerDeathMutation* PROTOBUF_NONNULL mutable_player_death();
  void set_allocated_player_death(::df::plugin::PlayerDeathMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_death(::df::plugin::PlayerDeathMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerDeathMutation* PROTOBUF_NULLABLE unsafe_arena_release_player_death();

  private:
  const ::df::plugin::PlayerDeathMutation& _internal_player_death() const;
  ::df::plugin::PlayerDeathMutation* PROTOBUF_NONNULL _internal_mutable_player_death();

  public:
  // .df.plugin.PlayerRespawnMutation player_respawn = 16 [json_name = "playerRespawn"];
  bool has_player_respawn() const;
  private:
  bool _internal_has_player_respawn() const;

  public:
  void clear_player_respawn() ;
  const ::df::plugin::PlayerRespawnMutation& player_respawn() const;
  [[nodiscard]] ::df::plugin::PlayerRespawnMutation* PROTOBUF_NULLABLE release_player_respawn();
  ::df::plugin::PlayerRespawnMutation* PROTOBUF_NONNULL mutable_player_respawn();
  void set_allocated_player_respawn(::df::plugin::PlayerRespawnMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_respawn(::df::plugin::PlayerRespawnMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerRespawnMutation* PROTOBUF_NULLABLE unsafe_arena_release_player_respawn();

  private:
  const ::df::plugin::PlayerRespawnMutation& _internal_player_respawn() const;
  ::df::plugin::PlayerRespawnMutation* PROTOBUF_NONNULL _internal_mutable_player_respawn();

  public:
  // .df.plugin.PlayerAttackEntityMutation player_attack_entity = 17 [json_name = "playerAttackEntity"];
  bool has_player_attack_entity() const;
  private:
  bool _internal_has_player_attack_entity() const;

  public:
  void clear_player_attack_entity() ;
  const ::df::plugin::PlayerAttackEntityMutation& player_attack_entity() const;
  [[nodiscard]] ::df::plugin::PlayerAttackEntityMutation* PROTOBUF_NULLABLE release_player_attack_entity();
  ::df::plugin::PlayerAttackEntityMutation* PROTOBUF_NONNULL mutable_player_attack_entity();
  void set_allocated_player_attack_entity(::df::plugin::PlayerAttackEntityMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_attack_entity(::df::plugin::PlayerAttackEntityMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerAttackEntityMutation* PROTOBUF_NULLABLE unsafe_arena_release_player_attack_entity();

  private:
  const ::df::plugin::PlayerAttackEntityMutation& _internal_player_attack_entity() const;
  ::df::plugin::PlayerAttackEntityMutation* PROTOBUF_NONNULL _internal_mutable_player_attack_entity();

  public:
  // .df.plugin.PlayerExperienceGainMutation player_experience_gain = 18 [json_name = "playerExperienceGain"];
  bool has_player_experience_gain() const;
  private:
  bool _internal_has_player_experience_gain() const;

  public:
  void clear_player_experience_gain() ;
  const ::df::plugin::PlayerExperienceGainMutation& player_experience_gain() const;
  [[nodiscard]] ::df::plugin::PlayerExperienceGainMutation* PROTOBUF_NULLABLE release_player_experience_gain();
  ::df::plugin::PlayerExperienceGainMutation* PROTOBUF_NONNULL mutable_player_experience_gain();
  void set_allocated_player_experience_gain(::df::plugin::PlayerExperienceGainMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_experience_gain(::df::plugin::PlayerExperienceGainMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerExperienceGainMutation* PROTOBUF_NULLABLE unsafe_arena_release_player_experience_gain();

  private:
  const ::df::plugin::PlayerExperienceGainMutation& _internal_player_experience_gain() const;
  ::df::plugin::PlayerExperienceGainMutation* PROTOBUF_NONNULL _internal_mutable_player_experience_gain();

  public:
  // .df.plugin.PlayerLecternPageTurnMutation player_lectern_page_turn = 19 [json_name = "playerLecternPageTurn"];
  bool has_player_lectern_page_turn() const;
  private:
  bool _internal_has_player_lectern_page_turn() const;

  public:
  void clear_player_lectern_page_turn() ;
  const ::df::plugin::PlayerLecternPageTurnMutation& player_lectern_page_turn() const;
  [[nodiscard]] ::df::plugin::PlayerLecternPageTurnMutation* PROTOBUF_NULLABLE release_player_lectern_page_turn();
  ::df::plugin::PlayerLecternPageTurnMutation* PROTOBUF_NONNULL mutable_player_lectern_page_turn();
  void set_allocated_player_lectern_page_turn(::df::plugin::PlayerLecternPageTurnMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_lectern_page_turn(::df::plugin::PlayerLecternPageTurnMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerLecternPageTurnMutation* PROTOBUF_NULLABLE unsafe_arena_release_player_lectern_page_turn();

  private:
  const ::df::plugin::PlayerLecternPageTurnMutation& _internal_player_lectern_page_turn() const;
  ::df::plugin::PlayerLecternPageTurnMutation* PROTOBUF_NONNULL _internal_mutable_player_lectern_page_turn();

  public:
  // .df.plugin.PlayerItemPickupMutation player_item_pickup = 20 [json_name = "playerItemPickup"];
  bool has_player_item_pickup() const;
  private:
  bool _internal_has_player_item_pickup() const;

  public:
  void clear_player_item_pickup() ;
  const ::df::plugin::PlayerItemPickupMutation& player_item_pickup() const;
  [[nodiscard]] ::df::plugin::PlayerItemPickupMutation* PROTOBUF_NULLABLE release_player_item_pickup();
  ::df::plugin::PlayerItemPickupMutation* PROTOBUF_NONNULL mutable_player_item_pickup();
  void set_allocated_player_item_pickup(::df::plugin::PlayerItemPickupMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_item_pickup(::df::plugin::PlayerItemPickupMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerItemPickupMutation* PROTOBUF_NULLABLE unsafe_arena_release_player_item_pickup();

  private:
  const ::df::plugin::PlayerItemPickupMutation& _internal_player_item_pickup() const;
  ::df::plugin::PlayerItemPickupMutation* PROTOBUF_NONNULL _internal_mutable_player_item_pickup();

  public:
  // .df.plugin.PlayerTransferMutation player_transfer = 21 [json_name = "playerTransfer"];
  bool has_player_transfer() const;
  private:
  bool _internal_has_player_transfer() const;

  public:
  void clear_player_transfer() ;
  const ::df::plugin::PlayerTransferMutation& player_transfer() const;
  [[nodiscard]] ::df::plugin::PlayerTransferMutation* PROTOBUF_NULLABLE release_player_transfer();
  ::df::plugin::PlayerTransferMutation* PROTOBUF_NONNULL mutable_player_transfer();
  void set_allocated_player_transfer(::df::plugin::PlayerTransferMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_transfer(::df::plugin::PlayerTransferMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerTransferMutation* PROTOBUF_NULLABLE unsafe_arena_release_player_transfer();

  private:
  const ::df::plugin::PlayerTransferMutation& _internal_player_transfer() const;
  ::df::plugin::PlayerTransferMutation* PROTOBUF_NONNULL _internal_mutable_player_transfer();

  public:
  // .df.plugin.WorldExplosionMutation world_explosion = 30 [json_name = "worldExplosion"];
  bool has_world_explosion() const;
  private:
  bool _internal_has_world_explosion() const;

  public:
  void clear_world_explosion() ;
  const ::df::plugin::WorldExplosionMutation& world_explosion() const;
  [[nodiscard]] ::df::plugin::WorldExplosionMutation* PROTOBUF_NULLABLE release_world_explosion();
  ::df::plugin::WorldExplosionMutation* PROTOBUF_NONNULL mutable_world_explosion();
  void set_allocated_world_explosion(::df::plugin::WorldExplosionMutation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_explosion(::df::plugin::WorldExplosionMutation* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldExplosionMutation* PROTOBUF_NULLABLE unsafe_arena_release_world_explosion();

  private:
  const ::df::plugin::WorldExplosionMutation& _internal_world_explosion() const;
  ::df::plugin::WorldExplosionMutation* PROTOBUF_NONNULL _internal_mutable_world_explosion();

  public:
  void clear_update();
  UpdateCase update_case() const;
  // @@protoc_insertion_point(class_scope:df.plugin.EventResult)
 private:
  class _Internal;
  void set_has_chat();
  void set_has_block_break();
  void set_has_player_food_loss();
  void set_has_player_heal();
  void set_has_player_hurt();
  void set_has_player_death();
  void set_has_player_respawn();
  void set_has_player_attack_entity();
  void set_has_player_experience_gain();
  void set_has_player_lectern_page_turn();
  void set_has_player_item_pickup();
  void set_has_player_transfer();
  void set_has_world_explosion();
  inline bool has_update() const;
  inline void clear_has_update();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 15,
                                   13, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EventResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr event_id_;
    bool cancel_;
    union UpdateUnion {
      constexpr UpdateUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE chat_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE block_break_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_food_loss_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_heal_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_hurt_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_death_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_respawn_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_attack_entity_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_experience_gain_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_lectern_page_turn_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_item_pickup_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_transfer_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_explosion_;
    } update_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mutations_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EventResult_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EventResult

// string event_id = 1 [json_name = "eventId"];
inline void EventResult::clear_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& EventResult::event_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.event_id)
  return _internal_event_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EventResult::set_event_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.event_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.EventResult.event_id)
}
inline ::std::string* PROTOBUF_NONNULL EventResult::mutable_event_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.event_id)
  return _s;
}
inline const ::std::string& EventResult::_internal_event_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.event_id_.Get();
}
inline void EventResult::_internal_set_event_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EventResult::_internal_mutable_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.event_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EventResult::release_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.event_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.event_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.event_id_.Set("", GetArena());
  }
  return released;
}
inline void EventResult::set_allocated_event_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.event_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.EventResult.event_id)
}

// optional bool cancel = 2 [json_name = "cancel"];
inline bool EventResult::has_cancel() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void EventResult::clear_cancel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancel_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool EventResult::cancel() const {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.cancel)
  return _internal_cancel();
}
inline void EventResult::set_cancel(bool value) {
  _internal_set_cancel(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:df.plugin.EventResult.cancel)
}
inline bool EventResult::_internal_cancel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cancel_;
}
inline void EventResult::_internal_set_cancel(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancel_ = value;
}

// .df.plugin.ChatMutation chat = 10 [json_name = "chat"];
inline bool EventResult::has_chat() const {
  return update_case() == kChat;
}
inline bool EventResult::_internal_has_chat() const {
  return update_case() == kChat;
}
inline void EventResult::set_has_chat() {
  _impl_._oneof_case_[0] = kChat;
}
inline void EventResult::clear_chat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kChat) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.chat_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.chat_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::ChatMutation* PROTOBUF_NULLABLE EventResult::release_chat() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.chat)
  if (update_case() == kChat) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::ChatMutation*>(_impl_.update_.chat_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.chat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::ChatMutation& EventResult::_internal_chat() const {
  return update_case() == kChat ? static_cast<const ::df::plugin::ChatMutation&>(*reinterpret_cast<::df::plugin::ChatMutation*>(_impl_.update_.chat_))
                     : reinterpret_cast<const ::df::plugin::ChatMutation&>(::df::plugin::_ChatMutation_default_instance_);
}
inline const ::df::plugin::ChatMutation& EventResult::chat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.chat)
  return _internal_chat();
}
inline ::df::plugin::ChatMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_chat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.chat)
  if (update_case() == kChat) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::ChatMutation*>(_impl_.update_.chat_);
    _impl_.update_.chat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_chat(
    ::df::plugin::ChatMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_chat();
    _impl_.update_.chat_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.chat)
}
inline ::df::plugin::ChatMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_chat() {
  if (update_case() != kChat) {
    clear_update();
    set_has_chat();
    _impl_.update_.chat_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::ChatMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::ChatMutation*>(_impl_.update_.chat_);
}
inline ::df::plugin::ChatMutation* PROTOBUF_NONNULL EventResult::mutable_chat()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::ChatMutation* _msg = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.chat)
  return _msg;
}

// .df.plugin.BlockBreakMutation block_break = 11 [json_name = "blockBreak"];
inline bool EventResult::has_block_break() const {
  return update_case() == kBlockBreak;
}
inline bool EventResult::_internal_has_block_break() const {
  return update_case() == kBlockBreak;
}
inline void EventResult::set_has_block_break() {
  _impl_._oneof_case_[0] = kBlockBreak;
}
inline void EventResult::clear_block_break() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kBlockBreak) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.block_break_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.block_break_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::BlockBreakMutation* PROTOBUF_NULLABLE EventResult::release_block_break() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.block_break)
  if (update_case() == kBlockBreak) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::BlockBreakMutation*>(_impl_.update_.block_break_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.block_break_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::BlockBreakMutation& EventResult::_internal_block_break() const {
  return update_case() == kBlockBreak ? static_cast<const ::df::plugin::BlockBreakMutation&>(*reinterpret_cast<::df::plugin::BlockBreakMutation*>(_impl_.update_.block_break_))
                     : reinterpret_cast<const ::df::plugin::BlockBreakMutation&>(::df::plugin::_BlockBreakMutation_default_instance_);
}
inline const ::df::plugin::BlockBreakMutation& EventResult::block_break() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.block_break)
  return _internal_block_break();
}
inline ::df::plugin::BlockBreakMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_block_break() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.block_break)
  if (update_case() == kBlockBreak) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::BlockBreakMutation*>(_impl_.update_.block_break_);
    _impl_.update_.block_break_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_block_break(
    ::df::plugin::BlockBreakMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_block_break();
    _impl_.update_.block_break_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.block_break)
}
inline ::df::plugin::BlockBreakMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_block_break() {
  if (update_case() != kBlockBreak) {
    clear_update();
    set_has_block_break();
    _impl_.update_.block_break_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::BlockBreakMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::BlockBreakMutation*>(_impl_.update_.block_break_);
}
inline ::df::plugin::BlockBreakMutation* PROTOBUF_NONNULL EventResult::mutable_block_break()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::BlockBreakMutation* _msg = _internal_mutable_block_break();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.block_break)
  return _msg;
}

// .df.plugin.PlayerFoodLossMutation player_food_loss = 12 [json_name = "playerFoodLoss"];
inline bool EventResult::has_player_food_loss() const {
  return update_case() == kPlayerFoodLoss;
}
inline bool EventResult::_internal_has_player_food_loss() const {
  return update_case() == kPlayerFoodLoss;
}
inline void EventResult::set_has_player_food_loss() {
  _impl_._oneof_case_[0] = kPlayerFoodLoss;
}
inline void EventResult::clear_player_food_loss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kPlayerFoodLoss) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.player_food_loss_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.player_food_loss_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::PlayerFoodLossMutation* PROTOBUF_NULLABLE EventResult::release_player_food_loss() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.player_food_loss)
  if (update_case() == kPlayerFoodLoss) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerFoodLossMutation*>(_impl_.update_.player_food_loss_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.player_food_loss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerFoodLossMutation& EventResult::_internal_player_food_loss() const {
  return update_case() == kPlayerFoodLoss ? static_cast<const ::df::plugin::PlayerFoodLossMutation&>(*reinterpret_cast<::df::plugin::PlayerFoodLossMutation*>(_impl_.update_.player_food_loss_))
                     : reinterpret_cast<const ::df::plugin::PlayerFoodLossMutation&>(::df::plugin::_PlayerFoodLossMutation_default_instance_);
}
inline const ::df::plugin::PlayerFoodLossMutation& EventResult::player_food_loss() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.player_food_loss)
  return _internal_player_food_loss();
}
inline ::df::plugin::PlayerFoodLossMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_player_food_loss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.player_food_loss)
  if (update_case() == kPlayerFoodLoss) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerFoodLossMutation*>(_impl_.update_.player_food_loss_);
    _impl_.update_.player_food_loss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_player_food_loss(
    ::df::plugin::PlayerFoodLossMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_player_food_loss();
    _impl_.update_.player_food_loss_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.player_food_loss)
}
inline ::df::plugin::PlayerFoodLossMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_player_food_loss() {
  if (update_case() != kPlayerFoodLoss) {
    clear_update();
    set_has_player_food_loss();
    _impl_.update_.player_food_loss_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerFoodLossMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerFoodLossMutation*>(_impl_.update_.player_food_loss_);
}
inline ::df::plugin::PlayerFoodLossMutation* PROTOBUF_NONNULL EventResult::mutable_player_food_loss()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerFoodLossMutation* _msg = _internal_mutable_player_food_loss();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.player_food_loss)
  return _msg;
}

// .df.plugin.PlayerHealMutation player_heal = 13 [json_name = "playerHeal"];
inline bool EventResult::has_player_heal() const {
  return update_case() == kPlayerHeal;
}
inline bool EventResult::_internal_has_player_heal() const {
  return update_case() == kPlayerHeal;
}
inline void EventResult::set_has_player_heal() {
  _impl_._oneof_case_[0] = kPlayerHeal;
}
inline void EventResult::clear_player_heal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kPlayerHeal) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.player_heal_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.player_heal_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::PlayerHealMutation* PROTOBUF_NULLABLE EventResult::release_player_heal() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.player_heal)
  if (update_case() == kPlayerHeal) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerHealMutation*>(_impl_.update_.player_heal_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.player_heal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerHealMutation& EventResult::_internal_player_heal() const {
  return update_case() == kPlayerHeal ? static_cast<const ::df::plugin::PlayerHealMutation&>(*reinterpret_cast<::df::plugin::PlayerHealMutation*>(_impl_.update_.player_heal_))
                     : reinterpret_cast<const ::df::plugin::PlayerHealMutation&>(::df::plugin::_PlayerHealMutation_default_instance_);
}
inline const ::df::plugin::PlayerHealMutation& EventResult::player_heal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.player_heal)
  return _internal_player_heal();
}
inline ::df::plugin::PlayerHealMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_player_heal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.player_heal)
  if (update_case() == kPlayerHeal) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerHealMutation*>(_impl_.update_.player_heal_);
    _impl_.update_.player_heal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_player_heal(
    ::df::plugin::PlayerHealMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_player_heal();
    _impl_.update_.player_heal_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.player_heal)
}
inline ::df::plugin::PlayerHealMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_player_heal() {
  if (update_case() != kPlayerHeal) {
    clear_update();
    set_has_player_heal();
    _impl_.update_.player_heal_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerHealMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerHealMutation*>(_impl_.update_.player_heal_);
}
inline ::df::plugin::PlayerHealMutation* PROTOBUF_NONNULL EventResult::mutable_player_heal()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerHealMutation* _msg = _internal_mutable_player_heal();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.player_heal)
  return _msg;
}

// .df.plugin.PlayerHurtMutation player_hurt = 14 [json_name = "playerHurt"];
inline bool EventResult::has_player_hurt() const {
  return update_case() == kPlayerHurt;
}
inline bool EventResult::_internal_has_player_hurt() const {
  return update_case() == kPlayerHurt;
}
inline void EventResult::set_has_player_hurt() {
  _impl_._oneof_case_[0] = kPlayerHurt;
}
inline void EventResult::clear_player_hurt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kPlayerHurt) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.player_hurt_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.player_hurt_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::PlayerHurtMutation* PROTOBUF_NULLABLE EventResult::release_player_hurt() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.player_hurt)
  if (update_case() == kPlayerHurt) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerHurtMutation*>(_impl_.update_.player_hurt_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.player_hurt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerHurtMutation& EventResult::_internal_player_hurt() const {
  return update_case() == kPlayerHurt ? static_cast<const ::df::plugin::PlayerHurtMutation&>(*reinterpret_cast<::df::plugin::PlayerHurtMutation*>(_impl_.update_.player_hurt_))
                     : reinterpret_cast<const ::df::plugin::PlayerHurtMutation&>(::df::plugin::_PlayerHurtMutation_default_instance_);
}
inline const ::df::plugin::PlayerHurtMutation& EventResult::player_hurt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.player_hurt)
  return _internal_player_hurt();
}
inline ::df::plugin::PlayerHurtMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_player_hurt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.player_hurt)
  if (update_case() == kPlayerHurt) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerHurtMutation*>(_impl_.update_.player_hurt_);
    _impl_.update_.player_hurt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_player_hurt(
    ::df::plugin::PlayerHurtMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_player_hurt();
    _impl_.update_.player_hurt_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.player_hurt)
}
inline ::df::plugin::PlayerHurtMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_player_hurt() {
  if (update_case() != kPlayerHurt) {
    clear_update();
    set_has_player_hurt();
    _impl_.update_.player_hurt_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerHurtMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerHurtMutation*>(_impl_.update_.player_hurt_);
}
inline ::df::plugin::PlayerHurtMutation* PROTOBUF_NONNULL EventResult::mutable_player_hurt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerHurtMutation* _msg = _internal_mutable_player_hurt();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.player_hurt)
  return _msg;
}

// .df.plugin.PlayerDeathMutation player_death = 15 [json_name = "playerDeath"];
inline bool EventResult::has_player_death() const {
  return update_case() == kPlayerDeath;
}
inline bool EventResult::_internal_has_player_death() const {
  return update_case() == kPlayerDeath;
}
inline void EventResult::set_has_player_death() {
  _impl_._oneof_case_[0] = kPlayerDeath;
}
inline void EventResult::clear_player_death() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kPlayerDeath) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.player_death_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.player_death_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::PlayerDeathMutation* PROTOBUF_NULLABLE EventResult::release_player_death() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.player_death)
  if (update_case() == kPlayerDeath) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerDeathMutation*>(_impl_.update_.player_death_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.player_death_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerDeathMutation& EventResult::_internal_player_death() const {
  return update_case() == kPlayerDeath ? static_cast<const ::df::plugin::PlayerDeathMutation&>(*reinterpret_cast<::df::plugin::PlayerDeathMutation*>(_impl_.update_.player_death_))
                     : reinterpret_cast<const ::df::plugin::PlayerDeathMutation&>(::df::plugin::_PlayerDeathMutation_default_instance_);
}
inline const ::df::plugin::PlayerDeathMutation& EventResult::player_death() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.player_death)
  return _internal_player_death();
}
inline ::df::plugin::PlayerDeathMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_player_death() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.player_death)
  if (update_case() == kPlayerDeath) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerDeathMutation*>(_impl_.update_.player_death_);
    _impl_.update_.player_death_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_player_death(
    ::df::plugin::PlayerDeathMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_player_death();
    _impl_.update_.player_death_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.player_death)
}
inline ::df::plugin::PlayerDeathMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_player_death() {
  if (update_case() != kPlayerDeath) {
    clear_update();
    set_has_player_death();
    _impl_.update_.player_death_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerDeathMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerDeathMutation*>(_impl_.update_.player_death_);
}
inline ::df::plugin::PlayerDeathMutation* PROTOBUF_NONNULL EventResult::mutable_player_death()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerDeathMutation* _msg = _internal_mutable_player_death();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.player_death)
  return _msg;
}

// .df.plugin.PlayerRespawnMutation player_respawn = 16 [json_name = "playerRespawn"];
inline bool EventResult::has_player_respawn() const {
  return update_case() == kPlayerRespawn;
}
inline bool EventResult::_internal_has_player_respawn() const {
  return update_case() == kPlayerRespawn;
}
inline void EventResult::set_has_player_respawn() {
  _impl_._oneof_case_[0] = kPlayerRespawn;
}
inline void EventResult::clear_player_respawn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kPlayerRespawn) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.player_respawn_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.player_respawn_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::PlayerRespawnMutation* PROTOBUF_NULLABLE EventResult::release_player_respawn() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.player_respawn)
  if (update_case() == kPlayerRespawn) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerRespawnMutation*>(_impl_.update_.player_respawn_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.player_respawn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerRespawnMutation& EventResult::_internal_player_respawn() const {
  return update_case() == kPlayerRespawn ? static_cast<const ::df::plugin::PlayerRespawnMutation&>(*reinterpret_cast<::df::plugin::PlayerRespawnMutation*>(_impl_.update_.player_respawn_))
                     : reinterpret_cast<const ::df::plugin::PlayerRespawnMutation&>(::df::plugin::_PlayerRespawnMutation_default_instance_);
}
inline const ::df::plugin::PlayerRespawnMutation& EventResult::player_respawn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.player_respawn)
  return _internal_player_respawn();
}
inline ::df::plugin::PlayerRespawnMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_player_respawn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.player_respawn)
  if (update_case() == kPlayerRespawn) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerRespawnMutation*>(_impl_.update_.player_respawn_);
    _impl_.update_.player_respawn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_player_respawn(
    ::df::plugin::PlayerRespawnMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_player_respawn();
    _impl_.update_.player_respawn_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.player_respawn)
}
inline ::df::plugin::PlayerRespawnMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_player_respawn() {
  if (update_case() != kPlayerRespawn) {
    clear_update();
    set_has_player_respawn();
    _impl_.update_.player_respawn_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerRespawnMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerRespawnMutation*>(_impl_.update_.player_respawn_);
}
inline ::df::plugin::PlayerRespawnMutation* PROTOBUF_NONNULL EventResult::mutable_player_respawn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerRespawnMutation* _msg = _internal_mutable_player_respawn();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.player_respawn)
  return _msg;
}

// .df.plugin.PlayerAttackEntityMutation player_attack_entity = 17 [json_name = "playerAttackEntity"];
inline bool EventResult::has_player_attack_entity() const {
  return update_case() == kPlayerAttackEntity;
}
inline bool EventResult::_internal_has_player_attack_entity() const {
  return update_case() == kPlayerAttackEntity;
}
inline void EventResult::set_has_player_attack_entity() {
  _impl_._oneof_case_[0] = kPlayerAttackEntity;
}
inline void EventResult::clear_player_attack_entity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kPlayerAttackEntity) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.player_attack_entity_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.player_attack_entity_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::PlayerAttackEntityMutation* PROTOBUF_NULLABLE EventResult::release_player_attack_entity() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.player_attack_entity)
  if (update_case() == kPlayerAttackEntity) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerAttackEntityMutation*>(_impl_.update_.player_attack_entity_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.player_attack_entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerAttackEntityMutation& EventResult::_internal_player_attack_entity() const {
  return update_case() == kPlayerAttackEntity ? static_cast<const ::df::plugin::PlayerAttackEntityMutation&>(*reinterpret_cast<::df::plugin::PlayerAttackEntityMutation*>(_impl_.update_.player_attack_entity_))
                     : reinterpret_cast<const ::df::plugin::PlayerAttackEntityMutation&>(::df::plugin::_PlayerAttackEntityMutation_default_instance_);
}
inline const ::df::plugin::PlayerAttackEntityMutation& EventResult::player_attack_entity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.player_attack_entity)
  return _internal_player_attack_entity();
}
inline ::df::plugin::PlayerAttackEntityMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_player_attack_entity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.player_attack_entity)
  if (update_case() == kPlayerAttackEntity) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerAttackEntityMutation*>(_impl_.update_.player_attack_entity_);
    _impl_.update_.player_attack_entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_player_attack_entity(
    ::df::plugin::PlayerAttackEntityMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_player_attack_entity();
    _impl_.update_.player_attack_entity_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.player_attack_entity)
}
inline ::df::plugin::PlayerAttackEntityMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_player_attack_entity() {
  if (update_case() != kPlayerAttackEntity) {
    clear_update();
    set_has_player_attack_entity();
    _impl_.update_.player_attack_entity_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerAttackEntityMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerAttackEntityMutation*>(_impl_.update_.player_attack_entity_);
}
inline ::df::plugin::PlayerAttackEntityMutation* PROTOBUF_NONNULL EventResult::mutable_player_attack_entity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerAttackEntityMutation* _msg = _internal_mutable_player_attack_entity();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.player_attack_entity)
  return _msg;
}

// .df.plugin.PlayerExperienceGainMutation player_experience_gain = 18 [json_name = "playerExperienceGain"];
inline bool EventResult::has_player_experience_gain() const {
  return update_case() == kPlayerExperienceGain;
}
inline bool EventResult::_internal_has_player_experience_gain() const {
  return update_case() == kPlayerExperienceGain;
}
inline void EventResult::set_has_player_experience_gain() {
  _impl_._oneof_case_[0] = kPlayerExperienceGain;
}
inline void EventResult::clear_player_experience_gain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kPlayerExperienceGain) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.player_experience_gain_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.player_experience_gain_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::PlayerExperienceGainMutation* PROTOBUF_NULLABLE EventResult::release_player_experience_gain() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.player_experience_gain)
  if (update_case() == kPlayerExperienceGain) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerExperienceGainMutation*>(_impl_.update_.player_experience_gain_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.player_experience_gain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerExperienceGainMutation& EventResult::_internal_player_experience_gain() const {
  return update_case() == kPlayerExperienceGain ? static_cast<const ::df::plugin::PlayerExperienceGainMutation&>(*reinterpret_cast<::df::plugin::PlayerExperienceGainMutation*>(_impl_.update_.player_experience_gain_))
                     : reinterpret_cast<const ::df::plugin::PlayerExperienceGainMutation&>(::df::plugin::_PlayerExperienceGainMutation_default_instance_);
}
inline const ::df::plugin::PlayerExperienceGainMutation& EventResult::player_experience_gain() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.player_experience_gain)
  return _internal_player_experience_gain();
}
inline ::df::plugin::PlayerExperienceGainMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_player_experience_gain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.player_experience_gain)
  if (update_case() == kPlayerExperienceGain) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerExperienceGainMutation*>(_impl_.update_.player_experience_gain_);
    _impl_.update_.player_experience_gain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_player_experience_gain(
    ::df::plugin::PlayerExperienceGainMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_player_experience_gain();
    _impl_.update_.player_experience_gain_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.player_experience_gain)
}
inline ::df::plugin::PlayerExperienceGainMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_player_experience_gain() {
  if (update_case() != kPlayerExperienceGain) {
    clear_update();
    set_has_player_experience_gain();
    _impl_.update_.player_experience_gain_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerExperienceGainMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerExperienceGainMutation*>(_impl_.update_.player_experience_gain_);
}
inline ::df::plugin::PlayerExperienceGainMutation* PROTOBUF_NONNULL EventResult::mutable_player_experience_gain()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerExperienceGainMutation* _msg = _internal_mutable_player_experience_gain();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.player_experience_gain)
  return _msg;
}

// .df.plugin.PlayerLecternPageTurnMutation player_lectern_page_turn = 19 [json_name = "playerLecternPageTurn"];
inline bool EventResult::has_player_lectern_page_turn() const {
  return update_case() == kPlayerLecternPageTurn;
}
inline bool EventResult::_internal_has_player_lectern_page_turn() const {
  return update_case() == kPlayerLecternPageTurn;
}
inline void EventResult::set_has_player_lectern_page_turn() {
  _impl_._oneof_case_[0] = kPlayerLecternPageTurn;
}
inline void EventResult::clear_player_lectern_page_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kPlayerLecternPageTurn) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.player_lectern_page_turn_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.player_lectern_page_turn_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::PlayerLecternPageTurnMutation* PROTOBUF_NULLABLE EventResult::release_player_lectern_page_turn() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.player_lectern_page_turn)
  if (update_case() == kPlayerLecternPageTurn) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerLecternPageTurnMutation*>(_impl_.update_.player_lectern_page_turn_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.player_lectern_page_turn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerLecternPageTurnMutation& EventResult::_internal_player_lectern_page_turn() const {
  return update_case() == kPlayerLecternPageTurn ? static_cast<const ::df::plugin::PlayerLecternPageTurnMutation&>(*reinterpret_cast<::df::plugin::PlayerLecternPageTurnMutation*>(_impl_.update_.player_lectern_page_turn_))
                     : reinterpret_cast<const ::df::plugin::PlayerLecternPageTurnMutation&>(::df::plugin::_PlayerLecternPageTurnMutation_default_instance_);
}
inline const ::df::plugin::PlayerLecternPageTurnMutation& EventResult::player_lectern_page_turn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.player_lectern_page_turn)
  return _internal_player_lectern_page_turn();
}
inline ::df::plugin::PlayerLecternPageTurnMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_player_lectern_page_turn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.player_lectern_page_turn)
  if (update_case() == kPlayerLecternPageTurn) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerLecternPageTurnMutation*>(_impl_.update_.player_lectern_page_turn_);
    _impl_.update_.player_lectern_page_turn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_player_lectern_page_turn(
    ::df::plugin::PlayerLecternPageTurnMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_player_lectern_page_turn();
    _impl_.update_.player_lectern_page_turn_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.player_lectern_page_turn)
}
inline ::df::plugin::PlayerLecternPageTurnMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_player_lectern_page_turn() {
  if (update_case() != kPlayerLecternPageTurn) {
    clear_update();
    set_has_player_lectern_page_turn();
    _impl_.update_.player_lectern_page_turn_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerLecternPageTurnMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerLecternPageTurnMutation*>(_impl_.update_.player_lectern_page_turn_);
}
inline ::df::plugin::PlayerLecternPageTurnMutation* PROTOBUF_NONNULL EventResult::mutable_player_lectern_page_turn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerLecternPageTurnMutation* _msg = _internal_mutable_player_lectern_page_turn();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.player_lectern_page_turn)
  return _msg;
}

// .df.plugin.PlayerItemPickupMutation player_item_pickup = 20 [json_name = "playerItemPickup"];
inline bool EventResult::has_player_item_pickup() const {
  return update_case() == kPlayerItemPickup;
}
inline bool EventResult::_internal_has_player_item_pickup() const {
  return update_case() == kPlayerItemPickup;
}
inline void EventResult::set_has_player_item_pickup() {
  _impl_._oneof_case_[0] = kPlayerItemPickup;
}
inline void EventResult::clear_player_item_pickup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kPlayerItemPickup) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.player_item_pickup_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.player_item_pickup_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::PlayerItemPickupMutation* PROTOBUF_NULLABLE EventResult::release_player_item_pickup() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.player_item_pickup)
  if (update_case() == kPlayerItemPickup) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemPickupMutation*>(_impl_.update_.player_item_pickup_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.player_item_pickup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerItemPickupMutation& EventResult::_internal_player_item_pickup() const {
  return update_case() == kPlayerItemPickup ? static_cast<const ::df::plugin::PlayerItemPickupMutation&>(*reinterpret_cast<::df::plugin::PlayerItemPickupMutation*>(_impl_.update_.player_item_pickup_))
                     : reinterpret_cast<const ::df::plugin::PlayerItemPickupMutation&>(::df::plugin::_PlayerItemPickupMutation_default_instance_);
}
inline const ::df::plugin::PlayerItemPickupMutation& EventResult::player_item_pickup() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.player_item_pickup)
  return _internal_player_item_pickup();
}
inline ::df::plugin::PlayerItemPickupMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_player_item_pickup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.player_item_pickup)
  if (update_case() == kPlayerItemPickup) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemPickupMutation*>(_impl_.update_.player_item_pickup_);
    _impl_.update_.player_item_pickup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_player_item_pickup(
    ::df::plugin::PlayerItemPickupMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_player_item_pickup();
    _impl_.update_.player_item_pickup_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.player_item_pickup)
}
inline ::df::plugin::PlayerItemPickupMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_player_item_pickup() {
  if (update_case() != kPlayerItemPickup) {
    clear_update();
    set_has_player_item_pickup();
    _impl_.update_.player_item_pickup_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerItemPickupMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerItemPickupMutation*>(_impl_.update_.player_item_pickup_);
}
inline ::df::plugin::PlayerItemPickupMutation* PROTOBUF_NONNULL EventResult::mutable_player_item_pickup()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerItemPickupMutation* _msg = _internal_mutable_player_item_pickup();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.player_item_pickup)
  return _msg;
}

// .df.plugin.PlayerTransferMutation player_transfer = 21 [json_name = "playerTransfer"];
inline bool EventResult::has_player_transfer() const {
  return update_case() == kPlayerTransfer;
}
inline bool EventResult::_internal_has_player_transfer() const {
  return update_case() == kPlayerTransfer;
}
inline void EventResult::set_has_player_transfer() {
  _impl_._oneof_case_[0] = kPlayerTransfer;
}
inline void EventResult::clear_player_transfer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kPlayerTransfer) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.player_transfer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.player_transfer_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::PlayerTransferMutation* PROTOBUF_NULLABLE EventResult::release_player_transfer() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.player_transfer)
  if (update_case() == kPlayerTransfer) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerTransferMutation*>(_impl_.update_.player_transfer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.player_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerTransferMutation& EventResult::_internal_player_transfer() const {
  return update_case() == kPlayerTransfer ? static_cast<const ::df::plugin::PlayerTransferMutation&>(*reinterpret_cast<::df::plugin::PlayerTransferMutation*>(_impl_.update_.player_transfer_))
                     : reinterpret_cast<const ::df::plugin::PlayerTransferMutation&>(::df::plugin::_PlayerTransferMutation_default_instance_);
}
inline const ::df::plugin::PlayerTransferMutation& EventResult::player_transfer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.player_transfer)
  return _internal_player_transfer();
}
inline ::df::plugin::PlayerTransferMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_player_transfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.player_transfer)
  if (update_case() == kPlayerTransfer) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::PlayerTransferMutation*>(_impl_.update_.player_transfer_);
    _impl_.update_.player_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_player_transfer(
    ::df::plugin::PlayerTransferMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_player_transfer();
    _impl_.update_.player_transfer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.player_transfer)
}
inline ::df::plugin::PlayerTransferMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_player_transfer() {
  if (update_case() != kPlayerTransfer) {
    clear_update();
    set_has_player_transfer();
    _impl_.update_.player_transfer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerTransferMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerTransferMutation*>(_impl_.update_.player_transfer_);
}
inline ::df::plugin::PlayerTransferMutation* PROTOBUF_NONNULL EventResult::mutable_player_transfer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerTransferMutation* _msg = _internal_mutable_player_transfer();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.player_transfer)
  return _msg;
}

// .df.plugin.WorldExplosionMutation world_explosion = 30 [json_name = "worldExplosion"];
inline bool EventResult::has_world_explosion() const {
  return update_case() == kWorldExplosion;
}
inline bool EventResult::_internal_has_world_explosion() const {
  return update_case() == kWorldExplosion;
}
inline void EventResult::set_has_world_explosion() {
  _impl_._oneof_case_[0] = kWorldExplosion;
}
inline void EventResult::clear_world_explosion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kWorldExplosion) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.world_explosion_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.world_explosion_);
    }
    clear_has_update();
  }
}
inline ::df::plugin::WorldExplosionMutation* PROTOBUF_NULLABLE EventResult::release_world_explosion() {
  // @@protoc_insertion_point(field_release:df.plugin.EventResult.world_explosion)
  if (update_case() == kWorldExplosion) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::WorldExplosionMutation*>(_impl_.update_.world_explosion_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.world_explosion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldExplosionMutation& EventResult::_internal_world_explosion() const {
  return update_case() == kWorldExplosion ? static_cast<const ::df::plugin::WorldExplosionMutation&>(*reinterpret_cast<::df::plugin::WorldExplosionMutation*>(_impl_.update_.world_explosion_))
                     : reinterpret_cast<const ::df::plugin::WorldExplosionMutation&>(::df::plugin::_WorldExplosionMutation_default_instance_);
}
inline const ::df::plugin::WorldExplosionMutation& EventResult::world_explosion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventResult.world_explosion)
  return _internal_world_explosion();
}
inline ::df::plugin::WorldExplosionMutation* PROTOBUF_NULLABLE EventResult::unsafe_arena_release_world_explosion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventResult.world_explosion)
  if (update_case() == kWorldExplosion) {
    clear_has_update();
    auto* temp = reinterpret_cast<::df::plugin::WorldExplosionMutation*>(_impl_.update_.world_explosion_);
    _impl_.update_.world_explosion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventResult::unsafe_arena_set_allocated_world_explosion(
    ::df::plugin::WorldExplosionMutation* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_world_explosion();
    _impl_.update_.world_explosion_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventResult.world_explosion)
}
inline ::df::plugin::WorldExplosionMutation* PROTOBUF_NONNULL EventResult::_internal_mutable_world_explosion() {
  if (update_case() != kWorldExplosion) {
    clear_update();
    set_has_world_explosion();
    _impl_.update_.world_explosion_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldExplosionMutation>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldExplosionMutation*>(_impl_.update_.world_explosion_);
}
inline ::df::plugin::WorldExplosionMutation* PROTOBUF_NONNULL EventResult::mutable_world_explosion()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldExplosionMutation* _msg = _internal_mutable_world_explosion();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventResult.world_explosion)
  return _msg;
}

inline bool EventResult::has_update() const {
  return update_case() != UPDATE_NOT_SET;
}
inline void EventResult::clear_has_update() {
  _impl_._oneof_case_[0] = UPDATE_NOT_SET;
}
inline EventResult::UpdateCase EventResult::update_case() const {
  return EventResult::UpdateCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ItemStackList

// repeated .df.plugin.ItemStack items = 1 [json_name = "items"];
inline int ItemStackList::_internal_items_size() const {
  return _internal_items().size();
}
inline int ItemStackList::items_size() const {
  return _internal_items_size();
}
inline ::df::plugin::ItemStack* PROTOBUF_NONNULL ItemStackList::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:df.plugin.ItemStackList.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::df::plugin::ItemStack>* PROTOBUF_NONNULL ItemStackList::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:df.plugin.ItemStackList.items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_items();
}
inline const ::df::plugin::ItemStack& ItemStackList::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.ItemStackList.items)
  return _internal_items().Get(index);
}
inline ::df::plugin::ItemStack* PROTOBUF_NONNULL ItemStackList::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::df::plugin::ItemStack* _add =
      _internal_mutable_items()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:df.plugin.ItemStackList.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::df::plugin::ItemStack>& ItemStackList::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:df.plugin.ItemStackList.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::df::plugin::ItemStack>&
ItemStackList::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::df::plugin::ItemStack>* PROTOBUF_NONNULL
ItemStackList::_internal_mutable_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// StringList

// repeated string values = 1 [json_name = "values"];
inline int StringList::_internal_values_size() const {
  return _internal_values().size();
}
inline int StringList::values_size() const {
  return _internal_values_size();
}
inline void StringList::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL StringList::add_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_values()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:df.plugin.StringList.values)
  return _s;
}
inline const ::std::string& StringList::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.StringList.values)
  return _internal_values().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL StringList::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:df.plugin.StringList.values)
  return _internal_mutable_values()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void StringList::set_values(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_values()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:df.plugin.StringList.values)
}
template <typename Arg_, typename... Args_>
inline void StringList::add_values(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_values(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:df.plugin.StringList.values)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& StringList::values()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:df.plugin.StringList.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
StringList::mutable_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:df.plugin.StringList.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
StringList::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
StringList::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// BlockPosList

// repeated .df.plugin.BlockPos positions = 1 [json_name = "positions"];
inline int BlockPosList::_internal_positions_size() const {
  return _internal_positions().size();
}
inline int BlockPosList::positions_size() const {
  return _internal_positions_size();
}
inline ::df::plugin::BlockPos* PROTOBUF_NONNULL BlockPosList::mutable_positions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:df.plugin.BlockPosList.positions)
  return _internal_mutable_positions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::df::plugin::BlockPos>* PROTOBUF_NONNULL BlockPosList::mutable_positions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:df.plugin.BlockPosList.positions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_positions();
}
inline const ::df::plugin::BlockPos& BlockPosList::positions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.BlockPosList.positions)
  return _internal_positions().Get(index);
}
inline ::df::plugin::BlockPos* PROTOBUF_NONNULL BlockPosList::add_positions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::df::plugin::BlockPos* _add =
      _internal_mutable_positions()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:df.plugin.BlockPosList.positions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::df::plugin::BlockPos>& BlockPosList::positions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:df.plugin.BlockPosList.positions)
  return _internal_positions();
}
inline const ::google::protobuf::RepeatedPtrField<::df::plugin::BlockPos>&
BlockPosList::_internal_positions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positions_;
}
inline ::google::protobuf::RepeatedPtrField<::df::plugin::BlockPos>* PROTOBUF_NONNULL
BlockPosList::_internal_mutable_positions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.positions_;
}

// -------------------------------------------------------------------

// ChatMutation

// optional string message = 1 [json_name = "message"];
inline bool ChatMutation::has_message() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void ChatMutation::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ChatMutation::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.ChatMutation.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChatMutation::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.ChatMutation.message)
}
inline ::std::string* PROTOBUF_NONNULL ChatMutation::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:df.plugin.ChatMutation.message)
  return _s;
}
inline const ::std::string& ChatMutation::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void ChatMutation::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChatMutation::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChatMutation::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.ChatMutation.message)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void ChatMutation::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.ChatMutation.message)
}

// -------------------------------------------------------------------

// BlockBreakMutation

// optional .df.plugin.ItemStackList drops = 1 [json_name = "drops"];
inline bool BlockBreakMutation::has_drops() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.drops_ != nullptr);
  return value;
}
inline void BlockBreakMutation::clear_drops() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.drops_ != nullptr) _impl_.drops_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::df::plugin::ItemStackList& BlockBreakMutation::_internal_drops() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::ItemStackList* p = _impl_.drops_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::ItemStackList&>(::df::plugin::_ItemStackList_default_instance_);
}
inline const ::df::plugin::ItemStackList& BlockBreakMutation::drops() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.BlockBreakMutation.drops)
  return _internal_drops();
}
inline void BlockBreakMutation::unsafe_arena_set_allocated_drops(
    ::df::plugin::ItemStackList* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.drops_);
  }
  _impl_.drops_ = reinterpret_cast<::df::plugin::ItemStackList*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.BlockBreakMutation.drops)
}
inline ::df::plugin::ItemStackList* PROTOBUF_NULLABLE BlockBreakMutation::release_drops() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::ItemStackList* released = _impl_.drops_;
  _impl_.drops_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::ItemStackList* PROTOBUF_NULLABLE BlockBreakMutation::unsafe_arena_release_drops() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.BlockBreakMutation.drops)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::ItemStackList* temp = _impl_.drops_;
  _impl_.drops_ = nullptr;
  return temp;
}
inline ::df::plugin::ItemStackList* PROTOBUF_NONNULL BlockBreakMutation::_internal_mutable_drops() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.drops_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::ItemStackList>(GetArena());
    _impl_.drops_ = reinterpret_cast<::df::plugin::ItemStackList*>(p);
  }
  return _impl_.drops_;
}
inline ::df::plugin::ItemStackList* PROTOBUF_NONNULL BlockBreakMutation::mutable_drops()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::ItemStackList* _msg = _internal_mutable_drops();
  // @@protoc_insertion_point(field_mutable:df.plugin.BlockBreakMutation.drops)
  return _msg;
}
inline void BlockBreakMutation::set_allocated_drops(::df::plugin::ItemStackList* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.drops_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.drops_ = reinterpret_cast<::df::plugin::ItemStackList*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.BlockBreakMutation.drops)
}

// optional int32 xp = 2 [json_name = "xp"];
inline bool BlockBreakMutation::has_xp() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void BlockBreakMutation::clear_xp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xp_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t BlockBreakMutation::xp() const {
  // @@protoc_insertion_point(field_get:df.plugin.BlockBreakMutation.xp)
  return _internal_xp();
}
inline void BlockBreakMutation::set_xp(::int32_t value) {
  _internal_set_xp(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:df.plugin.BlockBreakMutation.xp)
}
inline ::int32_t BlockBreakMutation::_internal_xp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.xp_;
}
inline void BlockBreakMutation::_internal_set_xp(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xp_ = value;
}

// -------------------------------------------------------------------

// PlayerFoodLossMutation

// optional int32 to = 1 [json_name = "to"];
inline bool PlayerFoodLossMutation::has_to() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PlayerFoodLossMutation::clear_to() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerFoodLossMutation::to() const {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerFoodLossMutation.to)
  return _internal_to();
}
inline void PlayerFoodLossMutation::set_to(::int32_t value) {
  _internal_set_to(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:df.plugin.PlayerFoodLossMutation.to)
}
inline ::int32_t PlayerFoodLossMutation::_internal_to() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_;
}
inline void PlayerFoodLossMutation::_internal_set_to(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_ = value;
}

// -------------------------------------------------------------------

// PlayerHealMutation

// optional double amount = 1 [json_name = "amount"];
inline bool PlayerHealMutation::has_amount() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PlayerHealMutation::clear_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.amount_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline double PlayerHealMutation::amount() const {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerHealMutation.amount)
  return _internal_amount();
}
inline void PlayerHealMutation::set_amount(double value) {
  _internal_set_amount(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:df.plugin.PlayerHealMutation.amount)
}
inline double PlayerHealMutation::_internal_amount() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.amount_;
}
inline void PlayerHealMutation::_internal_set_amount(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.amount_ = value;
}

// -------------------------------------------------------------------

// PlayerHurtMutation

// optional double damage = 1 [json_name = "damage"];
inline bool PlayerHurtMutation::has_damage() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PlayerHurtMutation::clear_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline double PlayerHurtMutation::damage() const {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerHurtMutation.damage)
  return _internal_damage();
}
inline void PlayerHurtMutation::set_damage(double value) {
  _internal_set_damage(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:df.plugin.PlayerHurtMutation.damage)
}
inline double PlayerHurtMutation::_internal_damage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_;
}
inline void PlayerHurtMutation::_internal_set_damage(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = value;
}

// optional int64 attack_immunity_ms = 2 [json_name = "attackImmunityMs"];
inline bool PlayerHurtMutation::has_attack_immunity_ms() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void PlayerHurtMutation::clear_attack_immunity_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_immunity_ms_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int64_t PlayerHurtMutation::attack_immunity_ms() const {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerHurtMutation.attack_immunity_ms)
  return _internal_attack_immunity_ms();
}
inline void PlayerHurtMutation::set_attack_immunity_ms(::int64_t value) {
  _internal_set_attack_immunity_ms(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:df.plugin.PlayerHurtMutation.attack_immunity_ms)
}
inline ::int64_t PlayerHurtMutation::_internal_attack_immunity_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attack_immunity_ms_;
}
inline void PlayerHurtMutation::_internal_set_attack_immunity_ms(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_immunity_ms_ = value;
}

// -------------------------------------------------------------------

// PlayerDeathMutation

// optional bool keep_inventory = 1 [json_name = "keepInventory"];
inline bool PlayerDeathMutation::has_keep_inventory() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PlayerDeathMutation::clear_keep_inventory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.keep_inventory_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool PlayerDeathMutation::keep_inventory() const {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerDeathMutation.keep_inventory)
  return _internal_keep_inventory();
}
inline void PlayerDeathMutation::set_keep_inventory(bool value) {
  _internal_set_keep_inventory(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:df.plugin.PlayerDeathMutation.keep_inventory)
}
inline bool PlayerDeathMutation::_internal_keep_inventory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.keep_inventory_;
}
inline void PlayerDeathMutation::_internal_set_keep_inventory(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.keep_inventory_ = value;
}

// -------------------------------------------------------------------

// PlayerRespawnMutation

// optional .df.plugin.Vec3 position = 1 [json_name = "position"];
inline bool PlayerRespawnMutation::has_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::df::plugin::Vec3& PlayerRespawnMutation::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::Vec3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::Vec3&>(::df::plugin::_Vec3_default_instance_);
}
inline const ::df::plugin::Vec3& PlayerRespawnMutation::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerRespawnMutation.position)
  return _internal_position();
}
inline void PlayerRespawnMutation::unsafe_arena_set_allocated_position(
    ::df::plugin::Vec3* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::df::plugin::Vec3*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.PlayerRespawnMutation.position)
}
inline ::df::plugin::Vec3* PROTOBUF_NULLABLE PlayerRespawnMutation::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::Vec3* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::Vec3* PROTOBUF_NULLABLE PlayerRespawnMutation::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.PlayerRespawnMutation.position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::Vec3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::df::plugin::Vec3* PROTOBUF_NONNULL PlayerRespawnMutation::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::Vec3>(GetArena());
    _impl_.position_ = reinterpret_cast<::df::plugin::Vec3*>(p);
  }
  return _impl_.position_;
}
inline ::df::plugin::Vec3* PROTOBUF_NONNULL PlayerRespawnMutation::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::Vec3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:df.plugin.PlayerRespawnMutation.position)
  return _msg;
}
inline void PlayerRespawnMutation::set_allocated_position(::df::plugin::Vec3* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.position_ = reinterpret_cast<::df::plugin::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.PlayerRespawnMutation.position)
}

// optional .df.plugin.WorldRef world = 2 [json_name = "world"];
inline bool PlayerRespawnMutation::has_world() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.world_ != nullptr);
  return value;
}
inline const ::df::plugin::WorldRef& PlayerRespawnMutation::_internal_world() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::WorldRef* p = _impl_.world_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::WorldRef&>(::df::plugin::_WorldRef_default_instance_);
}
inline const ::df::plugin::WorldRef& PlayerRespawnMutation::world() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerRespawnMutation.world)
  return _internal_world();
}
inline void PlayerRespawnMutation::unsafe_arena_set_allocated_world(
    ::df::plugin::WorldRef* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.world_);
  }
  _impl_.world_ = reinterpret_cast<::df::plugin::WorldRef*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.PlayerRespawnMutation.world)
}
inline ::df::plugin::WorldRef* PROTOBUF_NULLABLE PlayerRespawnMutation::release_world() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::WorldRef* released = _impl_.world_;
  _impl_.world_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::WorldRef* PROTOBUF_NULLABLE PlayerRespawnMutation::unsafe_arena_release_world() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.PlayerRespawnMutation.world)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::WorldRef* temp = _impl_.world_;
  _impl_.world_ = nullptr;
  return temp;
}
inline ::df::plugin::WorldRef* PROTOBUF_NONNULL PlayerRespawnMutation::_internal_mutable_world() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.world_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldRef>(GetArena());
    _impl_.world_ = reinterpret_cast<::df::plugin::WorldRef*>(p);
  }
  return _impl_.world_;
}
inline ::df::plugin::WorldRef* PROTOBUF_NONNULL PlayerRespawnMutation::mutable_world()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::WorldRef* _msg = _internal_mutable_world();
  // @@protoc_insertion_point(field_mutable:df.plugin.PlayerRespawnMutation.world)
  return _msg;
}
inline void PlayerRespawnMutation::set_allocated_world(::df::plugin::WorldRef* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.world_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.world_ = reinterpret_cast<::df::plugin::WorldRef*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.PlayerRespawnMutation.world)
}

// -------------------------------------------------------------------

// PlayerAttackEntityMutation

// optional double force = 1 [json_name = "force"];
inline bool PlayerAttackEntityMutation::has_force() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PlayerAttackEntityMutation::clear_force() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.force_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline double PlayerAttackEntityMutation::force() const {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerAttackEntityMutation.force)
  return _internal_force();
}
inline void PlayerAttackEntityMutation::set_force(double value) {
  _internal_set_force(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:df.plugin.PlayerAttackEntityMutation.force)
}
inline double PlayerAttackEntityMutation::_internal_force() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.force_;
}
inline void PlayerAttackEntityMutation::_internal_set_force(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.force_ = value;
}

// optional double height = 2 [json_name = "height"];
inline bool PlayerAttackEntityMutation::has_height() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void PlayerAttackEntityMutation::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline double PlayerAttackEntityMutation::height() const {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerAttackEntityMutation.height)
  return _internal_height();
}
inline void PlayerAttackEntityMutation::set_height(double value) {
  _internal_set_height(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:df.plugin.PlayerAttackEntityMutation.height)
}
inline double PlayerAttackEntityMutation::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void PlayerAttackEntityMutation::_internal_set_height(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// optional bool critical = 3 [json_name = "critical"];
inline bool PlayerAttackEntityMutation::has_critical() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void PlayerAttackEntityMutation::clear_critical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool PlayerAttackEntityMutation::critical() const {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerAttackEntityMutation.critical)
  return _internal_critical();
}
inline void PlayerAttackEntityMutation::set_critical(bool value) {
  _internal_set_critical(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:df.plugin.PlayerAttackEntityMutation.critical)
}
inline bool PlayerAttackEntityMutation::_internal_critical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.critical_;
}
inline void PlayerAttackEntityMutation::_internal_set_critical(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_ = value;
}

// -------------------------------------------------------------------

// PlayerExperienceGainMutation

// optional int32 amount = 1 [json_name = "amount"];
inline bool PlayerExperienceGainMutation::has_amount() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PlayerExperienceGainMutation::clear_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.amount_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerExperienceGainMutation::amount() const {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerExperienceGainMutation.amount)
  return _internal_amount();
}
inline void PlayerExperienceGainMutation::set_amount(::int32_t value) {
  _internal_set_amount(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:df.plugin.PlayerExperienceGainMutation.amount)
}
inline ::int32_t PlayerExperienceGainMutation::_internal_amount() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.amount_;
}
inline void PlayerExperienceGainMutation::_internal_set_amount(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.amount_ = value;
}

// -------------------------------------------------------------------

// PlayerLecternPageTurnMutation

// optional int32 new_page = 1 [json_name = "newPage"];
inline bool PlayerLecternPageTurnMutation::has_new_page() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PlayerLecternPageTurnMutation::clear_new_page() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_page_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerLecternPageTurnMutation::new_page() const {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerLecternPageTurnMutation.new_page)
  return _internal_new_page();
}
inline void PlayerLecternPageTurnMutation::set_new_page(::int32_t value) {
  _internal_set_new_page(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:df.plugin.PlayerLecternPageTurnMutation.new_page)
}
inline ::int32_t PlayerLecternPageTurnMutation::_internal_new_page() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_page_;
}
inline void PlayerLecternPageTurnMutation::_internal_set_new_page(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_page_ = value;
}

// -------------------------------------------------------------------

// PlayerItemPickupMutation

// optional .df.plugin.ItemStack item = 1 [json_name = "item"];
inline bool PlayerItemPickupMutation::has_item() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.item_ != nullptr);
  return value;
}
inline const ::df::plugin::ItemStack& PlayerItemPickupMutation::_internal_item() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::ItemStack* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::ItemStack&>(::df::plugin::_ItemStack_default_instance_);
}
inline const ::df::plugin::ItemStack& PlayerItemPickupMutation::item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerItemPickupMutation.item)
  return _internal_item();
}
inline void PlayerItemPickupMutation::unsafe_arena_set_allocated_item(
    ::df::plugin::ItemStack* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = reinterpret_cast<::df::plugin::ItemStack*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.PlayerItemPickupMutation.item)
}
inline ::df::plugin::ItemStack* PROTOBUF_NULLABLE PlayerItemPickupMutation::release_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::ItemStack* released = _impl_.item_;
  _impl_.item_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::ItemStack* PROTOBUF_NULLABLE PlayerItemPickupMutation::unsafe_arena_release_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.PlayerItemPickupMutation.item)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::ItemStack* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::df::plugin::ItemStack* PROTOBUF_NONNULL PlayerItemPickupMutation::_internal_mutable_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.item_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::ItemStack>(GetArena());
    _impl_.item_ = reinterpret_cast<::df::plugin::ItemStack*>(p);
  }
  return _impl_.item_;
}
inline ::df::plugin::ItemStack* PROTOBUF_NONNULL PlayerItemPickupMutation::mutable_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::ItemStack* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:df.plugin.PlayerItemPickupMutation.item)
  return _msg;
}
inline void PlayerItemPickupMutation::set_allocated_item(::df::plugin::ItemStack* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.item_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.item_ = reinterpret_cast<::df::plugin::ItemStack*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.PlayerItemPickupMutation.item)
}

// -------------------------------------------------------------------

// PlayerTransferMutation

// optional .df.plugin.Address address = 1 [json_name = "address"];
inline bool PlayerTransferMutation::has_address() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.address_ != nullptr);
  return value;
}
inline const ::df::plugin::Address& PlayerTransferMutation::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::Address* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::Address&>(::df::plugin::_Address_default_instance_);
}
inline const ::df::plugin::Address& PlayerTransferMutation::address() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PlayerTransferMutation.address)
  return _internal_address();
}
inline void PlayerTransferMutation::unsafe_arena_set_allocated_address(
    ::df::plugin::Address* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = reinterpret_cast<::df::plugin::Address*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.PlayerTransferMutation.address)
}
inline ::df::plugin::Address* PROTOBUF_NULLABLE PlayerTransferMutation::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::Address* released = _impl_.address_;
  _impl_.address_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::Address* PROTOBUF_NULLABLE PlayerTransferMutation::unsafe_arena_release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.PlayerTransferMutation.address)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::Address* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::df::plugin::Address* PROTOBUF_NONNULL PlayerTransferMutation::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.address_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::Address>(GetArena());
    _impl_.address_ = reinterpret_cast<::df::plugin::Address*>(p);
  }
  return _impl_.address_;
}
inline ::df::plugin::Address* PROTOBUF_NONNULL PlayerTransferMutation::mutable_address()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::Address* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:df.plugin.PlayerTransferMutation.address)
  return _msg;
}
inline void PlayerTransferMutation::set_allocated_address(::df::plugin::Address* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.address_ = reinterpret_cast<::df::plugin::Address*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.PlayerTransferMutation.address)
}

// -------------------------------------------------------------------

// WorldExplosionMutation

// optional .df.plugin.StringList entity_uuids = 1 [json_name = "entityUuids"];
inline bool WorldExplosionMutation::has_entity_uuids() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.entity_uuids_ != nullptr);
  return value;
}
inline void WorldExplosionMutation::clear_entity_uuids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.entity_uuids_ != nullptr) _impl_.entity_uuids_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::df::plugin::StringList& WorldExplosionMutation::_internal_entity_uuids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::StringList* p = _impl_.entity_uuids_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::StringList&>(::df::plugin::_StringList_default_instance_);
}
inline const ::df::plugin::StringList& WorldExplosionMutation::entity_uuids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.WorldExplosionMutation.entity_uuids)
  return _internal_entity_uuids();
}
inline void WorldExplosionMutation::unsafe_arena_set_allocated_entity_uuids(
    ::df::plugin::StringList* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entity_uuids_);
  }
  _impl_.entity_uuids_ = reinterpret_cast<::df::plugin::StringList*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.WorldExplosionMutation.entity_uuids)
}
inline ::df::plugin::StringList* PROTOBUF_NULLABLE WorldExplosionMutation::release_entity_uuids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::StringList* released = _impl_.entity_uuids_;
  _impl_.entity_uuids_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::StringList* PROTOBUF_NULLABLE WorldExplosionMutation::unsafe_arena_release_entity_uuids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.WorldExplosionMutation.entity_uuids)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::StringList* temp = _impl_.entity_uuids_;
  _impl_.entity_uuids_ = nullptr;
  return temp;
}
inline ::df::plugin::StringList* PROTOBUF_NONNULL WorldExplosionMutation::_internal_mutable_entity_uuids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.entity_uuids_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::StringList>(GetArena());
    _impl_.entity_uuids_ = reinterpret_cast<::df::plugin::StringList*>(p);
  }
  return _impl_.entity_uuids_;
}
inline ::df::plugin::StringList* PROTOBUF_NONNULL WorldExplosionMutation::mutable_entity_uuids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::StringList* _msg = _internal_mutable_entity_uuids();
  // @@protoc_insertion_point(field_mutable:df.plugin.WorldExplosionMutation.entity_uuids)
  return _msg;
}
inline void WorldExplosionMutation::set_allocated_entity_uuids(::df::plugin::StringList* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entity_uuids_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.entity_uuids_ = reinterpret_cast<::df::plugin::StringList*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.WorldExplosionMutation.entity_uuids)
}

// optional .df.plugin.BlockPosList blocks = 2 [json_name = "blocks"];
inline bool WorldExplosionMutation::has_blocks() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.blocks_ != nullptr);
  return value;
}
inline void WorldExplosionMutation::clear_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.blocks_ != nullptr) _impl_.blocks_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::df::plugin::BlockPosList& WorldExplosionMutation::_internal_blocks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::BlockPosList* p = _impl_.blocks_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::BlockPosList&>(::df::plugin::_BlockPosList_default_instance_);
}
inline const ::df::plugin::BlockPosList& WorldExplosionMutation::blocks() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.WorldExplosionMutation.blocks)
  return _internal_blocks();
}
inline void WorldExplosionMutation::unsafe_arena_set_allocated_blocks(
    ::df::plugin::BlockPosList* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.blocks_);
  }
  _impl_.blocks_ = reinterpret_cast<::df::plugin::BlockPosList*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.WorldExplosionMutation.blocks)
}
inline ::df::plugin::BlockPosList* PROTOBUF_NULLABLE WorldExplosionMutation::release_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::BlockPosList* released = _impl_.blocks_;
  _impl_.blocks_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::BlockPosList* PROTOBUF_NULLABLE WorldExplosionMutation::unsafe_arena_release_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.WorldExplosionMutation.blocks)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::BlockPosList* temp = _impl_.blocks_;
  _impl_.blocks_ = nullptr;
  return temp;
}
inline ::df::plugin::BlockPosList* PROTOBUF_NONNULL WorldExplosionMutation::_internal_mutable_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.blocks_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::BlockPosList>(GetArena());
    _impl_.blocks_ = reinterpret_cast<::df::plugin::BlockPosList*>(p);
  }
  return _impl_.blocks_;
}
inline ::df::plugin::BlockPosList* PROTOBUF_NONNULL WorldExplosionMutation::mutable_blocks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::BlockPosList* _msg = _internal_mutable_blocks();
  // @@protoc_insertion_point(field_mutable:df.plugin.WorldExplosionMutation.blocks)
  return _msg;
}
inline void WorldExplosionMutation::set_allocated_blocks(::df::plugin::BlockPosList* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.blocks_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.blocks_ = reinterpret_cast<::df::plugin::BlockPosList*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.WorldExplosionMutation.blocks)
}

// optional double item_drop_chance = 3 [json_name = "itemDropChance"];
inline bool WorldExplosionMutation::has_item_drop_chance() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void WorldExplosionMutation::clear_item_drop_chance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.item_drop_chance_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double WorldExplosionMutation::item_drop_chance() const {
  // @@protoc_insertion_point(field_get:df.plugin.WorldExplosionMutation.item_drop_chance)
  return _internal_item_drop_chance();
}
inline void WorldExplosionMutation::set_item_drop_chance(double value) {
  _internal_set_item_drop_chance(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:df.plugin.WorldExplosionMutation.item_drop_chance)
}
inline double WorldExplosionMutation::_internal_item_drop_chance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.item_drop_chance_;
}
inline void WorldExplosionMutation::_internal_set_item_drop_chance(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.item_drop_chance_ = value;
}

// optional bool spawn_fire = 4 [json_name = "spawnFire"];
inline bool WorldExplosionMutation::has_spawn_fire() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void WorldExplosionMutation::clear_spawn_fire() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spawn_fire_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool WorldExplosionMutation::spawn_fire() const {
  // @@protoc_insertion_point(field_get:df.plugin.WorldExplosionMutation.spawn_fire)
  return _internal_spawn_fire();
}
inline void WorldExplosionMutation::set_spawn_fire(bool value) {
  _internal_set_spawn_fire(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:df.plugin.WorldExplosionMutation.spawn_fire)
}
inline bool WorldExplosionMutation::_internal_spawn_fire() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spawn_fire_;
}
inline void WorldExplosionMutation::_internal_set_spawn_fire(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spawn_fire_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace plugin
}  // namespace df


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // mutations_2eproto_2epb_2eh
