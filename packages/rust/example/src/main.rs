use dragonfly_plugin::{
    Plugin,
    PluginRunner,
    Server,
    event::{EventContext, EventHandler},
    event_handler,
    types, // All the raw prost/tonic types
};

// --- 2. Define a struct for your plugin's state ---
// It can be empty, or it can hold databases, configs, etc.
// Note `Plugin` is what enables the auto regisration feature
// and the plugin details via plugin(...)
// `subscriptions(xx)` is the events that your handle will sub
// to from the server.
// We add `Default` so it's easy to create.
#[derive(Plugin, Default)]
#[plugin(
    id = "example-rust",        // A unique ID for your plugin (matches plugins.yaml)
    name = "Example Rust Plugin", // A human-readable name
    version = "1.0.0",               // Your plugin's version
    api = "1.0.0",               // The API version you're built against
)]
struct MyExamplePlugin;

// --- 3. Implement the event handlers ---
// #[event_handler] is our magic proc macro that
// detects which handlers you are implementing and
// automatically gathers which events to subscribe to.
// This replaces the prior #[events()] and impl EventSubscriptions
// and manually writing the list in the function definition.
#[event_handler]
impl EventHandler for MyExamplePlugin {
    /// This handler runs when a player joins the server.
    /// We'll use it to send our "hello world" message.
    async fn on_player_join(
        &self,
        server: &Server,
        event: &mut EventContext<'_, types::PlayerJoinEvent>,
    ) {
        // Log to the plugin's console
        println!("Player '{}' has joined the server.", event.data.name);

        // We assume `send_chat` was generated by `xtask` from a `SendChatAction`.
        let welcome_message = format!(
            "Welcome, {}! This server is running MyExamplePlugin.",
            event.data.name
        );

        // We call the auto-generated `server.send_chat` helper.
        // On failure we log the error, but otherwise keep behavior unchanged.
        if let Err(e) = server
            .send_chat(event.data.player_uuid.clone(), welcome_message)
            .await
        {
            eprintln!("Failed to send welcome message: {}", e);
        }
    }

    /// This handler runs every time a player sends a chat message.
    /// We'll use it to edit the message.
    async fn on_chat(
        &self,
        _server: &Server, // We don't need the server handle for this
        event: &mut EventContext<'_, types::ChatEvent>,
    ) {
        // Get the original message from the event's data
        let original_message = &event.data.message;

        // Create the new message
        let new_message = format!("[Plugin] {}", original_message);

        // Use the auto-generated `set_message` helper to
        // mutate the event before the server processes it.
        event.set_message(new_message);
    }

    // We don't implement `on_player_hurt`, `on_block_break`, etc.,
}

// --- 4. The main function to run the plugin ---
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Starting the rust plugin...");

    PluginRunner::run(
        MyExamplePlugin,         // Pass in an instance of our plugin
        "tcp://127.0.0.1:50050", // The server address (e.g., TCP or Unix socket)
    )
    .await
}
