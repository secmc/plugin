//! This file is auto-generated by `xtask`. Do not edit manually.
#![allow(async_fn_in_trait)]
use crate::{
    event::EventContext, types, Server, EventSubscriptions, command::CommandRegistry,
};
pub trait EventHandler: EventSubscriptions + Send + Sync {
    ///Handler for the `PlayerJoin` event.
    async fn on_player_join(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerJoinEvent>,
    ) {}
    ///Handler for the `PlayerQuit` event.
    async fn on_player_quit(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerQuitEvent>,
    ) {}
    ///Handler for the `PlayerMove` event.
    async fn on_player_move(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerMoveEvent>,
    ) {}
    ///Handler for the `PlayerJump` event.
    async fn on_player_jump(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerJumpEvent>,
    ) {}
    ///Handler for the `PlayerTeleport` event.
    async fn on_player_teleport(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerTeleportEvent>,
    ) {}
    ///Handler for the `PlayerChangeWorld` event.
    async fn on_player_change_world(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerChangeWorldEvent>,
    ) {}
    ///Handler for the `PlayerToggleSprint` event.
    async fn on_player_toggle_sprint(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerToggleSprintEvent>,
    ) {}
    ///Handler for the `PlayerToggleSneak` event.
    async fn on_player_toggle_sneak(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerToggleSneakEvent>,
    ) {}
    ///Handler for the `Chat` event.
    async fn on_chat(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::ChatEvent>,
    ) {}
    ///Handler for the `PlayerFoodLoss` event.
    async fn on_player_food_loss(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerFoodLossEvent>,
    ) {}
    ///Handler for the `PlayerHeal` event.
    async fn on_player_heal(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerHealEvent>,
    ) {}
    ///Handler for the `PlayerHurt` event.
    async fn on_player_hurt(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerHurtEvent>,
    ) {}
    ///Handler for the `PlayerDeath` event.
    async fn on_player_death(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerDeathEvent>,
    ) {}
    ///Handler for the `PlayerRespawn` event.
    async fn on_player_respawn(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerRespawnEvent>,
    ) {}
    ///Handler for the `PlayerSkinChange` event.
    async fn on_player_skin_change(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerSkinChangeEvent>,
    ) {}
    ///Handler for the `PlayerFireExtinguish` event.
    async fn on_player_fire_extinguish(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerFireExtinguishEvent>,
    ) {}
    ///Handler for the `PlayerStartBreak` event.
    async fn on_player_start_break(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerStartBreakEvent>,
    ) {}
    ///Handler for the `BlockBreak` event.
    async fn on_block_break(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::BlockBreakEvent>,
    ) {}
    ///Handler for the `PlayerBlockPlace` event.
    async fn on_player_block_place(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerBlockPlaceEvent>,
    ) {}
    ///Handler for the `PlayerBlockPick` event.
    async fn on_player_block_pick(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerBlockPickEvent>,
    ) {}
    ///Handler for the `PlayerItemUse` event.
    async fn on_player_item_use(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerItemUseEvent>,
    ) {}
    ///Handler for the `PlayerItemUseOnBlock` event.
    async fn on_player_item_use_on_block(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerItemUseOnBlockEvent>,
    ) {}
    ///Handler for the `PlayerItemUseOnEntity` event.
    async fn on_player_item_use_on_entity(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerItemUseOnEntityEvent>,
    ) {}
    ///Handler for the `PlayerItemRelease` event.
    async fn on_player_item_release(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerItemReleaseEvent>,
    ) {}
    ///Handler for the `PlayerItemConsume` event.
    async fn on_player_item_consume(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerItemConsumeEvent>,
    ) {}
    ///Handler for the `PlayerAttackEntity` event.
    async fn on_player_attack_entity(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerAttackEntityEvent>,
    ) {}
    ///Handler for the `PlayerExperienceGain` event.
    async fn on_player_experience_gain(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerExperienceGainEvent>,
    ) {}
    ///Handler for the `PlayerPunchAir` event.
    async fn on_player_punch_air(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerPunchAirEvent>,
    ) {}
    ///Handler for the `PlayerSignEdit` event.
    async fn on_player_sign_edit(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerSignEditEvent>,
    ) {}
    ///Handler for the `PlayerLecternPageTurn` event.
    async fn on_player_lectern_page_turn(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerLecternPageTurnEvent>,
    ) {}
    ///Handler for the `PlayerItemDamage` event.
    async fn on_player_item_damage(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerItemDamageEvent>,
    ) {}
    ///Handler for the `PlayerItemPickup` event.
    async fn on_player_item_pickup(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerItemPickupEvent>,
    ) {}
    ///Handler for the `PlayerHeldSlotChange` event.
    async fn on_player_held_slot_change(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerHeldSlotChangeEvent>,
    ) {}
    ///Handler for the `PlayerItemDrop` event.
    async fn on_player_item_drop(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerItemDropEvent>,
    ) {}
    ///Handler for the `PlayerTransfer` event.
    async fn on_player_transfer(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerTransferEvent>,
    ) {}
    ///Handler for the `Command` event.
    async fn on_command(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::CommandEvent>,
    ) {}
    ///Handler for the `PlayerDiagnostics` event.
    async fn on_player_diagnostics(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::PlayerDiagnosticsEvent>,
    ) {}
    ///Handler for the `WorldLiquidFlow` event.
    async fn on_world_liquid_flow(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldLiquidFlowEvent>,
    ) {}
    ///Handler for the `WorldLiquidDecay` event.
    async fn on_world_liquid_decay(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldLiquidDecayEvent>,
    ) {}
    ///Handler for the `WorldLiquidHarden` event.
    async fn on_world_liquid_harden(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldLiquidHardenEvent>,
    ) {}
    ///Handler for the `WorldSound` event.
    async fn on_world_sound(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldSoundEvent>,
    ) {}
    ///Handler for the `WorldFireSpread` event.
    async fn on_world_fire_spread(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldFireSpreadEvent>,
    ) {}
    ///Handler for the `WorldBlockBurn` event.
    async fn on_world_block_burn(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldBlockBurnEvent>,
    ) {}
    ///Handler for the `WorldCropTrample` event.
    async fn on_world_crop_trample(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldCropTrampleEvent>,
    ) {}
    ///Handler for the `WorldLeavesDecay` event.
    async fn on_world_leaves_decay(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldLeavesDecayEvent>,
    ) {}
    ///Handler for the `WorldEntitySpawn` event.
    async fn on_world_entity_spawn(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldEntitySpawnEvent>,
    ) {}
    ///Handler for the `WorldEntityDespawn` event.
    async fn on_world_entity_despawn(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldEntityDespawnEvent>,
    ) {}
    ///Handler for the `WorldExplosion` event.
    async fn on_world_explosion(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldExplosionEvent>,
    ) {}
    ///Handler for the `WorldClose` event.
    async fn on_world_close(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::WorldCloseEvent>,
    ) {}
}
#[doc(hidden)]
pub async fn dispatch_event(
    server: &Server,
    handler: &(impl EventHandler + CommandRegistry),
    envelope: &types::EventEnvelope,
) {
    let Some(payload) = &envelope.payload else {
        return;
    };
    match payload {
        types::event_envelope::Payload::PlayerJoin(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_join(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerQuit(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_quit(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerMove(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_move(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerJump(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_jump(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerTeleport(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_teleport(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerChangeWorld(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_change_world(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerToggleSprint(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_toggle_sprint(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerToggleSneak(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_toggle_sneak(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::Chat(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_chat(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerFoodLoss(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_food_loss(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerHeal(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_heal(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerHurt(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_hurt(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerDeath(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_death(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerRespawn(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_respawn(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerSkinChange(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_skin_change(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerFireExtinguish(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_fire_extinguish(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerStartBreak(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_start_break(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::BlockBreak(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_block_break(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerBlockPlace(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_block_place(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerBlockPick(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_block_pick(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerItemUse(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_item_use(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerItemUseOnBlock(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_item_use_on_block(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerItemUseOnEntity(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_item_use_on_entity(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerItemRelease(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_item_release(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerItemConsume(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_item_consume(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerAttackEntity(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_attack_entity(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerExperienceGain(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_experience_gain(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerPunchAir(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_punch_air(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerSignEdit(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_sign_edit(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerLecternPageTurn(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_lectern_page_turn(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerItemDamage(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_item_damage(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerItemPickup(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_item_pickup(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerHeldSlotChange(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_held_slot_change(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerItemDrop(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_item_drop(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerTransfer(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_transfer(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::Command(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            let handled = handler.dispatch_commands(server, &mut context).await;
            if !handled {
                handler.on_command(server, &mut context).await;
            }
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::PlayerDiagnostics(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_player_diagnostics(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldLiquidFlow(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_liquid_flow(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldLiquidDecay(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_liquid_decay(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldLiquidHarden(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_liquid_harden(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldSound(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_sound(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldFireSpread(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_fire_spread(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldBlockBurn(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_block_burn(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldCropTrample(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_crop_trample(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldLeavesDecay(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_leaves_decay(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldEntitySpawn(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_entity_spawn(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldEntityDespawn(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_entity_despawn(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldExplosion(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_explosion(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::WorldClose(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_world_close(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
    }
}
