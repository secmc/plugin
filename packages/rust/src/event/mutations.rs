//! This file is auto-generated by `xtask`. Do not edit manually.
#![allow(clippy::all)]
use crate::types;
use crate::event::{EventContext, EventResult};
impl<'a> EventContext<'a, types::ChatEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result, EventResult::Mutated(types::EventResultUpdate::Chat(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::Chat(types::ChatMutation::default()),
            );
        }
    }
    ///Sets the `message` for this event.
    pub fn set_message(&mut self, message: impl Into<Option<String>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(types::EventResultUpdate::Chat(ref mut m)) = self
            .result
        {
            m.message = message.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::BlockBreakEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result, EventResult::Mutated(types::EventResultUpdate::BlockBreak(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::BlockBreak(
                    types::BlockBreakMutation::default(),
                ),
            );
        }
    }
    ///Sets the `drops` for this event.
    pub fn set_drops(
        &mut self,
        drops: impl Into<Option<types::ItemStackList>>,
    ) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(types::EventResultUpdate::BlockBreak(ref mut m)) = self
            .result
        {
            m.drops = drops.into();
        }
        self
    }
    ///Sets the `xp` for this event.
    pub fn set_xp(&mut self, xp: impl Into<Option<i32>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(types::EventResultUpdate::BlockBreak(ref mut m)) = self
            .result
        {
            m.xp = xp.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::PlayerFoodLossEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result,
            EventResult::Mutated(types::EventResultUpdate::PlayerFoodLoss(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::PlayerFoodLoss(
                    types::PlayerFoodLossMutation::default(),
                ),
            );
        }
    }
    ///Sets the `to` for this event.
    pub fn set_to(&mut self, to: impl Into<Option<i32>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::PlayerFoodLoss(ref mut m),
        ) = self.result
        {
            m.to = to.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::PlayerHealEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result, EventResult::Mutated(types::EventResultUpdate::PlayerHeal(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::PlayerHeal(
                    types::PlayerHealMutation::default(),
                ),
            );
        }
    }
    ///Sets the `amount` for this event.
    pub fn set_amount(&mut self, amount: impl Into<Option<f64>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(types::EventResultUpdate::PlayerHeal(ref mut m)) = self
            .result
        {
            m.amount = amount.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::PlayerHurtEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result, EventResult::Mutated(types::EventResultUpdate::PlayerHurt(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::PlayerHurt(
                    types::PlayerHurtMutation::default(),
                ),
            );
        }
    }
    ///Sets the `damage` for this event.
    pub fn set_damage(&mut self, damage: impl Into<Option<f64>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(types::EventResultUpdate::PlayerHurt(ref mut m)) = self
            .result
        {
            m.damage = damage.into();
        }
        self
    }
    ///Sets the `attack_immunity_ms` for this event.
    pub fn set_attack_immunity_ms(
        &mut self,
        attack_immunity_ms: impl Into<Option<i64>>,
    ) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(types::EventResultUpdate::PlayerHurt(ref mut m)) = self
            .result
        {
            m.attack_immunity_ms = attack_immunity_ms.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::PlayerDeathEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result, EventResult::Mutated(types::EventResultUpdate::PlayerDeath(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::PlayerDeath(
                    types::PlayerDeathMutation::default(),
                ),
            );
        }
    }
    ///Sets the `keep_inventory` for this event.
    pub fn set_keep_inventory(
        &mut self,
        keep_inventory: impl Into<Option<bool>>,
    ) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(types::EventResultUpdate::PlayerDeath(ref mut m)) = self
            .result
        {
            m.keep_inventory = keep_inventory.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::PlayerRespawnEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result, EventResult::Mutated(types::EventResultUpdate::PlayerRespawn(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::PlayerRespawn(
                    types::PlayerRespawnMutation::default(),
                ),
            );
        }
    }
    ///Sets the `position` for this event.
    pub fn set_position(
        &mut self,
        position: impl Into<Option<types::Vec3>>,
    ) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::PlayerRespawn(ref mut m),
        ) = self.result
        {
            m.position = position.into();
        }
        self
    }
    ///Sets the `world` for this event.
    pub fn set_world(&mut self, world: impl Into<Option<types::WorldRef>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::PlayerRespawn(ref mut m),
        ) = self.result
        {
            m.world = world.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::PlayerAttackEntityEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result,
            EventResult::Mutated(types::EventResultUpdate::PlayerAttackEntity(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::PlayerAttackEntity(
                    types::PlayerAttackEntityMutation::default(),
                ),
            );
        }
    }
    ///Sets the `force` for this event.
    pub fn set_force(&mut self, force: impl Into<Option<f64>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::PlayerAttackEntity(ref mut m),
        ) = self.result
        {
            m.force = force.into();
        }
        self
    }
    ///Sets the `height` for this event.
    pub fn set_height(&mut self, height: impl Into<Option<f64>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::PlayerAttackEntity(ref mut m),
        ) = self.result
        {
            m.height = height.into();
        }
        self
    }
    ///Sets the `critical` for this event.
    pub fn set_critical(&mut self, critical: impl Into<Option<bool>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::PlayerAttackEntity(ref mut m),
        ) = self.result
        {
            m.critical = critical.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::PlayerExperienceGainEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result,
            EventResult::Mutated(types::EventResultUpdate::PlayerExperienceGain(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::PlayerExperienceGain(
                    types::PlayerExperienceGainMutation::default(),
                ),
            );
        }
    }
    ///Sets the `amount` for this event.
    pub fn set_amount(&mut self, amount: impl Into<Option<i32>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::PlayerExperienceGain(ref mut m),
        ) = self.result
        {
            m.amount = amount.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::PlayerLecternPageTurnEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result,
            EventResult::Mutated(types::EventResultUpdate::PlayerLecternPageTurn(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::PlayerLecternPageTurn(
                    types::PlayerLecternPageTurnMutation::default(),
                ),
            );
        }
    }
    ///Sets the `new_page` for this event.
    pub fn set_new_page(&mut self, new_page: impl Into<Option<i32>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::PlayerLecternPageTurn(ref mut m),
        ) = self.result
        {
            m.new_page = new_page.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::PlayerItemPickupEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result,
            EventResult::Mutated(types::EventResultUpdate::PlayerItemPickup(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::PlayerItemPickup(
                    types::PlayerItemPickupMutation::default(),
                ),
            );
        }
    }
    ///Sets the `item` for this event.
    pub fn set_item(&mut self, item: impl Into<Option<types::ItemStack>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::PlayerItemPickup(ref mut m),
        ) = self.result
        {
            m.item = item.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::PlayerTransferEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result,
            EventResult::Mutated(types::EventResultUpdate::PlayerTransfer(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::PlayerTransfer(
                    types::PlayerTransferMutation::default(),
                ),
            );
        }
    }
    ///Sets the `address` for this event.
    pub fn set_address(
        &mut self,
        address: impl Into<Option<types::Address>>,
    ) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::PlayerTransfer(ref mut m),
        ) = self.result
        {
            m.address = address.into();
        }
        self
    }
}
impl<'a> EventContext<'a, types::WorldExplosionEvent> {
    fn ensure_mutation_exists(&mut self) {
        if !matches!(
            self.result,
            EventResult::Mutated(types::EventResultUpdate::WorldExplosion(_))
        ) {
            self.result = EventResult::Mutated(
                types::EventResultUpdate::WorldExplosion(
                    types::WorldExplosionMutation::default(),
                ),
            );
        }
    }
    ///Sets the `entity_uuids` for this event.
    pub fn set_entity_uuids(
        &mut self,
        entity_uuids: impl Into<Option<types::StringList>>,
    ) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::WorldExplosion(ref mut m),
        ) = self.result
        {
            m.entity_uuids = entity_uuids.into();
        }
        self
    }
    ///Sets the `blocks` for this event.
    pub fn set_blocks(
        &mut self,
        blocks: impl Into<Option<types::BlockPosList>>,
    ) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::WorldExplosion(ref mut m),
        ) = self.result
        {
            m.blocks = blocks.into();
        }
        self
    }
    ///Sets the `item_drop_chance` for this event.
    pub fn set_item_drop_chance(
        &mut self,
        item_drop_chance: impl Into<Option<f64>>,
    ) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::WorldExplosion(ref mut m),
        ) = self.result
        {
            m.item_drop_chance = item_drop_chance.into();
        }
        self
    }
    ///Sets the `spawn_fire` for this event.
    pub fn set_spawn_fire(&mut self, spawn_fire: impl Into<Option<bool>>) -> &mut Self {
        self.ensure_mutation_exists();
        if let EventResult::Mutated(
            types::EventResultUpdate::WorldExplosion(ref mut m),
        ) = self.result
        {
            m.spawn_fire = spawn_fire.into();
        }
        self
    }
}
