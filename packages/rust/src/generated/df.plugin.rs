// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vec3 {
    #[prost(double, tag="1")]
    pub x: f64,
    #[prost(double, tag="2")]
    pub y: f64,
    #[prost(double, tag="3")]
    pub z: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Rotation {
    #[prost(float, tag="1")]
    pub yaw: f32,
    #[prost(float, tag="2")]
    pub pitch: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BBox {
    #[prost(message, optional, tag="1")]
    pub min: ::core::option::Option<Vec3>,
    #[prost(message, optional, tag="2")]
    pub max: ::core::option::Option<Vec3>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlockPos {
    #[prost(int32, tag="1")]
    pub x: i32,
    #[prost(int32, tag="2")]
    pub y: i32,
    #[prost(int32, tag="3")]
    pub z: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemStack {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag="2")]
    pub meta: i32,
    #[prost(int32, tag="3")]
    pub count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockState {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="2")]
    pub properties: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiquidState {
    #[prost(message, optional, tag="1")]
    pub block: ::core::option::Option<BlockState>,
    #[prost(int32, tag="2")]
    pub depth: i32,
    #[prost(bool, tag="3")]
    pub falling: bool,
    #[prost(string, tag="4")]
    pub liquid_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldRef {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub dimension: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityRef {
    #[prost(string, tag="1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, optional, tag="3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<Vec3>,
    #[prost(message, optional, tag="5")]
    pub rotation: ::core::option::Option<Rotation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DamageSource {
    #[prost(string, tag="1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, optional, tag="2")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealingSource {
    #[prost(string, tag="1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, optional, tag="2")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    #[prost(string, tag="1")]
    pub host: ::prost::alloc::string::String,
    #[prost(int32, tag="2")]
    pub port: i32,
}
/// CustomItemDefinition defines a custom (non-vanilla) item that requires
/// a resource pack and client-side registration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomItemDefinition {
    /// Unique identifier for the custom item (e.g., "my_plugin:custom_sword")
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Display name shown to players
    #[prost(string, tag="2")]
    pub display_name: ::prost::alloc::string::String,
    /// Texture data encoded as PNG bytes
    #[prost(bytes="vec", tag="3")]
    pub texture_data: ::prost::alloc::vec::Vec<u8>,
    /// Creative inventory category
    #[prost(enumeration="ItemCategory", tag="4")]
    pub category: i32,
    /// Optional subgroup within the category (e.g., "sword", "pickaxe", "food")
    #[prost(string, optional, tag="5")]
    pub group: ::core::option::Option<::prost::alloc::string::String>,
    /// Metadata value for this item (defaults to 0)
    #[prost(int32, tag="6")]
    pub meta: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GameMode {
    Survival = 0,
    Creative = 1,
    Adventure = 2,
    Spectator = 3,
}
impl GameMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GameMode::Survival => "SURVIVAL",
            GameMode::Creative => "CREATIVE",
            GameMode::Adventure => "ADVENTURE",
            GameMode::Spectator => "SPECTATOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SURVIVAL" => Some(Self::Survival),
            "CREATIVE" => Some(Self::Creative),
            "ADVENTURE" => Some(Self::Adventure),
            "SPECTATOR" => Some(Self::Spectator),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Difficulty {
    Peaceful = 0,
    Easy = 1,
    Normal = 2,
    Hard = 3,
}
impl Difficulty {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Difficulty::Peaceful => "PEACEFUL",
            Difficulty::Easy => "EASY",
            Difficulty::Normal => "NORMAL",
            Difficulty::Hard => "HARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PEACEFUL" => Some(Self::Peaceful),
            "EASY" => Some(Self::Easy),
            "NORMAL" => Some(Self::Normal),
            "HARD" => Some(Self::Hard),
            _ => None,
        }
    }
}
/// EffectType mirrors Dragonfly's registered effect IDs for straightforward mapping.
/// Keep numeric values aligned with dragonfly/server/entity/effect/register.go.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EffectType {
    EffectUnknown = 0,
    Speed = 1,
    Slowness = 2,
    Haste = 3,
    MiningFatigue = 4,
    Strength = 5,
    InstantHealth = 6,
    InstantDamage = 7,
    JumpBoost = 8,
    Nausea = 9,
    Regeneration = 10,
    Resistance = 11,
    FireResistance = 12,
    WaterBreathing = 13,
    Invisibility = 14,
    Blindness = 15,
    NightVision = 16,
    Hunger = 17,
    Weakness = 18,
    Poison = 19,
    Wither = 20,
    HealthBoost = 21,
    Absorption = 22,
    Saturation = 23,
    Levitation = 24,
    FatalPoison = 25,
    ConduitPower = 26,
    SlowFalling = 27,
    /// 28, 29 intentionally omitted (Bad Omen, Hero of the Village - not implemented)
    Darkness = 30,
}
impl EffectType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EffectType::EffectUnknown => "EFFECT_UNKNOWN",
            EffectType::Speed => "SPEED",
            EffectType::Slowness => "SLOWNESS",
            EffectType::Haste => "HASTE",
            EffectType::MiningFatigue => "MINING_FATIGUE",
            EffectType::Strength => "STRENGTH",
            EffectType::InstantHealth => "INSTANT_HEALTH",
            EffectType::InstantDamage => "INSTANT_DAMAGE",
            EffectType::JumpBoost => "JUMP_BOOST",
            EffectType::Nausea => "NAUSEA",
            EffectType::Regeneration => "REGENERATION",
            EffectType::Resistance => "RESISTANCE",
            EffectType::FireResistance => "FIRE_RESISTANCE",
            EffectType::WaterBreathing => "WATER_BREATHING",
            EffectType::Invisibility => "INVISIBILITY",
            EffectType::Blindness => "BLINDNESS",
            EffectType::NightVision => "NIGHT_VISION",
            EffectType::Hunger => "HUNGER",
            EffectType::Weakness => "WEAKNESS",
            EffectType::Poison => "POISON",
            EffectType::Wither => "WITHER",
            EffectType::HealthBoost => "HEALTH_BOOST",
            EffectType::Absorption => "ABSORPTION",
            EffectType::Saturation => "SATURATION",
            EffectType::Levitation => "LEVITATION",
            EffectType::FatalPoison => "FATAL_POISON",
            EffectType::ConduitPower => "CONDUIT_POWER",
            EffectType::SlowFalling => "SLOW_FALLING",
            EffectType::Darkness => "DARKNESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EFFECT_UNKNOWN" => Some(Self::EffectUnknown),
            "SPEED" => Some(Self::Speed),
            "SLOWNESS" => Some(Self::Slowness),
            "HASTE" => Some(Self::Haste),
            "MINING_FATIGUE" => Some(Self::MiningFatigue),
            "STRENGTH" => Some(Self::Strength),
            "INSTANT_HEALTH" => Some(Self::InstantHealth),
            "INSTANT_DAMAGE" => Some(Self::InstantDamage),
            "JUMP_BOOST" => Some(Self::JumpBoost),
            "NAUSEA" => Some(Self::Nausea),
            "REGENERATION" => Some(Self::Regeneration),
            "RESISTANCE" => Some(Self::Resistance),
            "FIRE_RESISTANCE" => Some(Self::FireResistance),
            "WATER_BREATHING" => Some(Self::WaterBreathing),
            "INVISIBILITY" => Some(Self::Invisibility),
            "BLINDNESS" => Some(Self::Blindness),
            "NIGHT_VISION" => Some(Self::NightVision),
            "HUNGER" => Some(Self::Hunger),
            "WEAKNESS" => Some(Self::Weakness),
            "POISON" => Some(Self::Poison),
            "WITHER" => Some(Self::Wither),
            "HEALTH_BOOST" => Some(Self::HealthBoost),
            "ABSORPTION" => Some(Self::Absorption),
            "SATURATION" => Some(Self::Saturation),
            "LEVITATION" => Some(Self::Levitation),
            "FATAL_POISON" => Some(Self::FatalPoison),
            "CONDUIT_POWER" => Some(Self::ConduitPower),
            "SLOW_FALLING" => Some(Self::SlowFalling),
            "DARKNESS" => Some(Self::Darkness),
            _ => None,
        }
    }
}
/// Sound is a curated list of common sounds that don't require extra parameters.
/// For sounds that require additional context (e.g., BlockPlace, Note), adapters
/// may use sensible defaults or ignore extra semantics for now.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Sound {
    Unknown = 0,
    Attack = 1,
    Drowning = 2,
    Burning = 3,
    Fall = 4,
    Burp = 5,
    Pop = 6,
    Explosion = 7,
    Thunder = 8,
    LevelUp = 9,
    Experience = 10,
    FireworkLaunch = 11,
    FireworkHugeBlast = 12,
    FireworkBlast = 13,
    FireworkTwinkle = 14,
    Teleport = 15,
    ArrowHit = 16,
    ItemBreak = 17,
    ItemThrow = 18,
    Totem = 19,
    FireExtinguish = 20,
}
impl Sound {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Sound::Unknown => "SOUND_UNKNOWN",
            Sound::Attack => "ATTACK",
            Sound::Drowning => "DROWNING",
            Sound::Burning => "BURNING",
            Sound::Fall => "FALL",
            Sound::Burp => "BURP",
            Sound::Pop => "POP",
            Sound::Explosion => "EXPLOSION",
            Sound::Thunder => "THUNDER",
            Sound::LevelUp => "LEVEL_UP",
            Sound::Experience => "EXPERIENCE",
            Sound::FireworkLaunch => "FIREWORK_LAUNCH",
            Sound::FireworkHugeBlast => "FIREWORK_HUGE_BLAST",
            Sound::FireworkBlast => "FIREWORK_BLAST",
            Sound::FireworkTwinkle => "FIREWORK_TWINKLE",
            Sound::Teleport => "TELEPORT",
            Sound::ArrowHit => "ARROW_HIT",
            Sound::ItemBreak => "ITEM_BREAK",
            Sound::ItemThrow => "ITEM_THROW",
            Sound::Totem => "TOTEM",
            Sound::FireExtinguish => "FIRE_EXTINGUISH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SOUND_UNKNOWN" => Some(Self::Unknown),
            "ATTACK" => Some(Self::Attack),
            "DROWNING" => Some(Self::Drowning),
            "BURNING" => Some(Self::Burning),
            "FALL" => Some(Self::Fall),
            "BURP" => Some(Self::Burp),
            "POP" => Some(Self::Pop),
            "EXPLOSION" => Some(Self::Explosion),
            "THUNDER" => Some(Self::Thunder),
            "LEVEL_UP" => Some(Self::LevelUp),
            "EXPERIENCE" => Some(Self::Experience),
            "FIREWORK_LAUNCH" => Some(Self::FireworkLaunch),
            "FIREWORK_HUGE_BLAST" => Some(Self::FireworkHugeBlast),
            "FIREWORK_BLAST" => Some(Self::FireworkBlast),
            "FIREWORK_TWINKLE" => Some(Self::FireworkTwinkle),
            "TELEPORT" => Some(Self::Teleport),
            "ARROW_HIT" => Some(Self::ArrowHit),
            "ITEM_BREAK" => Some(Self::ItemBreak),
            "ITEM_THROW" => Some(Self::ItemThrow),
            "TOTEM" => Some(Self::Totem),
            "FIRE_EXTINGUISH" => Some(Self::FireExtinguish),
            _ => None,
        }
    }
}
/// Category for creative inventory
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ItemCategory {
    Construction = 0,
    Nature = 1,
    Equipment = 2,
    Items = 3,
}
impl ItemCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ItemCategory::Construction => "ITEM_CATEGORY_CONSTRUCTION",
            ItemCategory::Nature => "ITEM_CATEGORY_NATURE",
            ItemCategory::Equipment => "ITEM_CATEGORY_EQUIPMENT",
            ItemCategory::Items => "ITEM_CATEGORY_ITEMS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ITEM_CATEGORY_CONSTRUCTION" => Some(Self::Construction),
            "ITEM_CATEGORY_NATURE" => Some(Self::Nature),
            "ITEM_CATEGORY_EQUIPMENT" => Some(Self::Equipment),
            "ITEM_CATEGORY_ITEMS" => Some(Self::Items),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionBatch {
    #[prost(message, repeated, tag="1")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(string, optional, tag="1")]
    pub correlation_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof="action::Kind", tags="10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 30, 31, 40, 41, 42, 43, 50, 60, 61, 62, 63, 64, 65, 70, 71, 72")]
    pub kind: ::core::option::Option<action::Kind>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag="10")]
        SendChat(super::SendChatAction),
        #[prost(message, tag="11")]
        Teleport(super::TeleportAction),
        #[prost(message, tag="12")]
        Kick(super::KickAction),
        #[prost(message, tag="13")]
        SetGameMode(super::SetGameModeAction),
        /// Inventory & Items
        #[prost(message, tag="14")]
        GiveItem(super::GiveItemAction),
        #[prost(message, tag="15")]
        ClearInventory(super::ClearInventoryAction),
        #[prost(message, tag="16")]
        SetHeldItem(super::SetHeldItemAction),
        /// Player State
        #[prost(message, tag="20")]
        SetHealth(super::SetHealthAction),
        #[prost(message, tag="21")]
        SetFood(super::SetFoodAction),
        #[prost(message, tag="22")]
        SetExperience(super::SetExperienceAction),
        #[prost(message, tag="23")]
        SetVelocity(super::SetVelocityAction),
        /// Effects & Status
        #[prost(message, tag="30")]
        AddEffect(super::AddEffectAction),
        #[prost(message, tag="31")]
        RemoveEffect(super::RemoveEffectAction),
        /// UI & Communication
        #[prost(message, tag="40")]
        SendTitle(super::SendTitleAction),
        #[prost(message, tag="41")]
        SendPopup(super::SendPopupAction),
        #[prost(message, tag="42")]
        SendTip(super::SendTipAction),
        #[prost(message, tag="43")]
        PlaySound(super::PlaySoundAction),
        /// Commands
        #[prost(message, tag="50")]
        ExecuteCommand(super::ExecuteCommandAction),
        /// World configuration and effects
        #[prost(message, tag="60")]
        WorldSetDefaultGameMode(super::WorldSetDefaultGameModeAction),
        #[prost(message, tag="61")]
        WorldSetDifficulty(super::WorldSetDifficultyAction),
        #[prost(message, tag="62")]
        WorldSetTickRange(super::WorldSetTickRangeAction),
        #[prost(message, tag="63")]
        WorldSetBlock(super::WorldSetBlockAction),
        #[prost(message, tag="64")]
        WorldPlaySound(super::WorldPlaySoundAction),
        #[prost(message, tag="65")]
        WorldAddParticle(super::WorldAddParticleAction),
        /// World queries
        #[prost(message, tag="70")]
        WorldQueryEntities(super::WorldQueryEntitiesAction),
        #[prost(message, tag="71")]
        WorldQueryPlayers(super::WorldQueryPlayersAction),
        #[prost(message, tag="72")]
        WorldQueryEntitiesWithin(super::WorldQueryEntitiesWithinAction),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendChatAction {
    #[prost(string, tag="1")]
    pub target_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeleportAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub position: ::core::option::Option<Vec3>,
    /// rotation vector mapping:
    ///   x = pitch, y = yaw, z = head_yaw
    #[prost(message, optional, tag="3")]
    pub rotation: ::core::option::Option<Vec3>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KickAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGameModeAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(enumeration="GameMode", tag="2")]
    pub game_mode: i32,
}
/// Inventory & Items
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GiveItemAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub item: ::core::option::Option<ItemStack>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearInventoryAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetHeldItemAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    /// if set, updates main hand
    #[prost(message, optional, tag="2")]
    pub main: ::core::option::Option<ItemStack>,
    /// if set, updates offhand
    #[prost(message, optional, tag="3")]
    pub offhand: ::core::option::Option<ItemStack>,
}
/// Player State
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetHealthAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(double, tag="2")]
    pub health: f64,
    #[prost(double, optional, tag="3")]
    pub max_health: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetFoodAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    /// 0-20
    #[prost(int32, tag="2")]
    pub food: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetExperienceAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    /// If set, the player's level is set to this value.
    #[prost(int32, optional, tag="2")]
    pub level: ::core::option::Option<i32>,
    /// If set, the player's progress bar (0..1) is set to this value.
    #[prost(float, optional, tag="3")]
    pub progress: ::core::option::Option<f32>,
    /// If set, raw experience points are added (can be negative to remove).
    #[prost(int32, optional, tag="4")]
    pub amount: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetVelocityAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub velocity: ::core::option::Option<Vec3>,
}
/// Effects & Status
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddEffectAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(enumeration="EffectType", tag="2")]
    pub effect_type: i32,
    /// amplifier level (1 = level I)
    #[prost(int32, tag="3")]
    pub level: i32,
    /// duration in milliseconds
    #[prost(int64, tag="4")]
    pub duration_ms: i64,
    #[prost(bool, tag="5")]
    pub show_particles: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveEffectAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(enumeration="EffectType", tag="2")]
    pub effect_type: i32,
}
/// UI & Communication
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendTitleAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, optional, tag="3")]
    pub subtitle: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag="4")]
    pub fade_in_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="5")]
    pub duration_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="6")]
    pub fade_out_ms: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendPopupAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendTipAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
}
/// TODO: it should probably be a world action
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaySoundAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(enumeration="Sound", tag="2")]
    pub sound: i32,
    /// defaults to player position if unset
    #[prost(message, optional, tag="3")]
    pub position: ::core::option::Option<Vec3>,
    /// default 1.0
    #[prost(float, optional, tag="4")]
    pub volume: ::core::option::Option<f32>,
    /// default 1.0
    #[prost(float, optional, tag="5")]
    pub pitch: ::core::option::Option<f32>,
}
/// Commands
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteCommandAction {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    /// without leading slash
    #[prost(string, tag="2")]
    pub command: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldSetDefaultGameModeAction {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(enumeration="GameMode", tag="2")]
    pub game_mode: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldSetDifficultyAction {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(enumeration="Difficulty", tag="2")]
    pub difficulty: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldSetTickRangeAction {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(int32, tag="2")]
    pub tick_range: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldSetBlockAction {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub position: ::core::option::Option<BlockPos>,
    /// nil clears to air
    #[prost(message, optional, tag="3")]
    pub block: ::core::option::Option<BlockState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldPlaySoundAction {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(enumeration="Sound", tag="2")]
    pub sound: i32,
    #[prost(message, optional, tag="3")]
    pub position: ::core::option::Option<Vec3>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldAddParticleAction {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub position: ::core::option::Option<Vec3>,
    #[prost(enumeration="ParticleType", tag="3")]
    pub particle: i32,
    /// used for block-based particles when provided
    #[prost(message, optional, tag="4")]
    pub block: ::core::option::Option<BlockState>,
    /// used for punch_block when provided
    #[prost(int32, optional, tag="5")]
    pub face: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldQueryEntitiesAction {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldQueryPlayersAction {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldQueryEntitiesWithinAction {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub r#box: ::core::option::Option<BBox>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionStatus {
    #[prost(bool, tag="1")]
    pub ok: bool,
    #[prost(string, optional, tag="2")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldEntitiesResult {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, repeated, tag="2")]
    pub entities: ::prost::alloc::vec::Vec<EntityRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldEntitiesWithinResult {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub r#box: ::core::option::Option<BBox>,
    #[prost(message, repeated, tag="3")]
    pub entities: ::prost::alloc::vec::Vec<EntityRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldPlayersResult {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, repeated, tag="2")]
    pub players: ::prost::alloc::vec::Vec<EntityRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionResult {
    #[prost(string, tag="1")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub status: ::core::option::Option<ActionStatus>,
    #[prost(oneof="action_result::Result", tags="10, 11, 12")]
    pub result: ::core::option::Option<action_result::Result>,
}
/// Nested message and enum types in `ActionResult`.
pub mod action_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="10")]
        WorldEntities(super::WorldEntitiesResult),
        #[prost(message, tag="11")]
        WorldPlayers(super::WorldPlayersResult),
        #[prost(message, tag="12")]
        WorldEntitiesWithin(super::WorldEntitiesWithinResult),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParticleType {
    Unspecified = 0,
    ParticleHugeExplosion = 1,
    ParticleEndermanTeleport = 2,
    ParticleSnowballPoof = 3,
    ParticleEggSmash = 4,
    ParticleSplash = 5,
    ParticleEffect = 6,
    ParticleEntityFlame = 7,
    ParticleFlame = 8,
    ParticleDust = 9,
    ParticleBlockForceField = 10,
    ParticleBoneMeal = 11,
    ParticleEvaporate = 12,
    ParticleWaterDrip = 13,
    ParticleLavaDrip = 14,
    ParticleLava = 15,
    ParticleDustPlume = 16,
    ParticleBlockBreak = 17,
    ParticlePunchBlock = 18,
}
impl ParticleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ParticleType::Unspecified => "PARTICLE_TYPE_UNSPECIFIED",
            ParticleType::ParticleHugeExplosion => "PARTICLE_HUGE_EXPLOSION",
            ParticleType::ParticleEndermanTeleport => "PARTICLE_ENDERMAN_TELEPORT",
            ParticleType::ParticleSnowballPoof => "PARTICLE_SNOWBALL_POOF",
            ParticleType::ParticleEggSmash => "PARTICLE_EGG_SMASH",
            ParticleType::ParticleSplash => "PARTICLE_SPLASH",
            ParticleType::ParticleEffect => "PARTICLE_EFFECT",
            ParticleType::ParticleEntityFlame => "PARTICLE_ENTITY_FLAME",
            ParticleType::ParticleFlame => "PARTICLE_FLAME",
            ParticleType::ParticleDust => "PARTICLE_DUST",
            ParticleType::ParticleBlockForceField => "PARTICLE_BLOCK_FORCE_FIELD",
            ParticleType::ParticleBoneMeal => "PARTICLE_BONE_MEAL",
            ParticleType::ParticleEvaporate => "PARTICLE_EVAPORATE",
            ParticleType::ParticleWaterDrip => "PARTICLE_WATER_DRIP",
            ParticleType::ParticleLavaDrip => "PARTICLE_LAVA_DRIP",
            ParticleType::ParticleLava => "PARTICLE_LAVA",
            ParticleType::ParticleDustPlume => "PARTICLE_DUST_PLUME",
            ParticleType::ParticleBlockBreak => "PARTICLE_BLOCK_BREAK",
            ParticleType::ParticlePunchBlock => "PARTICLE_PUNCH_BLOCK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARTICLE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PARTICLE_HUGE_EXPLOSION" => Some(Self::ParticleHugeExplosion),
            "PARTICLE_ENDERMAN_TELEPORT" => Some(Self::ParticleEndermanTeleport),
            "PARTICLE_SNOWBALL_POOF" => Some(Self::ParticleSnowballPoof),
            "PARTICLE_EGG_SMASH" => Some(Self::ParticleEggSmash),
            "PARTICLE_SPLASH" => Some(Self::ParticleSplash),
            "PARTICLE_EFFECT" => Some(Self::ParticleEffect),
            "PARTICLE_ENTITY_FLAME" => Some(Self::ParticleEntityFlame),
            "PARTICLE_FLAME" => Some(Self::ParticleFlame),
            "PARTICLE_DUST" => Some(Self::ParticleDust),
            "PARTICLE_BLOCK_FORCE_FIELD" => Some(Self::ParticleBlockForceField),
            "PARTICLE_BONE_MEAL" => Some(Self::ParticleBoneMeal),
            "PARTICLE_EVAPORATE" => Some(Self::ParticleEvaporate),
            "PARTICLE_WATER_DRIP" => Some(Self::ParticleWaterDrip),
            "PARTICLE_LAVA_DRIP" => Some(Self::ParticleLavaDrip),
            "PARTICLE_LAVA" => Some(Self::ParticleLava),
            "PARTICLE_DUST_PLUME" => Some(Self::ParticleDustPlume),
            "PARTICLE_BLOCK_BREAK" => Some(Self::ParticleBlockBreak),
            "PARTICLE_PUNCH_BLOCK" => Some(Self::ParticlePunchBlock),
            _ => None,
        }
    }
}
/// Parameter specification for a command.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParamSpec {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration="ParamType", tag="2")]
    pub r#type: i32,
    #[prost(bool, tag="3")]
    pub optional: bool,
    /// Optional suffix as supported by Go cmd tags (e.g., units)
    #[prost(string, tag="4")]
    pub suffix: ::prost::alloc::string::String,
    /// Optional list of enum values to present in the client UI.
    /// When set, the parameter is shown as an enum selector regardless of ParamType.
    #[prost(string, repeated, tag="5")]
    pub enum_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Command specification announced by a plugin during handshake.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandSpec {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="3")]
    pub aliases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="4")]
    pub params: ::prost::alloc::vec::Vec<ParamSpec>,
}
/// Player command execution event.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Full command string like "/tp 100 64 200"
    #[prost(string, tag="3")]
    pub raw: ::prost::alloc::string::String,
    /// Just the command name like "tp"
    #[prost(string, tag="4")]
    pub command: ::prost::alloc::string::String,
    /// Parsed arguments like \["100", "64", "200"\]
    #[prost(string, repeated, tag="5")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Supported parameter types for commands.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParamType {
    ParamString = 0,
    ParamInt = 1,
    ParamFloat = 2,
    ParamBool = 3,
    ParamVarargs = 4,
    ParamEnum = 5,
}
impl ParamType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ParamType::ParamString => "PARAM_STRING",
            ParamType::ParamInt => "PARAM_INT",
            ParamType::ParamFloat => "PARAM_FLOAT",
            ParamType::ParamBool => "PARAM_BOOL",
            ParamType::ParamVarargs => "PARAM_VARARGS",
            ParamType::ParamEnum => "PARAM_ENUM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARAM_STRING" => Some(Self::ParamString),
            "PARAM_INT" => Some(Self::ParamInt),
            "PARAM_FLOAT" => Some(Self::ParamFloat),
            "PARAM_BOOL" => Some(Self::ParamBool),
            "PARAM_VARARGS" => Some(Self::ParamVarargs),
            "PARAM_ENUM" => Some(Self::ParamEnum),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventResult {
    #[prost(string, tag="1")]
    pub event_id: ::prost::alloc::string::String,
    #[prost(bool, optional, tag="2")]
    pub cancel: ::core::option::Option<bool>,
    #[prost(oneof="event_result::Update", tags="10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 30")]
    pub update: ::core::option::Option<event_result::Update>,
}
/// Nested message and enum types in `EventResult`.
pub mod event_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Update {
        #[prost(message, tag="10")]
        Chat(super::ChatMutation),
        #[prost(message, tag="11")]
        BlockBreak(super::BlockBreakMutation),
        #[prost(message, tag="12")]
        PlayerFoodLoss(super::PlayerFoodLossMutation),
        #[prost(message, tag="13")]
        PlayerHeal(super::PlayerHealMutation),
        #[prost(message, tag="14")]
        PlayerHurt(super::PlayerHurtMutation),
        #[prost(message, tag="15")]
        PlayerDeath(super::PlayerDeathMutation),
        #[prost(message, tag="16")]
        PlayerRespawn(super::PlayerRespawnMutation),
        #[prost(message, tag="17")]
        PlayerAttackEntity(super::PlayerAttackEntityMutation),
        #[prost(message, tag="18")]
        PlayerExperienceGain(super::PlayerExperienceGainMutation),
        #[prost(message, tag="19")]
        PlayerLecternPageTurn(super::PlayerLecternPageTurnMutation),
        #[prost(message, tag="20")]
        PlayerItemPickup(super::PlayerItemPickupMutation),
        #[prost(message, tag="21")]
        PlayerTransfer(super::PlayerTransferMutation),
        #[prost(message, tag="30")]
        WorldExplosion(super::WorldExplosionMutation),
    }
}
/// Wrapper messages for repeated fields to allow detecting "not set" vs "empty"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemStackList {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<ItemStack>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringList {
    #[prost(string, repeated, tag="1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockPosList {
    #[prost(message, repeated, tag="1")]
    pub positions: ::prost::alloc::vec::Vec<BlockPos>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatMutation {
    #[prost(string, optional, tag="1")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockBreakMutation {
    #[prost(message, optional, tag="1")]
    pub drops: ::core::option::Option<ItemStackList>,
    #[prost(int32, optional, tag="2")]
    pub xp: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerFoodLossMutation {
    #[prost(int32, optional, tag="1")]
    pub to: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerHealMutation {
    #[prost(double, optional, tag="1")]
    pub amount: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerHurtMutation {
    #[prost(double, optional, tag="1")]
    pub damage: ::core::option::Option<f64>,
    #[prost(int64, optional, tag="2")]
    pub attack_immunity_ms: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDeathMutation {
    #[prost(bool, optional, tag="1")]
    pub keep_inventory: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerRespawnMutation {
    #[prost(message, optional, tag="1")]
    pub position: ::core::option::Option<Vec3>,
    #[prost(message, optional, tag="2")]
    pub world: ::core::option::Option<WorldRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerAttackEntityMutation {
    #[prost(double, optional, tag="1")]
    pub force: ::core::option::Option<f64>,
    #[prost(double, optional, tag="2")]
    pub height: ::core::option::Option<f64>,
    #[prost(bool, optional, tag="3")]
    pub critical: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerExperienceGainMutation {
    #[prost(int32, optional, tag="1")]
    pub amount: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerLecternPageTurnMutation {
    #[prost(int32, optional, tag="1")]
    pub new_page: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerItemPickupMutation {
    #[prost(message, optional, tag="1")]
    pub item: ::core::option::Option<ItemStack>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerTransferMutation {
    #[prost(message, optional, tag="1")]
    pub address: ::core::option::Option<Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldExplosionMutation {
    #[prost(message, optional, tag="1")]
    pub entity_uuids: ::core::option::Option<StringList>,
    #[prost(message, optional, tag="2")]
    pub blocks: ::core::option::Option<BlockPosList>,
    #[prost(double, optional, tag="3")]
    pub item_drop_chance: ::core::option::Option<f64>,
    #[prost(bool, optional, tag="4")]
    pub spawn_fire: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerJoinEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerQuitEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerMoveEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<Vec3>,
    #[prost(message, optional, tag="5")]
    pub rotation: ::core::option::Option<Rotation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerJumpEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<Vec3>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerTeleportEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<Vec3>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerChangeWorldEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub before: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="4")]
    pub after: ::core::option::Option<WorldRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerToggleSprintEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag="3")]
    pub after: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerToggleSneakEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag="3")]
    pub after: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerFoodLossEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag="3")]
    pub from: i32,
    #[prost(int32, tag="4")]
    pub to: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerHealEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag="3")]
    pub amount: f64,
    #[prost(message, optional, tag="4")]
    pub source: ::core::option::Option<HealingSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerHurtEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag="3")]
    pub damage: f64,
    #[prost(bool, tag="4")]
    pub immune: bool,
    #[prost(int64, tag="5")]
    pub attack_immunity_ms: i64,
    #[prost(message, optional, tag="6")]
    pub source: ::core::option::Option<DamageSource>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerDeathEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub source: ::core::option::Option<DamageSource>,
    #[prost(bool, tag="4")]
    pub keep_inventory: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerRespawnEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub position: ::core::option::Option<Vec3>,
    #[prost(message, optional, tag="4")]
    pub world: ::core::option::Option<WorldRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerSkinChangeEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag="3")]
    pub full_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub play_fab_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag="5")]
    pub persona: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerFireExtinguishEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<BlockPos>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerStartBreakEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<BlockPos>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockBreakEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<BlockPos>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerBlockPlaceEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<BlockPos>,
    #[prost(message, optional, tag="5")]
    pub block: ::core::option::Option<BlockState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerBlockPickEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<BlockPos>,
    #[prost(message, optional, tag="5")]
    pub block: ::core::option::Option<BlockState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerItemUseEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub item: ::core::option::Option<ItemStack>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerItemUseOnBlockEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<BlockPos>,
    #[prost(string, tag="5")]
    pub face: ::prost::alloc::string::String,
    #[prost(message, optional, tag="6")]
    pub click_position: ::core::option::Option<Vec3>,
    #[prost(message, optional, tag="7")]
    pub block: ::core::option::Option<BlockState>,
    #[prost(message, optional, tag="8")]
    pub item: ::core::option::Option<ItemStack>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerItemUseOnEntityEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub entity: ::core::option::Option<EntityRef>,
    #[prost(message, optional, tag="5")]
    pub item: ::core::option::Option<ItemStack>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerItemReleaseEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub item: ::core::option::Option<ItemStack>,
    #[prost(int64, tag="5")]
    pub duration_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerItemConsumeEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub item: ::core::option::Option<ItemStack>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerAttackEntityEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub entity: ::core::option::Option<EntityRef>,
    #[prost(double, tag="5")]
    pub force: f64,
    #[prost(double, tag="6")]
    pub height: f64,
    #[prost(bool, tag="7")]
    pub critical: bool,
    #[prost(message, optional, tag="8")]
    pub item: ::core::option::Option<ItemStack>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerExperienceGainEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(int32, tag="4")]
    pub amount: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerPunchAirEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerSignEditEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<BlockPos>,
    #[prost(bool, tag="5")]
    pub front_side: bool,
    #[prost(string, tag="6")]
    pub old_text: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub new_text: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerLecternPageTurnEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub position: ::core::option::Option<BlockPos>,
    #[prost(int32, tag="5")]
    pub old_page: i32,
    #[prost(int32, tag="6")]
    pub new_page: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerItemDamageEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub item: ::core::option::Option<ItemStack>,
    #[prost(int32, tag="5")]
    pub damage: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerItemPickupEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub item: ::core::option::Option<ItemStack>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerHeldSlotChangeEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(int32, tag="4")]
    pub from_slot: i32,
    #[prost(int32, tag="5")]
    pub to_slot: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerItemDropEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub world: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub item: ::core::option::Option<ItemStack>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerTransferEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub address: ::core::option::Option<Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerDiagnosticsEvent {
    #[prost(string, tag="1")]
    pub player_uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag="3")]
    pub average_frames_per_second: f64,
    #[prost(double, tag="4")]
    pub average_server_sim_tick_time: f64,
    #[prost(double, tag="5")]
    pub average_client_sim_tick_time: f64,
    #[prost(double, tag="6")]
    pub average_begin_frame_time: f64,
    #[prost(double, tag="7")]
    pub average_input_time: f64,
    #[prost(double, tag="8")]
    pub average_render_time: f64,
    #[prost(double, tag="9")]
    pub average_end_frame_time: f64,
    #[prost(double, tag="10")]
    pub average_remainder_time_percent: f64,
    #[prost(double, tag="11")]
    pub average_unaccounted_time_percent: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldLiquidFlowEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub from: ::core::option::Option<BlockPos>,
    #[prost(message, optional, tag="3")]
    pub to: ::core::option::Option<BlockPos>,
    #[prost(message, optional, tag="4")]
    pub liquid: ::core::option::Option<LiquidState>,
    #[prost(message, optional, tag="5")]
    pub replaced: ::core::option::Option<BlockState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldLiquidDecayEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub position: ::core::option::Option<BlockPos>,
    #[prost(message, optional, tag="3")]
    pub before: ::core::option::Option<LiquidState>,
    #[prost(message, optional, tag="4")]
    pub after: ::core::option::Option<LiquidState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldLiquidHardenEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub position: ::core::option::Option<BlockPos>,
    #[prost(message, optional, tag="3")]
    pub liquid_hardened: ::core::option::Option<LiquidState>,
    #[prost(message, optional, tag="4")]
    pub other_liquid: ::core::option::Option<LiquidState>,
    #[prost(message, optional, tag="5")]
    pub new_block: ::core::option::Option<BlockState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldSoundEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(string, tag="2")]
    pub sound: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub position: ::core::option::Option<Vec3>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldFireSpreadEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub from: ::core::option::Option<BlockPos>,
    #[prost(message, optional, tag="3")]
    pub to: ::core::option::Option<BlockPos>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldBlockBurnEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub position: ::core::option::Option<BlockPos>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldCropTrampleEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub position: ::core::option::Option<BlockPos>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldLeavesDecayEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub position: ::core::option::Option<BlockPos>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldEntitySpawnEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub entity: ::core::option::Option<EntityRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldEntityDespawnEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub entity: ::core::option::Option<EntityRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldExplosionEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
    #[prost(message, optional, tag="2")]
    pub position: ::core::option::Option<Vec3>,
    #[prost(message, repeated, tag="3")]
    pub affected_entities: ::prost::alloc::vec::Vec<EntityRef>,
    #[prost(message, repeated, tag="4")]
    pub affected_blocks: ::prost::alloc::vec::Vec<BlockPos>,
    #[prost(double, tag="5")]
    pub item_drop_chance: f64,
    #[prost(bool, tag="6")]
    pub spawn_fire: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldCloseEvent {
    #[prost(message, optional, tag="1")]
    pub world: ::core::option::Option<WorldRef>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostToPlugin {
    #[prost(string, tag="1")]
    pub plugin_id: ::prost::alloc::string::String,
    #[prost(oneof="host_to_plugin::Payload", tags="10, 11, 12, 20, 21")]
    pub payload: ::core::option::Option<host_to_plugin::Payload>,
}
/// Nested message and enum types in `HostToPlugin`.
pub mod host_to_plugin {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag="10")]
        Hello(super::HostHello),
        #[prost(message, tag="11")]
        Shutdown(super::HostShutdown),
        #[prost(message, tag="12")]
        ServerInfo(super::ServerInformationResponse),
        #[prost(message, tag="20")]
        Event(super::EventEnvelope),
        #[prost(message, tag="21")]
        ActionResult(super::ActionResult),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerInformationRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerInformationResponse {
    #[prost(string, repeated, tag="1")]
    pub plugins: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostHello {
    #[prost(string, tag="1")]
    pub api_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostShutdown {
    #[prost(string, tag="1")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventEnvelope {
    #[prost(string, tag="1")]
    pub event_id: ::prost::alloc::string::String,
    #[prost(enumeration="EventType", tag="2")]
    pub r#type: i32,
    /// If an event can be cancelled or mutated it expects an acknowledgement.
    #[prost(bool, tag="3")]
    pub expects_response: bool,
    #[prost(oneof="event_envelope::Payload", tags="10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81")]
    pub payload: ::core::option::Option<event_envelope::Payload>,
}
/// Nested message and enum types in `EventEnvelope`.
pub mod event_envelope {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag="10")]
        PlayerJoin(super::PlayerJoinEvent),
        #[prost(message, tag="11")]
        PlayerQuit(super::PlayerQuitEvent),
        #[prost(message, tag="12")]
        PlayerMove(super::PlayerMoveEvent),
        #[prost(message, tag="13")]
        PlayerJump(super::PlayerJumpEvent),
        #[prost(message, tag="14")]
        PlayerTeleport(super::PlayerTeleportEvent),
        #[prost(message, tag="15")]
        PlayerChangeWorld(super::PlayerChangeWorldEvent),
        #[prost(message, tag="16")]
        PlayerToggleSprint(super::PlayerToggleSprintEvent),
        #[prost(message, tag="17")]
        PlayerToggleSneak(super::PlayerToggleSneakEvent),
        #[prost(message, tag="18")]
        Chat(super::ChatEvent),
        #[prost(message, tag="19")]
        PlayerFoodLoss(super::PlayerFoodLossEvent),
        #[prost(message, tag="20")]
        PlayerHeal(super::PlayerHealEvent),
        #[prost(message, tag="21")]
        PlayerHurt(super::PlayerHurtEvent),
        #[prost(message, tag="22")]
        PlayerDeath(super::PlayerDeathEvent),
        #[prost(message, tag="23")]
        PlayerRespawn(super::PlayerRespawnEvent),
        #[prost(message, tag="24")]
        PlayerSkinChange(super::PlayerSkinChangeEvent),
        #[prost(message, tag="25")]
        PlayerFireExtinguish(super::PlayerFireExtinguishEvent),
        #[prost(message, tag="26")]
        PlayerStartBreak(super::PlayerStartBreakEvent),
        #[prost(message, tag="27")]
        BlockBreak(super::BlockBreakEvent),
        #[prost(message, tag="28")]
        PlayerBlockPlace(super::PlayerBlockPlaceEvent),
        #[prost(message, tag="29")]
        PlayerBlockPick(super::PlayerBlockPickEvent),
        #[prost(message, tag="30")]
        PlayerItemUse(super::PlayerItemUseEvent),
        #[prost(message, tag="31")]
        PlayerItemUseOnBlock(super::PlayerItemUseOnBlockEvent),
        #[prost(message, tag="32")]
        PlayerItemUseOnEntity(super::PlayerItemUseOnEntityEvent),
        #[prost(message, tag="33")]
        PlayerItemRelease(super::PlayerItemReleaseEvent),
        #[prost(message, tag="34")]
        PlayerItemConsume(super::PlayerItemConsumeEvent),
        #[prost(message, tag="35")]
        PlayerAttackEntity(super::PlayerAttackEntityEvent),
        #[prost(message, tag="36")]
        PlayerExperienceGain(super::PlayerExperienceGainEvent),
        #[prost(message, tag="37")]
        PlayerPunchAir(super::PlayerPunchAirEvent),
        #[prost(message, tag="38")]
        PlayerSignEdit(super::PlayerSignEditEvent),
        #[prost(message, tag="39")]
        PlayerLecternPageTurn(super::PlayerLecternPageTurnEvent),
        #[prost(message, tag="40")]
        PlayerItemDamage(super::PlayerItemDamageEvent),
        #[prost(message, tag="41")]
        PlayerItemPickup(super::PlayerItemPickupEvent),
        #[prost(message, tag="42")]
        PlayerHeldSlotChange(super::PlayerHeldSlotChangeEvent),
        #[prost(message, tag="43")]
        PlayerItemDrop(super::PlayerItemDropEvent),
        #[prost(message, tag="44")]
        PlayerTransfer(super::PlayerTransferEvent),
        #[prost(message, tag="45")]
        Command(super::CommandEvent),
        #[prost(message, tag="46")]
        PlayerDiagnostics(super::PlayerDiagnosticsEvent),
        #[prost(message, tag="70")]
        WorldLiquidFlow(super::WorldLiquidFlowEvent),
        #[prost(message, tag="71")]
        WorldLiquidDecay(super::WorldLiquidDecayEvent),
        #[prost(message, tag="72")]
        WorldLiquidHarden(super::WorldLiquidHardenEvent),
        #[prost(message, tag="73")]
        WorldSound(super::WorldSoundEvent),
        #[prost(message, tag="74")]
        WorldFireSpread(super::WorldFireSpreadEvent),
        #[prost(message, tag="75")]
        WorldBlockBurn(super::WorldBlockBurnEvent),
        #[prost(message, tag="76")]
        WorldCropTrample(super::WorldCropTrampleEvent),
        #[prost(message, tag="77")]
        WorldLeavesDecay(super::WorldLeavesDecayEvent),
        #[prost(message, tag="78")]
        WorldEntitySpawn(super::WorldEntitySpawnEvent),
        #[prost(message, tag="79")]
        WorldEntityDespawn(super::WorldEntityDespawnEvent),
        #[prost(message, tag="80")]
        WorldExplosion(super::WorldExplosionEvent),
        #[prost(message, tag="81")]
        WorldClose(super::WorldCloseEvent),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluginToHost {
    #[prost(string, tag="1")]
    pub plugin_id: ::prost::alloc::string::String,
    #[prost(oneof="plugin_to_host::Payload", tags="10, 11, 12, 20, 30, 40")]
    pub payload: ::core::option::Option<plugin_to_host::Payload>,
}
/// Nested message and enum types in `PluginToHost`.
pub mod plugin_to_host {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag="10")]
        Hello(super::PluginHello),
        #[prost(message, tag="11")]
        Subscribe(super::EventSubscribe),
        #[prost(message, tag="12")]
        ServerInfo(super::ServerInformationRequest),
        #[prost(message, tag="20")]
        Actions(super::ActionBatch),
        #[prost(message, tag="30")]
        Log(super::LogMessage),
        #[prost(message, tag="40")]
        EventResult(super::EventResult),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluginHello {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub api_version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub commands: ::prost::alloc::vec::Vec<CommandSpec>,
    #[prost(message, repeated, tag="5")]
    pub custom_items: ::prost::alloc::vec::Vec<CustomItemDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogMessage {
    #[prost(string, tag="1")]
    pub level: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventSubscribe {
    #[prost(enumeration="EventType", repeated, tag="1")]
    pub events: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventType {
    Unspecified = 0,
    All = 1,
    PlayerJoin = 10,
    PlayerQuit = 11,
    PlayerMove = 12,
    PlayerJump = 13,
    PlayerTeleport = 14,
    PlayerChangeWorld = 15,
    PlayerToggleSprint = 16,
    PlayerToggleSneak = 17,
    Chat = 18,
    PlayerFoodLoss = 19,
    PlayerHeal = 20,
    PlayerHurt = 21,
    PlayerDeath = 22,
    PlayerRespawn = 23,
    PlayerSkinChange = 24,
    PlayerFireExtinguish = 25,
    PlayerStartBreak = 26,
    PlayerBlockBreak = 27,
    PlayerBlockPlace = 28,
    PlayerBlockPick = 29,
    PlayerItemUse = 30,
    PlayerItemUseOnBlock = 31,
    PlayerItemUseOnEntity = 32,
    PlayerItemRelease = 33,
    PlayerItemConsume = 34,
    PlayerAttackEntity = 35,
    PlayerExperienceGain = 36,
    PlayerPunchAir = 37,
    PlayerSignEdit = 38,
    PlayerLecternPageTurn = 39,
    PlayerItemDamage = 40,
    PlayerItemPickup = 41,
    PlayerHeldSlotChange = 42,
    PlayerItemDrop = 43,
    PlayerTransfer = 44,
    Command = 45,
    PlayerDiagnostics = 46,
    WorldLiquidFlow = 70,
    WorldLiquidDecay = 71,
    WorldLiquidHarden = 72,
    WorldSound = 73,
    WorldFireSpread = 74,
    WorldBlockBurn = 75,
    WorldCropTrample = 76,
    WorldLeavesDecay = 77,
    WorldEntitySpawn = 78,
    WorldEntityDespawn = 79,
    WorldExplosion = 80,
    WorldClose = 81,
}
impl EventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EventType::Unspecified => "EVENT_TYPE_UNSPECIFIED",
            EventType::All => "EVENT_TYPE_ALL",
            EventType::PlayerJoin => "PLAYER_JOIN",
            EventType::PlayerQuit => "PLAYER_QUIT",
            EventType::PlayerMove => "PLAYER_MOVE",
            EventType::PlayerJump => "PLAYER_JUMP",
            EventType::PlayerTeleport => "PLAYER_TELEPORT",
            EventType::PlayerChangeWorld => "PLAYER_CHANGE_WORLD",
            EventType::PlayerToggleSprint => "PLAYER_TOGGLE_SPRINT",
            EventType::PlayerToggleSneak => "PLAYER_TOGGLE_SNEAK",
            EventType::Chat => "CHAT",
            EventType::PlayerFoodLoss => "PLAYER_FOOD_LOSS",
            EventType::PlayerHeal => "PLAYER_HEAL",
            EventType::PlayerHurt => "PLAYER_HURT",
            EventType::PlayerDeath => "PLAYER_DEATH",
            EventType::PlayerRespawn => "PLAYER_RESPAWN",
            EventType::PlayerSkinChange => "PLAYER_SKIN_CHANGE",
            EventType::PlayerFireExtinguish => "PLAYER_FIRE_EXTINGUISH",
            EventType::PlayerStartBreak => "PLAYER_START_BREAK",
            EventType::PlayerBlockBreak => "PLAYER_BLOCK_BREAK",
            EventType::PlayerBlockPlace => "PLAYER_BLOCK_PLACE",
            EventType::PlayerBlockPick => "PLAYER_BLOCK_PICK",
            EventType::PlayerItemUse => "PLAYER_ITEM_USE",
            EventType::PlayerItemUseOnBlock => "PLAYER_ITEM_USE_ON_BLOCK",
            EventType::PlayerItemUseOnEntity => "PLAYER_ITEM_USE_ON_ENTITY",
            EventType::PlayerItemRelease => "PLAYER_ITEM_RELEASE",
            EventType::PlayerItemConsume => "PLAYER_ITEM_CONSUME",
            EventType::PlayerAttackEntity => "PLAYER_ATTACK_ENTITY",
            EventType::PlayerExperienceGain => "PLAYER_EXPERIENCE_GAIN",
            EventType::PlayerPunchAir => "PLAYER_PUNCH_AIR",
            EventType::PlayerSignEdit => "PLAYER_SIGN_EDIT",
            EventType::PlayerLecternPageTurn => "PLAYER_LECTERN_PAGE_TURN",
            EventType::PlayerItemDamage => "PLAYER_ITEM_DAMAGE",
            EventType::PlayerItemPickup => "PLAYER_ITEM_PICKUP",
            EventType::PlayerHeldSlotChange => "PLAYER_HELD_SLOT_CHANGE",
            EventType::PlayerItemDrop => "PLAYER_ITEM_DROP",
            EventType::PlayerTransfer => "PLAYER_TRANSFER",
            EventType::Command => "COMMAND",
            EventType::PlayerDiagnostics => "PLAYER_DIAGNOSTICS",
            EventType::WorldLiquidFlow => "WORLD_LIQUID_FLOW",
            EventType::WorldLiquidDecay => "WORLD_LIQUID_DECAY",
            EventType::WorldLiquidHarden => "WORLD_LIQUID_HARDEN",
            EventType::WorldSound => "WORLD_SOUND",
            EventType::WorldFireSpread => "WORLD_FIRE_SPREAD",
            EventType::WorldBlockBurn => "WORLD_BLOCK_BURN",
            EventType::WorldCropTrample => "WORLD_CROP_TRAMPLE",
            EventType::WorldLeavesDecay => "WORLD_LEAVES_DECAY",
            EventType::WorldEntitySpawn => "WORLD_ENTITY_SPAWN",
            EventType::WorldEntityDespawn => "WORLD_ENTITY_DESPAWN",
            EventType::WorldExplosion => "WORLD_EXPLOSION",
            EventType::WorldClose => "WORLD_CLOSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "EVENT_TYPE_ALL" => Some(Self::All),
            "PLAYER_JOIN" => Some(Self::PlayerJoin),
            "PLAYER_QUIT" => Some(Self::PlayerQuit),
            "PLAYER_MOVE" => Some(Self::PlayerMove),
            "PLAYER_JUMP" => Some(Self::PlayerJump),
            "PLAYER_TELEPORT" => Some(Self::PlayerTeleport),
            "PLAYER_CHANGE_WORLD" => Some(Self::PlayerChangeWorld),
            "PLAYER_TOGGLE_SPRINT" => Some(Self::PlayerToggleSprint),
            "PLAYER_TOGGLE_SNEAK" => Some(Self::PlayerToggleSneak),
            "CHAT" => Some(Self::Chat),
            "PLAYER_FOOD_LOSS" => Some(Self::PlayerFoodLoss),
            "PLAYER_HEAL" => Some(Self::PlayerHeal),
            "PLAYER_HURT" => Some(Self::PlayerHurt),
            "PLAYER_DEATH" => Some(Self::PlayerDeath),
            "PLAYER_RESPAWN" => Some(Self::PlayerRespawn),
            "PLAYER_SKIN_CHANGE" => Some(Self::PlayerSkinChange),
            "PLAYER_FIRE_EXTINGUISH" => Some(Self::PlayerFireExtinguish),
            "PLAYER_START_BREAK" => Some(Self::PlayerStartBreak),
            "PLAYER_BLOCK_BREAK" => Some(Self::PlayerBlockBreak),
            "PLAYER_BLOCK_PLACE" => Some(Self::PlayerBlockPlace),
            "PLAYER_BLOCK_PICK" => Some(Self::PlayerBlockPick),
            "PLAYER_ITEM_USE" => Some(Self::PlayerItemUse),
            "PLAYER_ITEM_USE_ON_BLOCK" => Some(Self::PlayerItemUseOnBlock),
            "PLAYER_ITEM_USE_ON_ENTITY" => Some(Self::PlayerItemUseOnEntity),
            "PLAYER_ITEM_RELEASE" => Some(Self::PlayerItemRelease),
            "PLAYER_ITEM_CONSUME" => Some(Self::PlayerItemConsume),
            "PLAYER_ATTACK_ENTITY" => Some(Self::PlayerAttackEntity),
            "PLAYER_EXPERIENCE_GAIN" => Some(Self::PlayerExperienceGain),
            "PLAYER_PUNCH_AIR" => Some(Self::PlayerPunchAir),
            "PLAYER_SIGN_EDIT" => Some(Self::PlayerSignEdit),
            "PLAYER_LECTERN_PAGE_TURN" => Some(Self::PlayerLecternPageTurn),
            "PLAYER_ITEM_DAMAGE" => Some(Self::PlayerItemDamage),
            "PLAYER_ITEM_PICKUP" => Some(Self::PlayerItemPickup),
            "PLAYER_HELD_SLOT_CHANGE" => Some(Self::PlayerHeldSlotChange),
            "PLAYER_ITEM_DROP" => Some(Self::PlayerItemDrop),
            "PLAYER_TRANSFER" => Some(Self::PlayerTransfer),
            "COMMAND" => Some(Self::Command),
            "PLAYER_DIAGNOSTICS" => Some(Self::PlayerDiagnostics),
            "WORLD_LIQUID_FLOW" => Some(Self::WorldLiquidFlow),
            "WORLD_LIQUID_DECAY" => Some(Self::WorldLiquidDecay),
            "WORLD_LIQUID_HARDEN" => Some(Self::WorldLiquidHarden),
            "WORLD_SOUND" => Some(Self::WorldSound),
            "WORLD_FIRE_SPREAD" => Some(Self::WorldFireSpread),
            "WORLD_BLOCK_BURN" => Some(Self::WorldBlockBurn),
            "WORLD_CROP_TRAMPLE" => Some(Self::WorldCropTrample),
            "WORLD_LEAVES_DECAY" => Some(Self::WorldLeavesDecay),
            "WORLD_ENTITY_SPAWN" => Some(Self::WorldEntitySpawn),
            "WORLD_ENTITY_DESPAWN" => Some(Self::WorldEntityDespawn),
            "WORLD_EXPLOSION" => Some(Self::WorldExplosion),
            "WORLD_CLOSE" => Some(Self::WorldClose),
            _ => None,
        }
    }
}
include!("df.plugin.tonic.rs");
// @@protoc_insertion_point(module)