use anyhow::Result;
use quote::{format_ident, quote};
use std::{collections::HashMap, path::PathBuf};
use syn::{File, Ident, ItemStruct};

use crate::utils::{
    clean_type, find_nested_enum, generate_conversion_code, get_variant_type_path,
    unwrap_option_path, write_formatted_file,
};

pub(crate) fn generate_event_mutations(
    ast: &File,
    all_structs: &HashMap<Ident, &ItemStruct>,
    output_path: &PathBuf,
) -> Result<()> {
    let mutation_enum = find_nested_enum(ast, "event_result", "Update")?;
    let event_payload_enum = find_nested_enum(ast, "event_envelope", "Payload")?;
    let mut mutation_impls = Vec::new();

    for variant in &mutation_enum.variants {
        let mutation_variant_name = &variant.ident;
        let mutation_struct_path = get_variant_type_path(variant)?;
        let mutation_struct_name = mutation_struct_path.segments.last().unwrap().ident.clone();

        let event_variant = event_payload_enum
            .variants
            .iter()
            .find(|v| v.ident == *mutation_variant_name)
            .ok_or_else(|| {
                anyhow::anyhow!("No event payload for mutation {}", mutation_variant_name)
            })?;
        let event_struct_path = get_variant_type_path(event_variant)?;
        let event_struct_name = event_struct_path.segments.last().unwrap().ident.clone();

        // Find mutation struct definition
        let mutation_struct_def = all_structs.get(&mutation_struct_name).ok_or_else(|| {
            anyhow::anyhow!("Struct definition not found for {}", mutation_struct_name)
        })?;

        let mut helper_methods = Vec::new();
        for field in &mutation_struct_def.fields {
            let field_name = field.ident.as_ref().unwrap();
            let (inner_type, is_option) = unwrap_option_path(&field.ty);

            if !is_option {
                continue;
            }

            let arg_type = clean_type(inner_type);
            let setter_fn_name = format_ident!("set_{}", field_name);
            let doc_string = format!("Sets the `{}` for this event.", field_name);

            let convert_code = generate_conversion_code(&quote! { #field_name }, inner_type);

            helper_methods.push(quote! {
                #[doc = #doc_string]
                pub fn #setter_fn_name(&mut self, #field_name: #arg_type) {
                    let mutation = types::#mutation_struct_name {
                        #field_name: Some(#convert_code),
                        ..Default::default()
                    };
                    self.set_mutation(types::EventResultUpdate::#mutation_variant_name(mutation));
                }
            });
        }

        mutation_impls.push(quote! {
            impl<'a> EventContext<'a, types::#event_struct_name> {
                #( #helper_methods )*
            }
        });
    }

    let final_file = quote! {
        // This file is auto-generated by `xtask`. Do not edit manually.
        use crate::types;
        use crate::event::EventContext;

        #( #mutation_impls )*
    };

    write_formatted_file(output_path, final_file.to_string())
}
