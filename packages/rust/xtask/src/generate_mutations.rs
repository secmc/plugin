//! Generate mutation helpers on `EventContext` for event updates.
//!
//! This module inspects the prost-generated `event_result::Update` enum and
//! corresponding mutation structs and generates setter-style helper methods
//! on `EventContext<T>` (e.g. `set_message`, `set_damage`). The resulting
//! code is written to `src/event/mutations.rs` and used directly by plugin
//! authors when mutating events.

use anyhow::Result;
use quote::{format_ident, quote};
use std::{collections::HashMap, path::PathBuf};
use syn::{File, Ident, ItemStruct};

use crate::utils::{find_nested_enum, get_api_type, get_variant_type_path, prettify_code};

/// Generate mutation helper methods on `EventContext` for each
/// `event_result::Update` variant in the prost-generated API.
pub(crate) fn generate_event_mutations(
    ast: &File,
    all_structs: &HashMap<Ident, &ItemStruct>,
    output_path: &PathBuf,
) -> Result<()> {
    let code = generate_event_mutations_tokens(ast, all_structs)?;

    let file = prettify_code(code)?;

    std::fs::write(output_path, file)?;

    Ok(())
}

fn generate_event_mutations_tokens(
    ast: &File,
    all_structs: &HashMap<Ident, &ItemStruct>,
) -> Result<String> {
    let mutation_enum = find_nested_enum(ast, "event_result", "Update")?;
    let event_payload_enum = find_nested_enum(ast, "event_envelope", "Payload")?;
    let mut mutation_impls = Vec::new();

    for variant in &mutation_enum.variants {
        let mutation_variant_name = &variant.ident;
        let mutation_struct_path = get_variant_type_path(variant)?;
        let mutation_struct_name = mutation_struct_path.segments.last().unwrap().ident.clone();

        let event_variant = event_payload_enum
            .variants
            .iter()
            .find(|v| v.ident == *mutation_variant_name)
            .ok_or_else(|| {
                anyhow::anyhow!("No event payload for mutation {}", mutation_variant_name)
            })?;
        let event_struct_path = get_variant_type_path(event_variant)?;
        let event_struct_name = event_struct_path.segments.last().unwrap().ident.clone();

        // Find mutation struct definition
        let mutation_struct_def = all_structs.get(&mutation_struct_name).ok_or_else(|| {
            anyhow::anyhow!("Struct definition not found for {}", mutation_struct_name)
        })?;

        let mut helper_methods = Vec::new();
        helper_methods.push(quote! {
            fn ensure_mutation_exists(&mut self) {
                if !matches!(self.result, EventResult::Mutated(types::EventResultUpdate::#mutation_variant_name(_))) {
                    self.result = EventResult::Mutated(
                        types::EventResultUpdate::#mutation_variant_name(types::#mutation_struct_name::default())
                    );
                }
            }
        });

        for field in &mutation_struct_def.fields {
            let field_name = field.ident.as_ref().unwrap();
            let arg_type = get_api_type(field);
            let setter_fn_name = format_ident!("set_{}", field_name);
            let doc_string = format!("Sets the `{}` for this event.", field_name);

            helper_methods.push(quote! {
                #[doc = #doc_string]
                pub fn #setter_fn_name(&mut self, #field_name: #arg_type) -> &mut Self {
                    self.ensure_mutation_exists();

                    if let EventResult::Mutated(types::EventResultUpdate::#mutation_variant_name(ref mut m)) = self.result {
                        m.#field_name = #field_name.into()
                    };
                    self
                }
            });
        }

        mutation_impls.push(quote! {
            impl<'a> EventContext<'a, types::#event_struct_name> {
                #( #helper_methods )*
            }
        });
    }

    Ok(quote! {
        //! This file is auto-generated by `xtask`. Do not edit manually.
        #![allow(clippy::all)]
        use crate::types;
        use crate::event::{EventContext, EventResult};

        #( #mutation_impls )*
    }
    .to_string())
}

#[cfg(test)]
mod tests {
    use crate::utils::find_all_structs;

    use super::*; // Import your generator functions
    use syn::{parse_file, File};

    fn setup_test_ast() -> File {
        let mock_code = include_str!("../assets/mock_prost.rs");

        parse_file(mock_code).expect("Failed to parse mock AST")
    }

    #[test]
    fn snapshot_test_generate_event_mutations() {
        let ast = setup_test_ast();

        let all_structs = find_all_structs(&ast);

        let generated_code =
            generate_event_mutations_tokens(&ast, &all_structs).expect("Generator function failed");

        let prettified_code = prettify_code(generated_code).expect("Invalid code being produced.");

        insta::assert_snapshot!("event_mutations", prettified_code);
    }

    #[test]
    fn generate_event_mutations_errors_when_payload_missing() {
        // Mutation has a variant with no corresponding payload variant.
        let code = r#"
            mod event_result {
                pub enum Update {
                    Chat(ChatMutation),
                }
            }
            mod event_envelope {
                pub enum Payload {
                    // Intentionally do not include Chat here.
                }
            }
            pub struct ChatMutation {
                pub message: ::prost::alloc::string::String,
            }
        "#;
        let ast: File = parse_file(code).expect("Failed to parse test AST");
        let all_structs = find_all_structs(&ast);

        let err = generate_event_mutations_tokens(&ast, &all_structs).unwrap_err();
        let msg = err.to_string();
        assert!(msg.contains("No event payload for mutation Chat"));
    }
}
