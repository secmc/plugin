---
source: xtask/src/generate_handlers.rs
expression: prettified_code
---
//! This file is auto-generated by `xtask`. Do not edit manually.
#![allow(async_fn_in_trait)]
use crate::{
    event::EventContext, types, Server, EventSubscriptions, command::CommandRegistry,
};
pub trait EventHandler: EventSubscriptions + Send + Sync {
    ///Handler for the `Chat` event.
    async fn on_chat(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::ChatEvent>,
    ) {}
    ///Handler for the `BlockBreak` event.
    async fn on_block_break(
        &self,
        _server: &Server,
        _event: &mut EventContext<'_, types::BlockBreakEvent>,
    ) {}
}
#[doc(hidden)]
pub async fn dispatch_event(
    server: &Server,
    handler: &(impl EventHandler + CommandRegistry),
    envelope: &types::EventEnvelope,
) {
    let Some(payload) = &envelope.payload else {
        return;
    };
    match payload {
        types::event_envelope::Payload::Chat(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_chat(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
        types::event_envelope::Payload::BlockBreak(e) => {
            let mut context = EventContext::new(
                &envelope.event_id,
                e,
                server.sender.clone(),
                server.plugin_id.clone(),
            );
            handler.on_block_break(server, &mut context).await;
            context.send_ack_if_needed().await;
        }
    }
}
