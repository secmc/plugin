//! Generate `Server` helper methods for each `action::Kind` variant.
//!
//! This module inspects the prost-generated `action::Kind` enum from
//! `df.plugin.rs` and produces a single `impl Server { ... }` block in
//! `src/server/helpers.rs`. Each action variant gets a corresponding async
//! helper method that takes ergonomic parameters and forwards them into the
//! raw `types::Action` wire format.

use anyhow::Result;
use heck::ToSnakeCase;
use quote::{format_ident, quote};
use std::{collections::HashMap, path::PathBuf};
use syn::{File, Ident, ItemStruct};

use crate::utils::{
    find_nested_enum, get_action_conversion_logic, get_api_type, get_variant_type_path,
    prettify_code, ConversionLogic,
};

/// Generate the `impl Server { .. }` block with one helper per `action::Kind`
/// variant in the prost-generated API.
pub(crate) fn generate_server_helpers(
    ast: &File,
    all_structs: &HashMap<Ident, &ItemStruct>,
    output_path: &PathBuf,
) -> Result<()> {
    let code = generate_server_helpers_tokens(ast, all_structs)?;

    let file = prettify_code(code)?;

    std::fs::write(output_path, file)?;

    Ok(())
}

fn generate_server_helpers_tokens(
    ast: &File,
    all_structs: &HashMap<Ident, &ItemStruct>,
) -> Result<String> {
    let action_kind_enum = find_nested_enum(ast, "action", "Kind")?;
    let mut server_helpers = Vec::new();

    for variant in &action_kind_enum.variants {
        let variant_ident = &variant.ident;
        let action_struct_path = get_variant_type_path(variant)?;
        let action_struct_name = action_struct_path.segments.last().unwrap().ident.clone();
        let fn_name = format_ident!("{}", variant_ident.to_string().to_snake_case());
        let doc_string = format!("Sends a `{}` action to the server.", variant_ident);

        // Find the struct definition
        let action_struct_def = all_structs.get(&action_struct_name).ok_or_else(|| {
            anyhow::anyhow!("Struct definition not found for {}", action_struct_name)
        })?;

        let mut fn_args = Vec::new();
        let mut struct_fields = Vec::new();

        for field in &action_struct_def.fields {
            let field_name = field.ident.as_ref().unwrap();
            let arg_type = get_api_type(field);
            let conversion_logic = get_action_conversion_logic(field);

            let struct_field_code = match conversion_logic {
                ConversionLogic::Direct => {
                    quote! { #field_name }
                }
                // It's an enum or Option. Use the explicit conversion
                ConversionLogic::Into => {
                    quote! { #field_name: #field_name.into() }
                }
                ConversionLogic::OptionInnerInto => {
                    quote! { #field_name: #field_name.into().map(|x| x.into()) }
                }
            };

            fn_args.push(quote! { #field_name: #arg_type });
            struct_fields.push(quote! { #struct_field_code });
        }

        server_helpers.push(quote! {
            #[doc = #doc_string]
            pub async fn #fn_name(
                &self,
                #( #fn_args ),*
            ) -> Result<(), mpsc::error::SendError<types::PluginToHost>> {
                self.send_action(types::action::Kind::#variant_ident(
                    types::#action_struct_name {
                        #( #struct_fields ),*
                    }
                )).await
            }
        });
    }

    Ok(quote! {
        //! This file is auto-generated by `xtask`. Do not edit manually.
        use crate::{types, Server};
        use tokio::sync::mpsc;

        impl Server {
            #( #server_helpers )*
        }
    }
    .to_string())
}

#[cfg(test)]
mod tests {
    use crate::utils::find_all_structs;

    use super::*; // Import your generator functions
    use syn::{parse_file, File};

    fn setup_test_ast() -> File {
        let mock_code = include_str!("../assets/mock_prost.rs");

        parse_file(mock_code).expect("Failed to parse mock AST")
    }

    #[test]
    fn snapshot_test_generate_server_actions() {
        let ast = setup_test_ast();

        let all_structs = find_all_structs(&ast);

        let generated_code =
            generate_server_helpers_tokens(&ast, &all_structs).expect("Generator function failed");

        let prettified_code = prettify_code(generated_code).expect("Invalid code being produced.");

        insta::assert_snapshot!("server_actions", prettified_code);
    }

    #[test]
    fn generate_server_helpers_fails_when_struct_missing() {
        // Create a tiny AST with an action::Kind enum referring to a non-existent struct.
        let code = r#"
            mod action {
                pub enum Kind {
                    Missing(MissingAction),
                }
            }
        "#;
        let ast: File = parse_file(code).expect("Failed to parse test AST");
        let all_structs = find_all_structs(&ast);

        let err = generate_server_helpers_tokens(&ast, &all_structs).unwrap_err();
        let msg = err.to_string();
        assert!(msg.contains("Struct definition not found for MissingAction"));
    }
}
