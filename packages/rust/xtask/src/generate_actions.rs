use anyhow::Result;
use heck::ToSnakeCase;
use quote::{format_ident, quote};
use std::{collections::HashMap, path::PathBuf};
use syn::{File, Ident, ItemStruct};

use crate::utils::{
    clean_type, find_nested_enum, get_variant_type_path, unwrap_option_path, write_formatted_file,
};

pub(crate) fn generate_server_helpers(
    ast: &File,
    all_structs: &HashMap<Ident, &ItemStruct>,
    output_path: &PathBuf,
) -> Result<()> {
    let action_kind_enum = find_nested_enum(ast, "action", "Kind")?;
    let mut server_helpers = Vec::new();

    for variant in &action_kind_enum.variants {
        let variant_ident = &variant.ident;
        let action_struct_path = get_variant_type_path(variant)?;
        let action_struct_name = action_struct_path.segments.last().unwrap().ident.clone();
        let fn_name = format_ident!("{}", variant_ident.to_string().to_snake_case());
        let doc_string = format!("Sends a `{}` action to the server.", variant_ident);

        // Find the struct definition
        let action_struct_def = all_structs.get(&action_struct_name).ok_or_else(|| {
            anyhow::anyhow!("Struct definition not found for {}", action_struct_name)
        })?;

        let mut fn_args = Vec::new();
        let mut struct_fields = Vec::new();

        for field in &action_struct_def.fields {
            let field_name = field.ident.as_ref().unwrap();
            let (_inner_type, is_option) = unwrap_option_path(&field.ty);
            let arg_type = clean_type(&field.ty);

            if is_option {
                // If it's an Option, we must map the inner value
                struct_fields.push(quote! { #field_name: #field_name.map(|v| v.into()) });
            } else {
                // If it's not an Option, we can call .into() directly
                struct_fields.push(quote! { #field_name: #field_name.into() });
            }

            fn_args.push(quote! { #field_name: #arg_type });
        }

        server_helpers.push(quote! {
            #[doc = #doc_string]
            pub async fn #fn_name(
                &self,
                #( #fn_args ),*
            ) -> Result<(), mpsc::error::SendError<types::PluginToHost>> {
                self.send_action(types::action::Kind::#variant_ident(
                    types::#action_struct_name {
                        #( #struct_fields ),*
                    }
                )).await
            }
        });
    }

    let final_file = quote! {
        // This file is auto-generated by `xtask`. Do not edit manually.
        use crate::{types, Server};
        use tokio::sync::mpsc;

        impl Server {
            #( #server_helpers )*
        }
    };

    write_formatted_file(output_path, final_file.to_string())
}
