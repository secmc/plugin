use dragonfly_plugin::{
    Plugin,
    PluginSubscriptions,
    Server,
    async_trait,
    event::{EventContext, PluginEventHandler},
    types, // All the raw prost/tonic types
};
use rust_plugin_macro::bedrock_plugin;

// --- 2. Define a struct for your plugin's state ---
// It can be empty, or it can hold databases, configs, etc.
// We add `Default` so it's easy to create.
#[derive(Default)]
struct MyExamplePlugin;

// --- 3. Implement the event handlers ---
//
// * We add `#[bedrock_plugin]` to this block.
//   This macro will scan for every `on_...` function we implement
//   and automatically generate the `impl PluginSubscriptions` for us.
//

#[async_trait]
#[bedrock_plugin]
impl PluginEventHandler for MyExamplePlugin {
    /// This handler runs when a player joins the server.
    /// We'll use it to send our "hello world" message.
    async fn on_player_join(
        &self,
        server: &Server,
        event: &mut EventContext<types::PlayerJoinEvent>,
    ) {
        // Log to the plugin's console
        println!("Player '{}' has joined the server.", event.data.name);

        // We assume `send_chat` was generated by `xtask` from a `SendChatAction`.
        let welcome_message = format!(
            "Welcome, {}! This server is running MyExamplePlugin.",
            event.data.name
        );

        // We call the auto-generated `server.send_chat` helper.
        // `.await.ok()` sends the message and ignores any potential
        // (but rare) connection errors.
        server
            .send_chat(event.data.player_uuid.clone(), welcome_message)
            .await
            .ok();
    }

    /// This handler runs every time a player sends a chat message.
    /// We'll use it to edit the message.
    async fn on_chat(
        &self,
        _server: &Server, // We don't need the server handle for this
        event: &mut EventContext<types::ChatEvent>,
    ) {
        // Get the original message from the event's data
        let original_message = &event.data.message;

        // Create the new message
        let new_message = format!("[Plugin] {}", original_message);

        // Use the auto-generated `set_message` helper to
        // mutate the event before the server processes it.
        event.set_message(new_message);
    }

    // We don't implement `on_player_hurt`, `on_block_break`, etc.,
    // so the `#[bedrock_plugin]` macro will not subscribe to them.
}

// --- 4. The main function to run the plugin ---
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. Define the plugin's metadata
    let plugin = Plugin::new(
        "example-rust",        // A unique ID for your plugin (matches plugins.yaml)
        "Example Rust Plugin", // A human-readable name
        "1.0.0",               // Your plugin's version
        "1.0.0",               // The API version you're built against
    );

    // 2. Connect to the server and run the plugin
    println!("Connecting to Bedrock server...");

    plugin
        .run(
            MyExamplePlugin,         // Pass in an instance of our handler
            "tcp://127.0.0.1:50050", // The server address (Unix socket)
        )
        .await
}
