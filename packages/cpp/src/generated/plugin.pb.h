// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: plugin.proto
// Protobuf C++ Version: 6.33.1

#ifndef plugin_2eproto_2epb_2eh
#define plugin_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "player_events.pb.h"
#include "world_events.pb.h"
#include "command.pb.h"
#include "actions.pb.h"
#include "mutations.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_plugin_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_plugin_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_plugin_2eproto;
}  // extern "C"
namespace df {
namespace plugin {
enum EventType : int;
extern const uint32_t EventType_internal_data_[];
class EventEnvelope;
struct EventEnvelopeDefaultTypeInternal;
extern EventEnvelopeDefaultTypeInternal _EventEnvelope_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EventEnvelope_class_data_;
class EventSubscribe;
struct EventSubscribeDefaultTypeInternal;
extern EventSubscribeDefaultTypeInternal _EventSubscribe_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EventSubscribe_class_data_;
class HostHello;
struct HostHelloDefaultTypeInternal;
extern HostHelloDefaultTypeInternal _HostHello_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HostHello_class_data_;
class HostShutdown;
struct HostShutdownDefaultTypeInternal;
extern HostShutdownDefaultTypeInternal _HostShutdown_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HostShutdown_class_data_;
class HostToPlugin;
struct HostToPluginDefaultTypeInternal;
extern HostToPluginDefaultTypeInternal _HostToPlugin_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HostToPlugin_class_data_;
class LogMessage;
struct LogMessageDefaultTypeInternal;
extern LogMessageDefaultTypeInternal _LogMessage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LogMessage_class_data_;
class PluginHello;
struct PluginHelloDefaultTypeInternal;
extern PluginHelloDefaultTypeInternal _PluginHello_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PluginHello_class_data_;
class PluginToHost;
struct PluginToHostDefaultTypeInternal;
extern PluginToHostDefaultTypeInternal _PluginToHost_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PluginToHost_class_data_;
class ServerInformationRequest;
struct ServerInformationRequestDefaultTypeInternal;
extern ServerInformationRequestDefaultTypeInternal _ServerInformationRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ServerInformationRequest_class_data_;
class ServerInformationResponse;
struct ServerInformationResponseDefaultTypeInternal;
extern ServerInformationResponseDefaultTypeInternal _ServerInformationResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ServerInformationResponse_class_data_;
}  // namespace plugin
}  // namespace df
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::df::plugin::EventType_internal_data_>
    internal::EnumTraitsImpl::value<::df::plugin::EventType>;
}  // namespace protobuf
}  // namespace google

namespace df {
namespace plugin {
enum EventType : int {
  EVENT_TYPE_UNSPECIFIED = 0,
  EVENT_TYPE_ALL = 1,
  PLAYER_JOIN = 10,
  PLAYER_QUIT = 11,
  PLAYER_MOVE = 12,
  PLAYER_JUMP = 13,
  PLAYER_TELEPORT = 14,
  PLAYER_CHANGE_WORLD = 15,
  PLAYER_TOGGLE_SPRINT = 16,
  PLAYER_TOGGLE_SNEAK = 17,
  CHAT = 18,
  PLAYER_FOOD_LOSS = 19,
  PLAYER_HEAL = 20,
  PLAYER_HURT = 21,
  PLAYER_DEATH = 22,
  PLAYER_RESPAWN = 23,
  PLAYER_SKIN_CHANGE = 24,
  PLAYER_FIRE_EXTINGUISH = 25,
  PLAYER_START_BREAK = 26,
  PLAYER_BLOCK_BREAK = 27,
  PLAYER_BLOCK_PLACE = 28,
  PLAYER_BLOCK_PICK = 29,
  PLAYER_ITEM_USE = 30,
  PLAYER_ITEM_USE_ON_BLOCK = 31,
  PLAYER_ITEM_USE_ON_ENTITY = 32,
  PLAYER_ITEM_RELEASE = 33,
  PLAYER_ITEM_CONSUME = 34,
  PLAYER_ATTACK_ENTITY = 35,
  PLAYER_EXPERIENCE_GAIN = 36,
  PLAYER_PUNCH_AIR = 37,
  PLAYER_SIGN_EDIT = 38,
  PLAYER_LECTERN_PAGE_TURN = 39,
  PLAYER_ITEM_DAMAGE = 40,
  PLAYER_ITEM_PICKUP = 41,
  PLAYER_HELD_SLOT_CHANGE = 42,
  PLAYER_ITEM_DROP = 43,
  PLAYER_TRANSFER = 44,
  COMMAND = 45,
  PLAYER_DIAGNOSTICS = 46,
  WORLD_LIQUID_FLOW = 70,
  WORLD_LIQUID_DECAY = 71,
  WORLD_LIQUID_HARDEN = 72,
  WORLD_SOUND = 73,
  WORLD_FIRE_SPREAD = 74,
  WORLD_BLOCK_BURN = 75,
  WORLD_CROP_TRAMPLE = 76,
  WORLD_LEAVES_DECAY = 77,
  WORLD_ENTITY_SPAWN = 78,
  WORLD_ENTITY_DESPAWN = 79,
  WORLD_EXPLOSION = 80,
  WORLD_CLOSE = 81,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EventType_internal_data_[];
inline constexpr EventType EventType_MIN =
    static_cast<EventType>(0);
inline constexpr EventType EventType_MAX =
    static_cast<EventType>(81);
inline bool EventType_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, EventType_internal_data_);
}
inline constexpr int EventType_ARRAYSIZE = 81 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EventType_descriptor();
template <typename T>
const ::std::string& EventType_Name(T value) {
  static_assert(::std::is_same<T, EventType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return EventType_Name(static_cast<EventType>(value));
}
template <>
inline const ::std::string& EventType_Name(EventType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EventType_descriptor, 0, 81>(
      static_cast<int>(value));
}
inline bool EventType_Parse(
    ::absl::string_view name, EventType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventType>(EventType_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class ServerInformationResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.ServerInformationResponse) */ {
 public:
  inline ServerInformationResponse() : ServerInformationResponse(nullptr) {}
  ~ServerInformationResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ServerInformationResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ServerInformationResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerInformationResponse(::google::protobuf::internal::ConstantInitialized);

  inline ServerInformationResponse(const ServerInformationResponse& from) : ServerInformationResponse(nullptr, from) {}
  inline ServerInformationResponse(ServerInformationResponse&& from) noexcept
      : ServerInformationResponse(nullptr, ::std::move(from)) {}
  inline ServerInformationResponse& operator=(const ServerInformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInformationResponse& operator=(ServerInformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInformationResponse& default_instance() {
    return *reinterpret_cast<const ServerInformationResponse*>(
        &_ServerInformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ServerInformationResponse& a, ServerInformationResponse& b) { a.Swap(&b); }
  inline void Swap(ServerInformationResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInformationResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerInformationResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ServerInformationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerInformationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServerInformationResponse& from) { ServerInformationResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ServerInformationResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.ServerInformationResponse"; }

  explicit ServerInformationResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ServerInformationResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ServerInformationResponse& from);
  ServerInformationResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ServerInformationResponse&& from) noexcept
      : ServerInformationResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPluginsFieldNumber = 1,
  };
  // repeated string plugins = 1 [json_name = "plugins"];
  int plugins_size() const;
  private:
  int _internal_plugins_size() const;

  public:
  void clear_plugins() ;
  const ::std::string& plugins(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_plugins(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_plugins(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_plugins();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_plugins(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& plugins() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_plugins();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_plugins() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_plugins();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.ServerInformationResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ServerInformationResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> plugins_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plugin_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ServerInformationResponse_class_data_;
// -------------------------------------------------------------------

class ServerInformationRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:df.plugin.ServerInformationRequest) */ {
 public:
  inline ServerInformationRequest() : ServerInformationRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ServerInformationRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ServerInformationRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerInformationRequest(::google::protobuf::internal::ConstantInitialized);

  inline ServerInformationRequest(const ServerInformationRequest& from) : ServerInformationRequest(nullptr, from) {}
  inline ServerInformationRequest(ServerInformationRequest&& from) noexcept
      : ServerInformationRequest(nullptr, ::std::move(from)) {}
  inline ServerInformationRequest& operator=(const ServerInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInformationRequest& operator=(ServerInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInformationRequest& default_instance() {
    return *reinterpret_cast<const ServerInformationRequest*>(
        &_ServerInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ServerInformationRequest& a, ServerInformationRequest& b) { a.Swap(&b); }
  inline void Swap(ServerInformationRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInformationRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerInformationRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ServerInformationRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ServerInformationRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ServerInformationRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.ServerInformationRequest"; }

  explicit ServerInformationRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ServerInformationRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ServerInformationRequest& from);
  ServerInformationRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ServerInformationRequest&& from) noexcept
      : ServerInformationRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:df.plugin.ServerInformationRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_plugin_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ServerInformationRequest_class_data_;
// -------------------------------------------------------------------

class LogMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.LogMessage) */ {
 public:
  inline LogMessage() : LogMessage(nullptr) {}
  ~LogMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LogMessage* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LogMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LogMessage(::google::protobuf::internal::ConstantInitialized);

  inline LogMessage(const LogMessage& from) : LogMessage(nullptr, from) {}
  inline LogMessage(LogMessage&& from) noexcept
      : LogMessage(nullptr, ::std::move(from)) {}
  inline LogMessage& operator=(const LogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogMessage& operator=(LogMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogMessage& default_instance() {
    return *reinterpret_cast<const LogMessage*>(
        &_LogMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(LogMessage& a, LogMessage& b) { a.Swap(&b); }
  inline void Swap(LogMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogMessage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LogMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LogMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LogMessage& from) { LogMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LogMessage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.LogMessage"; }

  explicit LogMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LogMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LogMessage& from);
  LogMessage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LogMessage&& from) noexcept
      : LogMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLevelFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string level = 1 [json_name = "level"];
  void clear_level() ;
  const ::std::string& level() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_level(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_level();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_level();
  void set_allocated_level(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_level() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_level(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_level();

  public:
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.LogMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LogMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr level_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plugin_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LogMessage_class_data_;
// -------------------------------------------------------------------

class HostShutdown final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.HostShutdown) */ {
 public:
  inline HostShutdown() : HostShutdown(nullptr) {}
  ~HostShutdown() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HostShutdown* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HostShutdown));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HostShutdown(::google::protobuf::internal::ConstantInitialized);

  inline HostShutdown(const HostShutdown& from) : HostShutdown(nullptr, from) {}
  inline HostShutdown(HostShutdown&& from) noexcept
      : HostShutdown(nullptr, ::std::move(from)) {}
  inline HostShutdown& operator=(const HostShutdown& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostShutdown& operator=(HostShutdown&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostShutdown& default_instance() {
    return *reinterpret_cast<const HostShutdown*>(
        &_HostShutdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(HostShutdown& a, HostShutdown& b) { a.Swap(&b); }
  inline void Swap(HostShutdown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostShutdown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostShutdown* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HostShutdown>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HostShutdown& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HostShutdown& from) { HostShutdown::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HostShutdown* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.HostShutdown"; }

  explicit HostShutdown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HostShutdown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HostShutdown& from);
  HostShutdown(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HostShutdown&& from) noexcept
      : HostShutdown(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 1,
  };
  // string reason = 1 [json_name = "reason"];
  void clear_reason() ;
  const ::std::string& reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_reason();
  void set_allocated_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_reason();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.HostShutdown)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 37,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HostShutdown& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plugin_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HostShutdown_class_data_;
// -------------------------------------------------------------------

class HostHello final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.HostHello) */ {
 public:
  inline HostHello() : HostHello(nullptr) {}
  ~HostHello() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HostHello* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HostHello));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HostHello(::google::protobuf::internal::ConstantInitialized);

  inline HostHello(const HostHello& from) : HostHello(nullptr, from) {}
  inline HostHello(HostHello&& from) noexcept
      : HostHello(nullptr, ::std::move(from)) {}
  inline HostHello& operator=(const HostHello& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostHello& operator=(HostHello&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostHello& default_instance() {
    return *reinterpret_cast<const HostHello*>(
        &_HostHello_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(HostHello& a, HostHello& b) { a.Swap(&b); }
  inline void Swap(HostHello* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostHello* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostHello* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HostHello>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HostHello& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HostHello& from) { HostHello::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HostHello* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.HostHello"; }

  explicit HostHello(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HostHello(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HostHello& from);
  HostHello(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HostHello&& from) noexcept
      : HostHello(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kApiVersionFieldNumber = 1,
  };
  // string api_version = 1 [json_name = "apiVersion"];
  void clear_api_version() ;
  const ::std::string& api_version() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_api_version(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_api_version();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_api_version();
  void set_allocated_api_version(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_api_version() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_api_version(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_api_version();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.HostHello)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 39,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HostHello& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr api_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plugin_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HostHello_class_data_;
// -------------------------------------------------------------------

class EventSubscribe final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.EventSubscribe) */ {
 public:
  inline EventSubscribe() : EventSubscribe(nullptr) {}
  ~EventSubscribe() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EventSubscribe* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EventSubscribe));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EventSubscribe(::google::protobuf::internal::ConstantInitialized);

  inline EventSubscribe(const EventSubscribe& from) : EventSubscribe(nullptr, from) {}
  inline EventSubscribe(EventSubscribe&& from) noexcept
      : EventSubscribe(nullptr, ::std::move(from)) {}
  inline EventSubscribe& operator=(const EventSubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventSubscribe& operator=(EventSubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventSubscribe& default_instance() {
    return *reinterpret_cast<const EventSubscribe*>(
        &_EventSubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(EventSubscribe& a, EventSubscribe& b) { a.Swap(&b); }
  inline void Swap(EventSubscribe* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventSubscribe* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventSubscribe* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EventSubscribe>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventSubscribe& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EventSubscribe& from) { EventSubscribe::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EventSubscribe* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.EventSubscribe"; }

  explicit EventSubscribe(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EventSubscribe(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EventSubscribe& from);
  EventSubscribe(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EventSubscribe&& from) noexcept
      : EventSubscribe(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventsFieldNumber = 1,
  };
  // repeated .df.plugin.EventType events = 1 [json_name = "events"];
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  public:
  ::df::plugin::EventType events(int index) const;
  void set_events(int index, ::df::plugin::EventType value);
  void add_events(::df::plugin::EventType value);
  const ::google::protobuf::RepeatedField<int>& events() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_events();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_events() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_events();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.EventSubscribe)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EventSubscribe& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> events_;
    ::google::protobuf::internal::CachedSize _events_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plugin_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EventSubscribe_class_data_;
// -------------------------------------------------------------------

class PluginHello final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PluginHello) */ {
 public:
  inline PluginHello() : PluginHello(nullptr) {}
  ~PluginHello() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PluginHello* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PluginHello));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PluginHello(::google::protobuf::internal::ConstantInitialized);

  inline PluginHello(const PluginHello& from) : PluginHello(nullptr, from) {}
  inline PluginHello(PluginHello&& from) noexcept
      : PluginHello(nullptr, ::std::move(from)) {}
  inline PluginHello& operator=(const PluginHello& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginHello& operator=(PluginHello&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginHello& default_instance() {
    return *reinterpret_cast<const PluginHello*>(
        &_PluginHello_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(PluginHello& a, PluginHello& b) { a.Swap(&b); }
  inline void Swap(PluginHello* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginHello* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginHello* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PluginHello>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PluginHello& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PluginHello& from) { PluginHello::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PluginHello* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PluginHello"; }

  explicit PluginHello(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PluginHello(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PluginHello& from);
  PluginHello(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PluginHello&& from) noexcept
      : PluginHello(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommandsFieldNumber = 4,
    kCustomItemsFieldNumber = 5,
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kApiVersionFieldNumber = 3,
  };
  // repeated .df.plugin.CommandSpec commands = 4 [json_name = "commands"];
  int commands_size() const;
  private:
  int _internal_commands_size() const;

  public:
  void clear_commands() ;
  ::df::plugin::CommandSpec* PROTOBUF_NONNULL mutable_commands(int index);
  ::google::protobuf::RepeatedPtrField<::df::plugin::CommandSpec>* PROTOBUF_NONNULL mutable_commands();

  private:
  const ::google::protobuf::RepeatedPtrField<::df::plugin::CommandSpec>& _internal_commands() const;
  ::google::protobuf::RepeatedPtrField<::df::plugin::CommandSpec>* PROTOBUF_NONNULL _internal_mutable_commands();
  public:
  const ::df::plugin::CommandSpec& commands(int index) const;
  ::df::plugin::CommandSpec* PROTOBUF_NONNULL add_commands();
  const ::google::protobuf::RepeatedPtrField<::df::plugin::CommandSpec>& commands() const;
  // repeated .df.plugin.CustomItemDefinition custom_items = 5 [json_name = "customItems"];
  int custom_items_size() const;
  private:
  int _internal_custom_items_size() const;

  public:
  void clear_custom_items() ;
  ::df::plugin::CustomItemDefinition* PROTOBUF_NONNULL mutable_custom_items(int index);
  ::google::protobuf::RepeatedPtrField<::df::plugin::CustomItemDefinition>* PROTOBUF_NONNULL mutable_custom_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::df::plugin::CustomItemDefinition>& _internal_custom_items() const;
  ::google::protobuf::RepeatedPtrField<::df::plugin::CustomItemDefinition>* PROTOBUF_NONNULL _internal_mutable_custom_items();
  public:
  const ::df::plugin::CustomItemDefinition& custom_items(int index) const;
  ::df::plugin::CustomItemDefinition* PROTOBUF_NONNULL add_custom_items();
  const ::google::protobuf::RepeatedPtrField<::df::plugin::CustomItemDefinition>& custom_items() const;
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string version = 2 [json_name = "version"];
  void clear_version() ;
  const ::std::string& version() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_version();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_version();
  void set_allocated_version(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_version() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_version(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_version();

  public:
  // string api_version = 3 [json_name = "apiVersion"];
  void clear_api_version() ;
  const ::std::string& api_version() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_api_version(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_api_version();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_api_version();
  void set_allocated_api_version(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_api_version() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_api_version(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_api_version();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.PluginHello)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   2, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PluginHello& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::df::plugin::CommandSpec > commands_;
    ::google::protobuf::RepeatedPtrField< ::df::plugin::CustomItemDefinition > custom_items_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr api_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plugin_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PluginHello_class_data_;
// -------------------------------------------------------------------

class EventEnvelope final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.EventEnvelope) */ {
 public:
  inline EventEnvelope() : EventEnvelope(nullptr) {}
  ~EventEnvelope() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EventEnvelope* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EventEnvelope));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EventEnvelope(::google::protobuf::internal::ConstantInitialized);

  inline EventEnvelope(const EventEnvelope& from) : EventEnvelope(nullptr, from) {}
  inline EventEnvelope(EventEnvelope&& from) noexcept
      : EventEnvelope(nullptr, ::std::move(from)) {}
  inline EventEnvelope& operator=(const EventEnvelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventEnvelope& operator=(EventEnvelope&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventEnvelope& default_instance() {
    return *reinterpret_cast<const EventEnvelope*>(
        &_EventEnvelope_default_instance_);
  }
  enum PayloadCase {
    kPlayerJoin = 10,
    kPlayerQuit = 11,
    kPlayerMove = 12,
    kPlayerJump = 13,
    kPlayerTeleport = 14,
    kPlayerChangeWorld = 15,
    kPlayerToggleSprint = 16,
    kPlayerToggleSneak = 17,
    kChat = 18,
    kPlayerFoodLoss = 19,
    kPlayerHeal = 20,
    kPlayerHurt = 21,
    kPlayerDeath = 22,
    kPlayerRespawn = 23,
    kPlayerSkinChange = 24,
    kPlayerFireExtinguish = 25,
    kPlayerStartBreak = 26,
    kBlockBreak = 27,
    kPlayerBlockPlace = 28,
    kPlayerBlockPick = 29,
    kPlayerItemUse = 30,
    kPlayerItemUseOnBlock = 31,
    kPlayerItemUseOnEntity = 32,
    kPlayerItemRelease = 33,
    kPlayerItemConsume = 34,
    kPlayerAttackEntity = 35,
    kPlayerExperienceGain = 36,
    kPlayerPunchAir = 37,
    kPlayerSignEdit = 38,
    kPlayerLecternPageTurn = 39,
    kPlayerItemDamage = 40,
    kPlayerItemPickup = 41,
    kPlayerHeldSlotChange = 42,
    kPlayerItemDrop = 43,
    kPlayerTransfer = 44,
    kCommand = 45,
    kPlayerDiagnostics = 46,
    kWorldLiquidFlow = 70,
    kWorldLiquidDecay = 71,
    kWorldLiquidHarden = 72,
    kWorldSound = 73,
    kWorldFireSpread = 74,
    kWorldBlockBurn = 75,
    kWorldCropTrample = 76,
    kWorldLeavesDecay = 77,
    kWorldEntitySpawn = 78,
    kWorldEntityDespawn = 79,
    kWorldExplosion = 80,
    kWorldClose = 81,
    PAYLOAD_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(EventEnvelope& a, EventEnvelope& b) { a.Swap(&b); }
  inline void Swap(EventEnvelope* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventEnvelope* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventEnvelope* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EventEnvelope>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventEnvelope& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EventEnvelope& from) { EventEnvelope::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EventEnvelope* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.EventEnvelope"; }

  explicit EventEnvelope(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EventEnvelope(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EventEnvelope& from);
  EventEnvelope(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EventEnvelope&& from) noexcept
      : EventEnvelope(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kExpectsResponseFieldNumber = 3,
    kPlayerJoinFieldNumber = 10,
    kPlayerQuitFieldNumber = 11,
    kPlayerMoveFieldNumber = 12,
    kPlayerJumpFieldNumber = 13,
    kPlayerTeleportFieldNumber = 14,
    kPlayerChangeWorldFieldNumber = 15,
    kPlayerToggleSprintFieldNumber = 16,
    kPlayerToggleSneakFieldNumber = 17,
    kChatFieldNumber = 18,
    kPlayerFoodLossFieldNumber = 19,
    kPlayerHealFieldNumber = 20,
    kPlayerHurtFieldNumber = 21,
    kPlayerDeathFieldNumber = 22,
    kPlayerRespawnFieldNumber = 23,
    kPlayerSkinChangeFieldNumber = 24,
    kPlayerFireExtinguishFieldNumber = 25,
    kPlayerStartBreakFieldNumber = 26,
    kBlockBreakFieldNumber = 27,
    kPlayerBlockPlaceFieldNumber = 28,
    kPlayerBlockPickFieldNumber = 29,
    kPlayerItemUseFieldNumber = 30,
    kPlayerItemUseOnBlockFieldNumber = 31,
    kPlayerItemUseOnEntityFieldNumber = 32,
    kPlayerItemReleaseFieldNumber = 33,
    kPlayerItemConsumeFieldNumber = 34,
    kPlayerAttackEntityFieldNumber = 35,
    kPlayerExperienceGainFieldNumber = 36,
    kPlayerPunchAirFieldNumber = 37,
    kPlayerSignEditFieldNumber = 38,
    kPlayerLecternPageTurnFieldNumber = 39,
    kPlayerItemDamageFieldNumber = 40,
    kPlayerItemPickupFieldNumber = 41,
    kPlayerHeldSlotChangeFieldNumber = 42,
    kPlayerItemDropFieldNumber = 43,
    kPlayerTransferFieldNumber = 44,
    kCommandFieldNumber = 45,
    kPlayerDiagnosticsFieldNumber = 46,
    kWorldLiquidFlowFieldNumber = 70,
    kWorldLiquidDecayFieldNumber = 71,
    kWorldLiquidHardenFieldNumber = 72,
    kWorldSoundFieldNumber = 73,
    kWorldFireSpreadFieldNumber = 74,
    kWorldBlockBurnFieldNumber = 75,
    kWorldCropTrampleFieldNumber = 76,
    kWorldLeavesDecayFieldNumber = 77,
    kWorldEntitySpawnFieldNumber = 78,
    kWorldEntityDespawnFieldNumber = 79,
    kWorldExplosionFieldNumber = 80,
    kWorldCloseFieldNumber = 81,
  };
  // string event_id = 1 [json_name = "eventId"];
  void clear_event_id() ;
  const ::std::string& event_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_event_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_event_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_event_id();
  void set_allocated_event_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_event_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_event_id();

  public:
  // .df.plugin.EventType type = 2 [json_name = "type"];
  void clear_type() ;
  ::df::plugin::EventType type() const;
  void set_type(::df::plugin::EventType value);

  private:
  ::df::plugin::EventType _internal_type() const;
  void _internal_set_type(::df::plugin::EventType value);

  public:
  // bool expects_response = 3 [json_name = "expectsResponse"];
  void clear_expects_response() ;
  bool expects_response() const;
  void set_expects_response(bool value);

  private:
  bool _internal_expects_response() const;
  void _internal_set_expects_response(bool value);

  public:
  // .df.plugin.PlayerJoinEvent player_join = 10 [json_name = "playerJoin"];
  bool has_player_join() const;
  private:
  bool _internal_has_player_join() const;

  public:
  void clear_player_join() ;
  const ::df::plugin::PlayerJoinEvent& player_join() const;
  [[nodiscard]] ::df::plugin::PlayerJoinEvent* PROTOBUF_NULLABLE release_player_join();
  ::df::plugin::PlayerJoinEvent* PROTOBUF_NONNULL mutable_player_join();
  void set_allocated_player_join(::df::plugin::PlayerJoinEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_join(::df::plugin::PlayerJoinEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerJoinEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_join();

  private:
  const ::df::plugin::PlayerJoinEvent& _internal_player_join() const;
  ::df::plugin::PlayerJoinEvent* PROTOBUF_NONNULL _internal_mutable_player_join();

  public:
  // .df.plugin.PlayerQuitEvent player_quit = 11 [json_name = "playerQuit"];
  bool has_player_quit() const;
  private:
  bool _internal_has_player_quit() const;

  public:
  void clear_player_quit() ;
  const ::df::plugin::PlayerQuitEvent& player_quit() const;
  [[nodiscard]] ::df::plugin::PlayerQuitEvent* PROTOBUF_NULLABLE release_player_quit();
  ::df::plugin::PlayerQuitEvent* PROTOBUF_NONNULL mutable_player_quit();
  void set_allocated_player_quit(::df::plugin::PlayerQuitEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_quit(::df::plugin::PlayerQuitEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerQuitEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_quit();

  private:
  const ::df::plugin::PlayerQuitEvent& _internal_player_quit() const;
  ::df::plugin::PlayerQuitEvent* PROTOBUF_NONNULL _internal_mutable_player_quit();

  public:
  // .df.plugin.PlayerMoveEvent player_move = 12 [json_name = "playerMove"];
  bool has_player_move() const;
  private:
  bool _internal_has_player_move() const;

  public:
  void clear_player_move() ;
  const ::df::plugin::PlayerMoveEvent& player_move() const;
  [[nodiscard]] ::df::plugin::PlayerMoveEvent* PROTOBUF_NULLABLE release_player_move();
  ::df::plugin::PlayerMoveEvent* PROTOBUF_NONNULL mutable_player_move();
  void set_allocated_player_move(::df::plugin::PlayerMoveEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_move(::df::plugin::PlayerMoveEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerMoveEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_move();

  private:
  const ::df::plugin::PlayerMoveEvent& _internal_player_move() const;
  ::df::plugin::PlayerMoveEvent* PROTOBUF_NONNULL _internal_mutable_player_move();

  public:
  // .df.plugin.PlayerJumpEvent player_jump = 13 [json_name = "playerJump"];
  bool has_player_jump() const;
  private:
  bool _internal_has_player_jump() const;

  public:
  void clear_player_jump() ;
  const ::df::plugin::PlayerJumpEvent& player_jump() const;
  [[nodiscard]] ::df::plugin::PlayerJumpEvent* PROTOBUF_NULLABLE release_player_jump();
  ::df::plugin::PlayerJumpEvent* PROTOBUF_NONNULL mutable_player_jump();
  void set_allocated_player_jump(::df::plugin::PlayerJumpEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_jump(::df::plugin::PlayerJumpEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerJumpEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_jump();

  private:
  const ::df::plugin::PlayerJumpEvent& _internal_player_jump() const;
  ::df::plugin::PlayerJumpEvent* PROTOBUF_NONNULL _internal_mutable_player_jump();

  public:
  // .df.plugin.PlayerTeleportEvent player_teleport = 14 [json_name = "playerTeleport"];
  bool has_player_teleport() const;
  private:
  bool _internal_has_player_teleport() const;

  public:
  void clear_player_teleport() ;
  const ::df::plugin::PlayerTeleportEvent& player_teleport() const;
  [[nodiscard]] ::df::plugin::PlayerTeleportEvent* PROTOBUF_NULLABLE release_player_teleport();
  ::df::plugin::PlayerTeleportEvent* PROTOBUF_NONNULL mutable_player_teleport();
  void set_allocated_player_teleport(::df::plugin::PlayerTeleportEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_teleport(::df::plugin::PlayerTeleportEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerTeleportEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_teleport();

  private:
  const ::df::plugin::PlayerTeleportEvent& _internal_player_teleport() const;
  ::df::plugin::PlayerTeleportEvent* PROTOBUF_NONNULL _internal_mutable_player_teleport();

  public:
  // .df.plugin.PlayerChangeWorldEvent player_change_world = 15 [json_name = "playerChangeWorld"];
  bool has_player_change_world() const;
  private:
  bool _internal_has_player_change_world() const;

  public:
  void clear_player_change_world() ;
  const ::df::plugin::PlayerChangeWorldEvent& player_change_world() const;
  [[nodiscard]] ::df::plugin::PlayerChangeWorldEvent* PROTOBUF_NULLABLE release_player_change_world();
  ::df::plugin::PlayerChangeWorldEvent* PROTOBUF_NONNULL mutable_player_change_world();
  void set_allocated_player_change_world(::df::plugin::PlayerChangeWorldEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_change_world(::df::plugin::PlayerChangeWorldEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerChangeWorldEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_change_world();

  private:
  const ::df::plugin::PlayerChangeWorldEvent& _internal_player_change_world() const;
  ::df::plugin::PlayerChangeWorldEvent* PROTOBUF_NONNULL _internal_mutable_player_change_world();

  public:
  // .df.plugin.PlayerToggleSprintEvent player_toggle_sprint = 16 [json_name = "playerToggleSprint"];
  bool has_player_toggle_sprint() const;
  private:
  bool _internal_has_player_toggle_sprint() const;

  public:
  void clear_player_toggle_sprint() ;
  const ::df::plugin::PlayerToggleSprintEvent& player_toggle_sprint() const;
  [[nodiscard]] ::df::plugin::PlayerToggleSprintEvent* PROTOBUF_NULLABLE release_player_toggle_sprint();
  ::df::plugin::PlayerToggleSprintEvent* PROTOBUF_NONNULL mutable_player_toggle_sprint();
  void set_allocated_player_toggle_sprint(::df::plugin::PlayerToggleSprintEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_toggle_sprint(::df::plugin::PlayerToggleSprintEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerToggleSprintEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_toggle_sprint();

  private:
  const ::df::plugin::PlayerToggleSprintEvent& _internal_player_toggle_sprint() const;
  ::df::plugin::PlayerToggleSprintEvent* PROTOBUF_NONNULL _internal_mutable_player_toggle_sprint();

  public:
  // .df.plugin.PlayerToggleSneakEvent player_toggle_sneak = 17 [json_name = "playerToggleSneak"];
  bool has_player_toggle_sneak() const;
  private:
  bool _internal_has_player_toggle_sneak() const;

  public:
  void clear_player_toggle_sneak() ;
  const ::df::plugin::PlayerToggleSneakEvent& player_toggle_sneak() const;
  [[nodiscard]] ::df::plugin::PlayerToggleSneakEvent* PROTOBUF_NULLABLE release_player_toggle_sneak();
  ::df::plugin::PlayerToggleSneakEvent* PROTOBUF_NONNULL mutable_player_toggle_sneak();
  void set_allocated_player_toggle_sneak(::df::plugin::PlayerToggleSneakEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_toggle_sneak(::df::plugin::PlayerToggleSneakEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerToggleSneakEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_toggle_sneak();

  private:
  const ::df::plugin::PlayerToggleSneakEvent& _internal_player_toggle_sneak() const;
  ::df::plugin::PlayerToggleSneakEvent* PROTOBUF_NONNULL _internal_mutable_player_toggle_sneak();

  public:
  // .df.plugin.ChatEvent chat = 18 [json_name = "chat"];
  bool has_chat() const;
  private:
  bool _internal_has_chat() const;

  public:
  void clear_chat() ;
  const ::df::plugin::ChatEvent& chat() const;
  [[nodiscard]] ::df::plugin::ChatEvent* PROTOBUF_NULLABLE release_chat();
  ::df::plugin::ChatEvent* PROTOBUF_NONNULL mutable_chat();
  void set_allocated_chat(::df::plugin::ChatEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chat(::df::plugin::ChatEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::ChatEvent* PROTOBUF_NULLABLE unsafe_arena_release_chat();

  private:
  const ::df::plugin::ChatEvent& _internal_chat() const;
  ::df::plugin::ChatEvent* PROTOBUF_NONNULL _internal_mutable_chat();

  public:
  // .df.plugin.PlayerFoodLossEvent player_food_loss = 19 [json_name = "playerFoodLoss"];
  bool has_player_food_loss() const;
  private:
  bool _internal_has_player_food_loss() const;

  public:
  void clear_player_food_loss() ;
  const ::df::plugin::PlayerFoodLossEvent& player_food_loss() const;
  [[nodiscard]] ::df::plugin::PlayerFoodLossEvent* PROTOBUF_NULLABLE release_player_food_loss();
  ::df::plugin::PlayerFoodLossEvent* PROTOBUF_NONNULL mutable_player_food_loss();
  void set_allocated_player_food_loss(::df::plugin::PlayerFoodLossEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_food_loss(::df::plugin::PlayerFoodLossEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerFoodLossEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_food_loss();

  private:
  const ::df::plugin::PlayerFoodLossEvent& _internal_player_food_loss() const;
  ::df::plugin::PlayerFoodLossEvent* PROTOBUF_NONNULL _internal_mutable_player_food_loss();

  public:
  // .df.plugin.PlayerHealEvent player_heal = 20 [json_name = "playerHeal"];
  bool has_player_heal() const;
  private:
  bool _internal_has_player_heal() const;

  public:
  void clear_player_heal() ;
  const ::df::plugin::PlayerHealEvent& player_heal() const;
  [[nodiscard]] ::df::plugin::PlayerHealEvent* PROTOBUF_NULLABLE release_player_heal();
  ::df::plugin::PlayerHealEvent* PROTOBUF_NONNULL mutable_player_heal();
  void set_allocated_player_heal(::df::plugin::PlayerHealEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_heal(::df::plugin::PlayerHealEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerHealEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_heal();

  private:
  const ::df::plugin::PlayerHealEvent& _internal_player_heal() const;
  ::df::plugin::PlayerHealEvent* PROTOBUF_NONNULL _internal_mutable_player_heal();

  public:
  // .df.plugin.PlayerHurtEvent player_hurt = 21 [json_name = "playerHurt"];
  bool has_player_hurt() const;
  private:
  bool _internal_has_player_hurt() const;

  public:
  void clear_player_hurt() ;
  const ::df::plugin::PlayerHurtEvent& player_hurt() const;
  [[nodiscard]] ::df::plugin::PlayerHurtEvent* PROTOBUF_NULLABLE release_player_hurt();
  ::df::plugin::PlayerHurtEvent* PROTOBUF_NONNULL mutable_player_hurt();
  void set_allocated_player_hurt(::df::plugin::PlayerHurtEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_hurt(::df::plugin::PlayerHurtEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerHurtEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_hurt();

  private:
  const ::df::plugin::PlayerHurtEvent& _internal_player_hurt() const;
  ::df::plugin::PlayerHurtEvent* PROTOBUF_NONNULL _internal_mutable_player_hurt();

  public:
  // .df.plugin.PlayerDeathEvent player_death = 22 [json_name = "playerDeath"];
  bool has_player_death() const;
  private:
  bool _internal_has_player_death() const;

  public:
  void clear_player_death() ;
  const ::df::plugin::PlayerDeathEvent& player_death() const;
  [[nodiscard]] ::df::plugin::PlayerDeathEvent* PROTOBUF_NULLABLE release_player_death();
  ::df::plugin::PlayerDeathEvent* PROTOBUF_NONNULL mutable_player_death();
  void set_allocated_player_death(::df::plugin::PlayerDeathEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_death(::df::plugin::PlayerDeathEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerDeathEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_death();

  private:
  const ::df::plugin::PlayerDeathEvent& _internal_player_death() const;
  ::df::plugin::PlayerDeathEvent* PROTOBUF_NONNULL _internal_mutable_player_death();

  public:
  // .df.plugin.PlayerRespawnEvent player_respawn = 23 [json_name = "playerRespawn"];
  bool has_player_respawn() const;
  private:
  bool _internal_has_player_respawn() const;

  public:
  void clear_player_respawn() ;
  const ::df::plugin::PlayerRespawnEvent& player_respawn() const;
  [[nodiscard]] ::df::plugin::PlayerRespawnEvent* PROTOBUF_NULLABLE release_player_respawn();
  ::df::plugin::PlayerRespawnEvent* PROTOBUF_NONNULL mutable_player_respawn();
  void set_allocated_player_respawn(::df::plugin::PlayerRespawnEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_respawn(::df::plugin::PlayerRespawnEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerRespawnEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_respawn();

  private:
  const ::df::plugin::PlayerRespawnEvent& _internal_player_respawn() const;
  ::df::plugin::PlayerRespawnEvent* PROTOBUF_NONNULL _internal_mutable_player_respawn();

  public:
  // .df.plugin.PlayerSkinChangeEvent player_skin_change = 24 [json_name = "playerSkinChange"];
  bool has_player_skin_change() const;
  private:
  bool _internal_has_player_skin_change() const;

  public:
  void clear_player_skin_change() ;
  const ::df::plugin::PlayerSkinChangeEvent& player_skin_change() const;
  [[nodiscard]] ::df::plugin::PlayerSkinChangeEvent* PROTOBUF_NULLABLE release_player_skin_change();
  ::df::plugin::PlayerSkinChangeEvent* PROTOBUF_NONNULL mutable_player_skin_change();
  void set_allocated_player_skin_change(::df::plugin::PlayerSkinChangeEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_skin_change(::df::plugin::PlayerSkinChangeEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerSkinChangeEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_skin_change();

  private:
  const ::df::plugin::PlayerSkinChangeEvent& _internal_player_skin_change() const;
  ::df::plugin::PlayerSkinChangeEvent* PROTOBUF_NONNULL _internal_mutable_player_skin_change();

  public:
  // .df.plugin.PlayerFireExtinguishEvent player_fire_extinguish = 25 [json_name = "playerFireExtinguish"];
  bool has_player_fire_extinguish() const;
  private:
  bool _internal_has_player_fire_extinguish() const;

  public:
  void clear_player_fire_extinguish() ;
  const ::df::plugin::PlayerFireExtinguishEvent& player_fire_extinguish() const;
  [[nodiscard]] ::df::plugin::PlayerFireExtinguishEvent* PROTOBUF_NULLABLE release_player_fire_extinguish();
  ::df::plugin::PlayerFireExtinguishEvent* PROTOBUF_NONNULL mutable_player_fire_extinguish();
  void set_allocated_player_fire_extinguish(::df::plugin::PlayerFireExtinguishEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_fire_extinguish(::df::plugin::PlayerFireExtinguishEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerFireExtinguishEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_fire_extinguish();

  private:
  const ::df::plugin::PlayerFireExtinguishEvent& _internal_player_fire_extinguish() const;
  ::df::plugin::PlayerFireExtinguishEvent* PROTOBUF_NONNULL _internal_mutable_player_fire_extinguish();

  public:
  // .df.plugin.PlayerStartBreakEvent player_start_break = 26 [json_name = "playerStartBreak"];
  bool has_player_start_break() const;
  private:
  bool _internal_has_player_start_break() const;

  public:
  void clear_player_start_break() ;
  const ::df::plugin::PlayerStartBreakEvent& player_start_break() const;
  [[nodiscard]] ::df::plugin::PlayerStartBreakEvent* PROTOBUF_NULLABLE release_player_start_break();
  ::df::plugin::PlayerStartBreakEvent* PROTOBUF_NONNULL mutable_player_start_break();
  void set_allocated_player_start_break(::df::plugin::PlayerStartBreakEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_start_break(::df::plugin::PlayerStartBreakEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerStartBreakEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_start_break();

  private:
  const ::df::plugin::PlayerStartBreakEvent& _internal_player_start_break() const;
  ::df::plugin::PlayerStartBreakEvent* PROTOBUF_NONNULL _internal_mutable_player_start_break();

  public:
  // .df.plugin.BlockBreakEvent block_break = 27 [json_name = "blockBreak"];
  bool has_block_break() const;
  private:
  bool _internal_has_block_break() const;

  public:
  void clear_block_break() ;
  const ::df::plugin::BlockBreakEvent& block_break() const;
  [[nodiscard]] ::df::plugin::BlockBreakEvent* PROTOBUF_NULLABLE release_block_break();
  ::df::plugin::BlockBreakEvent* PROTOBUF_NONNULL mutable_block_break();
  void set_allocated_block_break(::df::plugin::BlockBreakEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_block_break(::df::plugin::BlockBreakEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::BlockBreakEvent* PROTOBUF_NULLABLE unsafe_arena_release_block_break();

  private:
  const ::df::plugin::BlockBreakEvent& _internal_block_break() const;
  ::df::plugin::BlockBreakEvent* PROTOBUF_NONNULL _internal_mutable_block_break();

  public:
  // .df.plugin.PlayerBlockPlaceEvent player_block_place = 28 [json_name = "playerBlockPlace"];
  bool has_player_block_place() const;
  private:
  bool _internal_has_player_block_place() const;

  public:
  void clear_player_block_place() ;
  const ::df::plugin::PlayerBlockPlaceEvent& player_block_place() const;
  [[nodiscard]] ::df::plugin::PlayerBlockPlaceEvent* PROTOBUF_NULLABLE release_player_block_place();
  ::df::plugin::PlayerBlockPlaceEvent* PROTOBUF_NONNULL mutable_player_block_place();
  void set_allocated_player_block_place(::df::plugin::PlayerBlockPlaceEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_block_place(::df::plugin::PlayerBlockPlaceEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerBlockPlaceEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_block_place();

  private:
  const ::df::plugin::PlayerBlockPlaceEvent& _internal_player_block_place() const;
  ::df::plugin::PlayerBlockPlaceEvent* PROTOBUF_NONNULL _internal_mutable_player_block_place();

  public:
  // .df.plugin.PlayerBlockPickEvent player_block_pick = 29 [json_name = "playerBlockPick"];
  bool has_player_block_pick() const;
  private:
  bool _internal_has_player_block_pick() const;

  public:
  void clear_player_block_pick() ;
  const ::df::plugin::PlayerBlockPickEvent& player_block_pick() const;
  [[nodiscard]] ::df::plugin::PlayerBlockPickEvent* PROTOBUF_NULLABLE release_player_block_pick();
  ::df::plugin::PlayerBlockPickEvent* PROTOBUF_NONNULL mutable_player_block_pick();
  void set_allocated_player_block_pick(::df::plugin::PlayerBlockPickEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_block_pick(::df::plugin::PlayerBlockPickEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerBlockPickEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_block_pick();

  private:
  const ::df::plugin::PlayerBlockPickEvent& _internal_player_block_pick() const;
  ::df::plugin::PlayerBlockPickEvent* PROTOBUF_NONNULL _internal_mutable_player_block_pick();

  public:
  // .df.plugin.PlayerItemUseEvent player_item_use = 30 [json_name = "playerItemUse"];
  bool has_player_item_use() const;
  private:
  bool _internal_has_player_item_use() const;

  public:
  void clear_player_item_use() ;
  const ::df::plugin::PlayerItemUseEvent& player_item_use() const;
  [[nodiscard]] ::df::plugin::PlayerItemUseEvent* PROTOBUF_NULLABLE release_player_item_use();
  ::df::plugin::PlayerItemUseEvent* PROTOBUF_NONNULL mutable_player_item_use();
  void set_allocated_player_item_use(::df::plugin::PlayerItemUseEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_item_use(::df::plugin::PlayerItemUseEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerItemUseEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_item_use();

  private:
  const ::df::plugin::PlayerItemUseEvent& _internal_player_item_use() const;
  ::df::plugin::PlayerItemUseEvent* PROTOBUF_NONNULL _internal_mutable_player_item_use();

  public:
  // .df.plugin.PlayerItemUseOnBlockEvent player_item_use_on_block = 31 [json_name = "playerItemUseOnBlock"];
  bool has_player_item_use_on_block() const;
  private:
  bool _internal_has_player_item_use_on_block() const;

  public:
  void clear_player_item_use_on_block() ;
  const ::df::plugin::PlayerItemUseOnBlockEvent& player_item_use_on_block() const;
  [[nodiscard]] ::df::plugin::PlayerItemUseOnBlockEvent* PROTOBUF_NULLABLE release_player_item_use_on_block();
  ::df::plugin::PlayerItemUseOnBlockEvent* PROTOBUF_NONNULL mutable_player_item_use_on_block();
  void set_allocated_player_item_use_on_block(::df::plugin::PlayerItemUseOnBlockEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_item_use_on_block(::df::plugin::PlayerItemUseOnBlockEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerItemUseOnBlockEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_item_use_on_block();

  private:
  const ::df::plugin::PlayerItemUseOnBlockEvent& _internal_player_item_use_on_block() const;
  ::df::plugin::PlayerItemUseOnBlockEvent* PROTOBUF_NONNULL _internal_mutable_player_item_use_on_block();

  public:
  // .df.plugin.PlayerItemUseOnEntityEvent player_item_use_on_entity = 32 [json_name = "playerItemUseOnEntity"];
  bool has_player_item_use_on_entity() const;
  private:
  bool _internal_has_player_item_use_on_entity() const;

  public:
  void clear_player_item_use_on_entity() ;
  const ::df::plugin::PlayerItemUseOnEntityEvent& player_item_use_on_entity() const;
  [[nodiscard]] ::df::plugin::PlayerItemUseOnEntityEvent* PROTOBUF_NULLABLE release_player_item_use_on_entity();
  ::df::plugin::PlayerItemUseOnEntityEvent* PROTOBUF_NONNULL mutable_player_item_use_on_entity();
  void set_allocated_player_item_use_on_entity(::df::plugin::PlayerItemUseOnEntityEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_item_use_on_entity(::df::plugin::PlayerItemUseOnEntityEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerItemUseOnEntityEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_item_use_on_entity();

  private:
  const ::df::plugin::PlayerItemUseOnEntityEvent& _internal_player_item_use_on_entity() const;
  ::df::plugin::PlayerItemUseOnEntityEvent* PROTOBUF_NONNULL _internal_mutable_player_item_use_on_entity();

  public:
  // .df.plugin.PlayerItemReleaseEvent player_item_release = 33 [json_name = "playerItemRelease"];
  bool has_player_item_release() const;
  private:
  bool _internal_has_player_item_release() const;

  public:
  void clear_player_item_release() ;
  const ::df::plugin::PlayerItemReleaseEvent& player_item_release() const;
  [[nodiscard]] ::df::plugin::PlayerItemReleaseEvent* PROTOBUF_NULLABLE release_player_item_release();
  ::df::plugin::PlayerItemReleaseEvent* PROTOBUF_NONNULL mutable_player_item_release();
  void set_allocated_player_item_release(::df::plugin::PlayerItemReleaseEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_item_release(::df::plugin::PlayerItemReleaseEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerItemReleaseEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_item_release();

  private:
  const ::df::plugin::PlayerItemReleaseEvent& _internal_player_item_release() const;
  ::df::plugin::PlayerItemReleaseEvent* PROTOBUF_NONNULL _internal_mutable_player_item_release();

  public:
  // .df.plugin.PlayerItemConsumeEvent player_item_consume = 34 [json_name = "playerItemConsume"];
  bool has_player_item_consume() const;
  private:
  bool _internal_has_player_item_consume() const;

  public:
  void clear_player_item_consume() ;
  const ::df::plugin::PlayerItemConsumeEvent& player_item_consume() const;
  [[nodiscard]] ::df::plugin::PlayerItemConsumeEvent* PROTOBUF_NULLABLE release_player_item_consume();
  ::df::plugin::PlayerItemConsumeEvent* PROTOBUF_NONNULL mutable_player_item_consume();
  void set_allocated_player_item_consume(::df::plugin::PlayerItemConsumeEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_item_consume(::df::plugin::PlayerItemConsumeEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerItemConsumeEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_item_consume();

  private:
  const ::df::plugin::PlayerItemConsumeEvent& _internal_player_item_consume() const;
  ::df::plugin::PlayerItemConsumeEvent* PROTOBUF_NONNULL _internal_mutable_player_item_consume();

  public:
  // .df.plugin.PlayerAttackEntityEvent player_attack_entity = 35 [json_name = "playerAttackEntity"];
  bool has_player_attack_entity() const;
  private:
  bool _internal_has_player_attack_entity() const;

  public:
  void clear_player_attack_entity() ;
  const ::df::plugin::PlayerAttackEntityEvent& player_attack_entity() const;
  [[nodiscard]] ::df::plugin::PlayerAttackEntityEvent* PROTOBUF_NULLABLE release_player_attack_entity();
  ::df::plugin::PlayerAttackEntityEvent* PROTOBUF_NONNULL mutable_player_attack_entity();
  void set_allocated_player_attack_entity(::df::plugin::PlayerAttackEntityEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_attack_entity(::df::plugin::PlayerAttackEntityEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerAttackEntityEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_attack_entity();

  private:
  const ::df::plugin::PlayerAttackEntityEvent& _internal_player_attack_entity() const;
  ::df::plugin::PlayerAttackEntityEvent* PROTOBUF_NONNULL _internal_mutable_player_attack_entity();

  public:
  // .df.plugin.PlayerExperienceGainEvent player_experience_gain = 36 [json_name = "playerExperienceGain"];
  bool has_player_experience_gain() const;
  private:
  bool _internal_has_player_experience_gain() const;

  public:
  void clear_player_experience_gain() ;
  const ::df::plugin::PlayerExperienceGainEvent& player_experience_gain() const;
  [[nodiscard]] ::df::plugin::PlayerExperienceGainEvent* PROTOBUF_NULLABLE release_player_experience_gain();
  ::df::plugin::PlayerExperienceGainEvent* PROTOBUF_NONNULL mutable_player_experience_gain();
  void set_allocated_player_experience_gain(::df::plugin::PlayerExperienceGainEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_experience_gain(::df::plugin::PlayerExperienceGainEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerExperienceGainEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_experience_gain();

  private:
  const ::df::plugin::PlayerExperienceGainEvent& _internal_player_experience_gain() const;
  ::df::plugin::PlayerExperienceGainEvent* PROTOBUF_NONNULL _internal_mutable_player_experience_gain();

  public:
  // .df.plugin.PlayerPunchAirEvent player_punch_air = 37 [json_name = "playerPunchAir"];
  bool has_player_punch_air() const;
  private:
  bool _internal_has_player_punch_air() const;

  public:
  void clear_player_punch_air() ;
  const ::df::plugin::PlayerPunchAirEvent& player_punch_air() const;
  [[nodiscard]] ::df::plugin::PlayerPunchAirEvent* PROTOBUF_NULLABLE release_player_punch_air();
  ::df::plugin::PlayerPunchAirEvent* PROTOBUF_NONNULL mutable_player_punch_air();
  void set_allocated_player_punch_air(::df::plugin::PlayerPunchAirEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_punch_air(::df::plugin::PlayerPunchAirEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerPunchAirEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_punch_air();

  private:
  const ::df::plugin::PlayerPunchAirEvent& _internal_player_punch_air() const;
  ::df::plugin::PlayerPunchAirEvent* PROTOBUF_NONNULL _internal_mutable_player_punch_air();

  public:
  // .df.plugin.PlayerSignEditEvent player_sign_edit = 38 [json_name = "playerSignEdit"];
  bool has_player_sign_edit() const;
  private:
  bool _internal_has_player_sign_edit() const;

  public:
  void clear_player_sign_edit() ;
  const ::df::plugin::PlayerSignEditEvent& player_sign_edit() const;
  [[nodiscard]] ::df::plugin::PlayerSignEditEvent* PROTOBUF_NULLABLE release_player_sign_edit();
  ::df::plugin::PlayerSignEditEvent* PROTOBUF_NONNULL mutable_player_sign_edit();
  void set_allocated_player_sign_edit(::df::plugin::PlayerSignEditEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_sign_edit(::df::plugin::PlayerSignEditEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerSignEditEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_sign_edit();

  private:
  const ::df::plugin::PlayerSignEditEvent& _internal_player_sign_edit() const;
  ::df::plugin::PlayerSignEditEvent* PROTOBUF_NONNULL _internal_mutable_player_sign_edit();

  public:
  // .df.plugin.PlayerLecternPageTurnEvent player_lectern_page_turn = 39 [json_name = "playerLecternPageTurn"];
  bool has_player_lectern_page_turn() const;
  private:
  bool _internal_has_player_lectern_page_turn() const;

  public:
  void clear_player_lectern_page_turn() ;
  const ::df::plugin::PlayerLecternPageTurnEvent& player_lectern_page_turn() const;
  [[nodiscard]] ::df::plugin::PlayerLecternPageTurnEvent* PROTOBUF_NULLABLE release_player_lectern_page_turn();
  ::df::plugin::PlayerLecternPageTurnEvent* PROTOBUF_NONNULL mutable_player_lectern_page_turn();
  void set_allocated_player_lectern_page_turn(::df::plugin::PlayerLecternPageTurnEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_lectern_page_turn(::df::plugin::PlayerLecternPageTurnEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerLecternPageTurnEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_lectern_page_turn();

  private:
  const ::df::plugin::PlayerLecternPageTurnEvent& _internal_player_lectern_page_turn() const;
  ::df::plugin::PlayerLecternPageTurnEvent* PROTOBUF_NONNULL _internal_mutable_player_lectern_page_turn();

  public:
  // .df.plugin.PlayerItemDamageEvent player_item_damage = 40 [json_name = "playerItemDamage"];
  bool has_player_item_damage() const;
  private:
  bool _internal_has_player_item_damage() const;

  public:
  void clear_player_item_damage() ;
  const ::df::plugin::PlayerItemDamageEvent& player_item_damage() const;
  [[nodiscard]] ::df::plugin::PlayerItemDamageEvent* PROTOBUF_NULLABLE release_player_item_damage();
  ::df::plugin::PlayerItemDamageEvent* PROTOBUF_NONNULL mutable_player_item_damage();
  void set_allocated_player_item_damage(::df::plugin::PlayerItemDamageEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_item_damage(::df::plugin::PlayerItemDamageEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerItemDamageEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_item_damage();

  private:
  const ::df::plugin::PlayerItemDamageEvent& _internal_player_item_damage() const;
  ::df::plugin::PlayerItemDamageEvent* PROTOBUF_NONNULL _internal_mutable_player_item_damage();

  public:
  // .df.plugin.PlayerItemPickupEvent player_item_pickup = 41 [json_name = "playerItemPickup"];
  bool has_player_item_pickup() const;
  private:
  bool _internal_has_player_item_pickup() const;

  public:
  void clear_player_item_pickup() ;
  const ::df::plugin::PlayerItemPickupEvent& player_item_pickup() const;
  [[nodiscard]] ::df::plugin::PlayerItemPickupEvent* PROTOBUF_NULLABLE release_player_item_pickup();
  ::df::plugin::PlayerItemPickupEvent* PROTOBUF_NONNULL mutable_player_item_pickup();
  void set_allocated_player_item_pickup(::df::plugin::PlayerItemPickupEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_item_pickup(::df::plugin::PlayerItemPickupEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerItemPickupEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_item_pickup();

  private:
  const ::df::plugin::PlayerItemPickupEvent& _internal_player_item_pickup() const;
  ::df::plugin::PlayerItemPickupEvent* PROTOBUF_NONNULL _internal_mutable_player_item_pickup();

  public:
  // .df.plugin.PlayerHeldSlotChangeEvent player_held_slot_change = 42 [json_name = "playerHeldSlotChange"];
  bool has_player_held_slot_change() const;
  private:
  bool _internal_has_player_held_slot_change() const;

  public:
  void clear_player_held_slot_change() ;
  const ::df::plugin::PlayerHeldSlotChangeEvent& player_held_slot_change() const;
  [[nodiscard]] ::df::plugin::PlayerHeldSlotChangeEvent* PROTOBUF_NULLABLE release_player_held_slot_change();
  ::df::plugin::PlayerHeldSlotChangeEvent* PROTOBUF_NONNULL mutable_player_held_slot_change();
  void set_allocated_player_held_slot_change(::df::plugin::PlayerHeldSlotChangeEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_held_slot_change(::df::plugin::PlayerHeldSlotChangeEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerHeldSlotChangeEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_held_slot_change();

  private:
  const ::df::plugin::PlayerHeldSlotChangeEvent& _internal_player_held_slot_change() const;
  ::df::plugin::PlayerHeldSlotChangeEvent* PROTOBUF_NONNULL _internal_mutable_player_held_slot_change();

  public:
  // .df.plugin.PlayerItemDropEvent player_item_drop = 43 [json_name = "playerItemDrop"];
  bool has_player_item_drop() const;
  private:
  bool _internal_has_player_item_drop() const;

  public:
  void clear_player_item_drop() ;
  const ::df::plugin::PlayerItemDropEvent& player_item_drop() const;
  [[nodiscard]] ::df::plugin::PlayerItemDropEvent* PROTOBUF_NULLABLE release_player_item_drop();
  ::df::plugin::PlayerItemDropEvent* PROTOBUF_NONNULL mutable_player_item_drop();
  void set_allocated_player_item_drop(::df::plugin::PlayerItemDropEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_item_drop(::df::plugin::PlayerItemDropEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerItemDropEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_item_drop();

  private:
  const ::df::plugin::PlayerItemDropEvent& _internal_player_item_drop() const;
  ::df::plugin::PlayerItemDropEvent* PROTOBUF_NONNULL _internal_mutable_player_item_drop();

  public:
  // .df.plugin.PlayerTransferEvent player_transfer = 44 [json_name = "playerTransfer"];
  bool has_player_transfer() const;
  private:
  bool _internal_has_player_transfer() const;

  public:
  void clear_player_transfer() ;
  const ::df::plugin::PlayerTransferEvent& player_transfer() const;
  [[nodiscard]] ::df::plugin::PlayerTransferEvent* PROTOBUF_NULLABLE release_player_transfer();
  ::df::plugin::PlayerTransferEvent* PROTOBUF_NONNULL mutable_player_transfer();
  void set_allocated_player_transfer(::df::plugin::PlayerTransferEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_transfer(::df::plugin::PlayerTransferEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerTransferEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_transfer();

  private:
  const ::df::plugin::PlayerTransferEvent& _internal_player_transfer() const;
  ::df::plugin::PlayerTransferEvent* PROTOBUF_NONNULL _internal_mutable_player_transfer();

  public:
  // .df.plugin.CommandEvent command = 45 [json_name = "command"];
  bool has_command() const;
  private:
  bool _internal_has_command() const;

  public:
  void clear_command() ;
  const ::df::plugin::CommandEvent& command() const;
  [[nodiscard]] ::df::plugin::CommandEvent* PROTOBUF_NULLABLE release_command();
  ::df::plugin::CommandEvent* PROTOBUF_NONNULL mutable_command();
  void set_allocated_command(::df::plugin::CommandEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_command(::df::plugin::CommandEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::CommandEvent* PROTOBUF_NULLABLE unsafe_arena_release_command();

  private:
  const ::df::plugin::CommandEvent& _internal_command() const;
  ::df::plugin::CommandEvent* PROTOBUF_NONNULL _internal_mutable_command();

  public:
  // .df.plugin.PlayerDiagnosticsEvent player_diagnostics = 46 [json_name = "playerDiagnostics"];
  bool has_player_diagnostics() const;
  private:
  bool _internal_has_player_diagnostics() const;

  public:
  void clear_player_diagnostics() ;
  const ::df::plugin::PlayerDiagnosticsEvent& player_diagnostics() const;
  [[nodiscard]] ::df::plugin::PlayerDiagnosticsEvent* PROTOBUF_NULLABLE release_player_diagnostics();
  ::df::plugin::PlayerDiagnosticsEvent* PROTOBUF_NONNULL mutable_player_diagnostics();
  void set_allocated_player_diagnostics(::df::plugin::PlayerDiagnosticsEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_diagnostics(::df::plugin::PlayerDiagnosticsEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::PlayerDiagnosticsEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_diagnostics();

  private:
  const ::df::plugin::PlayerDiagnosticsEvent& _internal_player_diagnostics() const;
  ::df::plugin::PlayerDiagnosticsEvent* PROTOBUF_NONNULL _internal_mutable_player_diagnostics();

  public:
  // .df.plugin.WorldLiquidFlowEvent world_liquid_flow = 70 [json_name = "worldLiquidFlow"];
  bool has_world_liquid_flow() const;
  private:
  bool _internal_has_world_liquid_flow() const;

  public:
  void clear_world_liquid_flow() ;
  const ::df::plugin::WorldLiquidFlowEvent& world_liquid_flow() const;
  [[nodiscard]] ::df::plugin::WorldLiquidFlowEvent* PROTOBUF_NULLABLE release_world_liquid_flow();
  ::df::plugin::WorldLiquidFlowEvent* PROTOBUF_NONNULL mutable_world_liquid_flow();
  void set_allocated_world_liquid_flow(::df::plugin::WorldLiquidFlowEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_liquid_flow(::df::plugin::WorldLiquidFlowEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldLiquidFlowEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_liquid_flow();

  private:
  const ::df::plugin::WorldLiquidFlowEvent& _internal_world_liquid_flow() const;
  ::df::plugin::WorldLiquidFlowEvent* PROTOBUF_NONNULL _internal_mutable_world_liquid_flow();

  public:
  // .df.plugin.WorldLiquidDecayEvent world_liquid_decay = 71 [json_name = "worldLiquidDecay"];
  bool has_world_liquid_decay() const;
  private:
  bool _internal_has_world_liquid_decay() const;

  public:
  void clear_world_liquid_decay() ;
  const ::df::plugin::WorldLiquidDecayEvent& world_liquid_decay() const;
  [[nodiscard]] ::df::plugin::WorldLiquidDecayEvent* PROTOBUF_NULLABLE release_world_liquid_decay();
  ::df::plugin::WorldLiquidDecayEvent* PROTOBUF_NONNULL mutable_world_liquid_decay();
  void set_allocated_world_liquid_decay(::df::plugin::WorldLiquidDecayEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_liquid_decay(::df::plugin::WorldLiquidDecayEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldLiquidDecayEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_liquid_decay();

  private:
  const ::df::plugin::WorldLiquidDecayEvent& _internal_world_liquid_decay() const;
  ::df::plugin::WorldLiquidDecayEvent* PROTOBUF_NONNULL _internal_mutable_world_liquid_decay();

  public:
  // .df.plugin.WorldLiquidHardenEvent world_liquid_harden = 72 [json_name = "worldLiquidHarden"];
  bool has_world_liquid_harden() const;
  private:
  bool _internal_has_world_liquid_harden() const;

  public:
  void clear_world_liquid_harden() ;
  const ::df::plugin::WorldLiquidHardenEvent& world_liquid_harden() const;
  [[nodiscard]] ::df::plugin::WorldLiquidHardenEvent* PROTOBUF_NULLABLE release_world_liquid_harden();
  ::df::plugin::WorldLiquidHardenEvent* PROTOBUF_NONNULL mutable_world_liquid_harden();
  void set_allocated_world_liquid_harden(::df::plugin::WorldLiquidHardenEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_liquid_harden(::df::plugin::WorldLiquidHardenEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldLiquidHardenEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_liquid_harden();

  private:
  const ::df::plugin::WorldLiquidHardenEvent& _internal_world_liquid_harden() const;
  ::df::plugin::WorldLiquidHardenEvent* PROTOBUF_NONNULL _internal_mutable_world_liquid_harden();

  public:
  // .df.plugin.WorldSoundEvent world_sound = 73 [json_name = "worldSound"];
  bool has_world_sound() const;
  private:
  bool _internal_has_world_sound() const;

  public:
  void clear_world_sound() ;
  const ::df::plugin::WorldSoundEvent& world_sound() const;
  [[nodiscard]] ::df::plugin::WorldSoundEvent* PROTOBUF_NULLABLE release_world_sound();
  ::df::plugin::WorldSoundEvent* PROTOBUF_NONNULL mutable_world_sound();
  void set_allocated_world_sound(::df::plugin::WorldSoundEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_sound(::df::plugin::WorldSoundEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldSoundEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_sound();

  private:
  const ::df::plugin::WorldSoundEvent& _internal_world_sound() const;
  ::df::plugin::WorldSoundEvent* PROTOBUF_NONNULL _internal_mutable_world_sound();

  public:
  // .df.plugin.WorldFireSpreadEvent world_fire_spread = 74 [json_name = "worldFireSpread"];
  bool has_world_fire_spread() const;
  private:
  bool _internal_has_world_fire_spread() const;

  public:
  void clear_world_fire_spread() ;
  const ::df::plugin::WorldFireSpreadEvent& world_fire_spread() const;
  [[nodiscard]] ::df::plugin::WorldFireSpreadEvent* PROTOBUF_NULLABLE release_world_fire_spread();
  ::df::plugin::WorldFireSpreadEvent* PROTOBUF_NONNULL mutable_world_fire_spread();
  void set_allocated_world_fire_spread(::df::plugin::WorldFireSpreadEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_fire_spread(::df::plugin::WorldFireSpreadEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldFireSpreadEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_fire_spread();

  private:
  const ::df::plugin::WorldFireSpreadEvent& _internal_world_fire_spread() const;
  ::df::plugin::WorldFireSpreadEvent* PROTOBUF_NONNULL _internal_mutable_world_fire_spread();

  public:
  // .df.plugin.WorldBlockBurnEvent world_block_burn = 75 [json_name = "worldBlockBurn"];
  bool has_world_block_burn() const;
  private:
  bool _internal_has_world_block_burn() const;

  public:
  void clear_world_block_burn() ;
  const ::df::plugin::WorldBlockBurnEvent& world_block_burn() const;
  [[nodiscard]] ::df::plugin::WorldBlockBurnEvent* PROTOBUF_NULLABLE release_world_block_burn();
  ::df::plugin::WorldBlockBurnEvent* PROTOBUF_NONNULL mutable_world_block_burn();
  void set_allocated_world_block_burn(::df::plugin::WorldBlockBurnEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_block_burn(::df::plugin::WorldBlockBurnEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldBlockBurnEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_block_burn();

  private:
  const ::df::plugin::WorldBlockBurnEvent& _internal_world_block_burn() const;
  ::df::plugin::WorldBlockBurnEvent* PROTOBUF_NONNULL _internal_mutable_world_block_burn();

  public:
  // .df.plugin.WorldCropTrampleEvent world_crop_trample = 76 [json_name = "worldCropTrample"];
  bool has_world_crop_trample() const;
  private:
  bool _internal_has_world_crop_trample() const;

  public:
  void clear_world_crop_trample() ;
  const ::df::plugin::WorldCropTrampleEvent& world_crop_trample() const;
  [[nodiscard]] ::df::plugin::WorldCropTrampleEvent* PROTOBUF_NULLABLE release_world_crop_trample();
  ::df::plugin::WorldCropTrampleEvent* PROTOBUF_NONNULL mutable_world_crop_trample();
  void set_allocated_world_crop_trample(::df::plugin::WorldCropTrampleEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_crop_trample(::df::plugin::WorldCropTrampleEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldCropTrampleEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_crop_trample();

  private:
  const ::df::plugin::WorldCropTrampleEvent& _internal_world_crop_trample() const;
  ::df::plugin::WorldCropTrampleEvent* PROTOBUF_NONNULL _internal_mutable_world_crop_trample();

  public:
  // .df.plugin.WorldLeavesDecayEvent world_leaves_decay = 77 [json_name = "worldLeavesDecay"];
  bool has_world_leaves_decay() const;
  private:
  bool _internal_has_world_leaves_decay() const;

  public:
  void clear_world_leaves_decay() ;
  const ::df::plugin::WorldLeavesDecayEvent& world_leaves_decay() const;
  [[nodiscard]] ::df::plugin::WorldLeavesDecayEvent* PROTOBUF_NULLABLE release_world_leaves_decay();
  ::df::plugin::WorldLeavesDecayEvent* PROTOBUF_NONNULL mutable_world_leaves_decay();
  void set_allocated_world_leaves_decay(::df::plugin::WorldLeavesDecayEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_leaves_decay(::df::plugin::WorldLeavesDecayEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldLeavesDecayEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_leaves_decay();

  private:
  const ::df::plugin::WorldLeavesDecayEvent& _internal_world_leaves_decay() const;
  ::df::plugin::WorldLeavesDecayEvent* PROTOBUF_NONNULL _internal_mutable_world_leaves_decay();

  public:
  // .df.plugin.WorldEntitySpawnEvent world_entity_spawn = 78 [json_name = "worldEntitySpawn"];
  bool has_world_entity_spawn() const;
  private:
  bool _internal_has_world_entity_spawn() const;

  public:
  void clear_world_entity_spawn() ;
  const ::df::plugin::WorldEntitySpawnEvent& world_entity_spawn() const;
  [[nodiscard]] ::df::plugin::WorldEntitySpawnEvent* PROTOBUF_NULLABLE release_world_entity_spawn();
  ::df::plugin::WorldEntitySpawnEvent* PROTOBUF_NONNULL mutable_world_entity_spawn();
  void set_allocated_world_entity_spawn(::df::plugin::WorldEntitySpawnEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_entity_spawn(::df::plugin::WorldEntitySpawnEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldEntitySpawnEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_entity_spawn();

  private:
  const ::df::plugin::WorldEntitySpawnEvent& _internal_world_entity_spawn() const;
  ::df::plugin::WorldEntitySpawnEvent* PROTOBUF_NONNULL _internal_mutable_world_entity_spawn();

  public:
  // .df.plugin.WorldEntityDespawnEvent world_entity_despawn = 79 [json_name = "worldEntityDespawn"];
  bool has_world_entity_despawn() const;
  private:
  bool _internal_has_world_entity_despawn() const;

  public:
  void clear_world_entity_despawn() ;
  const ::df::plugin::WorldEntityDespawnEvent& world_entity_despawn() const;
  [[nodiscard]] ::df::plugin::WorldEntityDespawnEvent* PROTOBUF_NULLABLE release_world_entity_despawn();
  ::df::plugin::WorldEntityDespawnEvent* PROTOBUF_NONNULL mutable_world_entity_despawn();
  void set_allocated_world_entity_despawn(::df::plugin::WorldEntityDespawnEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_entity_despawn(::df::plugin::WorldEntityDespawnEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldEntityDespawnEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_entity_despawn();

  private:
  const ::df::plugin::WorldEntityDespawnEvent& _internal_world_entity_despawn() const;
  ::df::plugin::WorldEntityDespawnEvent* PROTOBUF_NONNULL _internal_mutable_world_entity_despawn();

  public:
  // .df.plugin.WorldExplosionEvent world_explosion = 80 [json_name = "worldExplosion"];
  bool has_world_explosion() const;
  private:
  bool _internal_has_world_explosion() const;

  public:
  void clear_world_explosion() ;
  const ::df::plugin::WorldExplosionEvent& world_explosion() const;
  [[nodiscard]] ::df::plugin::WorldExplosionEvent* PROTOBUF_NULLABLE release_world_explosion();
  ::df::plugin::WorldExplosionEvent* PROTOBUF_NONNULL mutable_world_explosion();
  void set_allocated_world_explosion(::df::plugin::WorldExplosionEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_explosion(::df::plugin::WorldExplosionEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldExplosionEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_explosion();

  private:
  const ::df::plugin::WorldExplosionEvent& _internal_world_explosion() const;
  ::df::plugin::WorldExplosionEvent* PROTOBUF_NONNULL _internal_mutable_world_explosion();

  public:
  // .df.plugin.WorldCloseEvent world_close = 81 [json_name = "worldClose"];
  bool has_world_close() const;
  private:
  bool _internal_has_world_close() const;

  public:
  void clear_world_close() ;
  const ::df::plugin::WorldCloseEvent& world_close() const;
  [[nodiscard]] ::df::plugin::WorldCloseEvent* PROTOBUF_NULLABLE release_world_close();
  ::df::plugin::WorldCloseEvent* PROTOBUF_NONNULL mutable_world_close();
  void set_allocated_world_close(::df::plugin::WorldCloseEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_world_close(::df::plugin::WorldCloseEvent* PROTOBUF_NULLABLE value);
  ::df::plugin::WorldCloseEvent* PROTOBUF_NULLABLE unsafe_arena_release_world_close();

  private:
  const ::df::plugin::WorldCloseEvent& _internal_world_close() const;
  ::df::plugin::WorldCloseEvent* PROTOBUF_NONNULL _internal_mutable_world_close();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:df.plugin.EventEnvelope)
 private:
  class _Internal;
  void set_has_player_join();
  void set_has_player_quit();
  void set_has_player_move();
  void set_has_player_jump();
  void set_has_player_teleport();
  void set_has_player_change_world();
  void set_has_player_toggle_sprint();
  void set_has_player_toggle_sneak();
  void set_has_chat();
  void set_has_player_food_loss();
  void set_has_player_heal();
  void set_has_player_hurt();
  void set_has_player_death();
  void set_has_player_respawn();
  void set_has_player_skin_change();
  void set_has_player_fire_extinguish();
  void set_has_player_start_break();
  void set_has_block_break();
  void set_has_player_block_place();
  void set_has_player_block_pick();
  void set_has_player_item_use();
  void set_has_player_item_use_on_block();
  void set_has_player_item_use_on_entity();
  void set_has_player_item_release();
  void set_has_player_item_consume();
  void set_has_player_attack_entity();
  void set_has_player_experience_gain();
  void set_has_player_punch_air();
  void set_has_player_sign_edit();
  void set_has_player_lectern_page_turn();
  void set_has_player_item_damage();
  void set_has_player_item_pickup();
  void set_has_player_held_slot_change();
  void set_has_player_item_drop();
  void set_has_player_transfer();
  void set_has_command();
  void set_has_player_diagnostics();
  void set_has_world_liquid_flow();
  void set_has_world_liquid_decay();
  void set_has_world_liquid_harden();
  void set_has_world_sound();
  void set_has_world_fire_spread();
  void set_has_world_block_burn();
  void set_has_world_crop_trample();
  void set_has_world_leaves_decay();
  void set_has_world_entity_spawn();
  void set_has_world_entity_despawn();
  void set_has_world_explosion();
  void set_has_world_close();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 52,
                                   49, 88,
                                   13>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EventEnvelope& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr event_id_;
    int type_;
    bool expects_response_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_join_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_quit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_move_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_jump_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_teleport_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_change_world_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_toggle_sprint_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_toggle_sneak_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE chat_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_food_loss_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_heal_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_hurt_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_death_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_respawn_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_skin_change_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_fire_extinguish_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_start_break_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE block_break_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_block_place_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_block_pick_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_item_use_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_item_use_on_block_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_item_use_on_entity_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_item_release_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_item_consume_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_attack_entity_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_experience_gain_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_punch_air_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_sign_edit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_lectern_page_turn_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_item_damage_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_item_pickup_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_held_slot_change_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_item_drop_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_transfer_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE command_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_diagnostics_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_liquid_flow_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_liquid_decay_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_liquid_harden_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_sound_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_fire_spread_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_block_burn_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_crop_trample_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_leaves_decay_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_entity_spawn_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_entity_despawn_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_explosion_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE world_close_;
    } payload_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plugin_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EventEnvelope_class_data_;
// -------------------------------------------------------------------

class PluginToHost final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.PluginToHost) */ {
 public:
  inline PluginToHost() : PluginToHost(nullptr) {}
  ~PluginToHost() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PluginToHost* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PluginToHost));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PluginToHost(::google::protobuf::internal::ConstantInitialized);

  inline PluginToHost(const PluginToHost& from) : PluginToHost(nullptr, from) {}
  inline PluginToHost(PluginToHost&& from) noexcept
      : PluginToHost(nullptr, ::std::move(from)) {}
  inline PluginToHost& operator=(const PluginToHost& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginToHost& operator=(PluginToHost&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginToHost& default_instance() {
    return *reinterpret_cast<const PluginToHost*>(
        &_PluginToHost_default_instance_);
  }
  enum PayloadCase {
    kHello = 10,
    kSubscribe = 11,
    kServerInfo = 12,
    kActions = 20,
    kLog = 30,
    kEventResult = 40,
    PAYLOAD_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PluginToHost& a, PluginToHost& b) { a.Swap(&b); }
  inline void Swap(PluginToHost* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginToHost* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginToHost* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PluginToHost>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PluginToHost& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PluginToHost& from) { PluginToHost::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PluginToHost* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.PluginToHost"; }

  explicit PluginToHost(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PluginToHost(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PluginToHost& from);
  PluginToHost(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PluginToHost&& from) noexcept
      : PluginToHost(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPluginIdFieldNumber = 1,
    kHelloFieldNumber = 10,
    kSubscribeFieldNumber = 11,
    kServerInfoFieldNumber = 12,
    kActionsFieldNumber = 20,
    kLogFieldNumber = 30,
    kEventResultFieldNumber = 40,
  };
  // string plugin_id = 1 [json_name = "pluginId"];
  void clear_plugin_id() ;
  const ::std::string& plugin_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_plugin_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_plugin_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_plugin_id();
  void set_allocated_plugin_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_plugin_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_plugin_id();

  public:
  // .df.plugin.PluginHello hello = 10 [json_name = "hello"];
  bool has_hello() const;
  private:
  bool _internal_has_hello() const;

  public:
  void clear_hello() ;
  const ::df::plugin::PluginHello& hello() const;
  [[nodiscard]] ::df::plugin::PluginHello* PROTOBUF_NULLABLE release_hello();
  ::df::plugin::PluginHello* PROTOBUF_NONNULL mutable_hello();
  void set_allocated_hello(::df::plugin::PluginHello* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hello(::df::plugin::PluginHello* PROTOBUF_NULLABLE value);
  ::df::plugin::PluginHello* PROTOBUF_NULLABLE unsafe_arena_release_hello();

  private:
  const ::df::plugin::PluginHello& _internal_hello() const;
  ::df::plugin::PluginHello* PROTOBUF_NONNULL _internal_mutable_hello();

  public:
  // .df.plugin.EventSubscribe subscribe = 11 [json_name = "subscribe"];
  bool has_subscribe() const;
  private:
  bool _internal_has_subscribe() const;

  public:
  void clear_subscribe() ;
  const ::df::plugin::EventSubscribe& subscribe() const;
  [[nodiscard]] ::df::plugin::EventSubscribe* PROTOBUF_NULLABLE release_subscribe();
  ::df::plugin::EventSubscribe* PROTOBUF_NONNULL mutable_subscribe();
  void set_allocated_subscribe(::df::plugin::EventSubscribe* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subscribe(::df::plugin::EventSubscribe* PROTOBUF_NULLABLE value);
  ::df::plugin::EventSubscribe* PROTOBUF_NULLABLE unsafe_arena_release_subscribe();

  private:
  const ::df::plugin::EventSubscribe& _internal_subscribe() const;
  ::df::plugin::EventSubscribe* PROTOBUF_NONNULL _internal_mutable_subscribe();

  public:
  // .df.plugin.ServerInformationRequest server_info = 12 [json_name = "serverInfo"];
  bool has_server_info() const;
  private:
  bool _internal_has_server_info() const;

  public:
  void clear_server_info() ;
  const ::df::plugin::ServerInformationRequest& server_info() const;
  [[nodiscard]] ::df::plugin::ServerInformationRequest* PROTOBUF_NULLABLE release_server_info();
  ::df::plugin::ServerInformationRequest* PROTOBUF_NONNULL mutable_server_info();
  void set_allocated_server_info(::df::plugin::ServerInformationRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_server_info(::df::plugin::ServerInformationRequest* PROTOBUF_NULLABLE value);
  ::df::plugin::ServerInformationRequest* PROTOBUF_NULLABLE unsafe_arena_release_server_info();

  private:
  const ::df::plugin::ServerInformationRequest& _internal_server_info() const;
  ::df::plugin::ServerInformationRequest* PROTOBUF_NONNULL _internal_mutable_server_info();

  public:
  // .df.plugin.ActionBatch actions = 20 [json_name = "actions"];
  bool has_actions() const;
  private:
  bool _internal_has_actions() const;

  public:
  void clear_actions() ;
  const ::df::plugin::ActionBatch& actions() const;
  [[nodiscard]] ::df::plugin::ActionBatch* PROTOBUF_NULLABLE release_actions();
  ::df::plugin::ActionBatch* PROTOBUF_NONNULL mutable_actions();
  void set_allocated_actions(::df::plugin::ActionBatch* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_actions(::df::plugin::ActionBatch* PROTOBUF_NULLABLE value);
  ::df::plugin::ActionBatch* PROTOBUF_NULLABLE unsafe_arena_release_actions();

  private:
  const ::df::plugin::ActionBatch& _internal_actions() const;
  ::df::plugin::ActionBatch* PROTOBUF_NONNULL _internal_mutable_actions();

  public:
  // .df.plugin.LogMessage log = 30 [json_name = "log"];
  bool has_log() const;
  private:
  bool _internal_has_log() const;

  public:
  void clear_log() ;
  const ::df::plugin::LogMessage& log() const;
  [[nodiscard]] ::df::plugin::LogMessage* PROTOBUF_NULLABLE release_log();
  ::df::plugin::LogMessage* PROTOBUF_NONNULL mutable_log();
  void set_allocated_log(::df::plugin::LogMessage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_log(::df::plugin::LogMessage* PROTOBUF_NULLABLE value);
  ::df::plugin::LogMessage* PROTOBUF_NULLABLE unsafe_arena_release_log();

  private:
  const ::df::plugin::LogMessage& _internal_log() const;
  ::df::plugin::LogMessage* PROTOBUF_NONNULL _internal_mutable_log();

  public:
  // .df.plugin.EventResult event_result = 40 [json_name = "eventResult"];
  bool has_event_result() const;
  private:
  bool _internal_has_event_result() const;

  public:
  void clear_event_result() ;
  const ::df::plugin::EventResult& event_result() const;
  [[nodiscard]] ::df::plugin::EventResult* PROTOBUF_NULLABLE release_event_result();
  ::df::plugin::EventResult* PROTOBUF_NONNULL mutable_event_result();
  void set_allocated_event_result(::df::plugin::EventResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_event_result(::df::plugin::EventResult* PROTOBUF_NULLABLE value);
  ::df::plugin::EventResult* PROTOBUF_NULLABLE unsafe_arena_release_event_result();

  private:
  const ::df::plugin::EventResult& _internal_event_result() const;
  ::df::plugin::EventResult* PROTOBUF_NONNULL _internal_mutable_event_result();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:df.plugin.PluginToHost)
 private:
  class _Internal;
  void set_has_hello();
  void set_has_subscribe();
  void set_has_server_info();
  void set_has_actions();
  void set_has_log();
  void set_has_event_result();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 7,
                                   6, 40,
                                   7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PluginToHost& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr plugin_id_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE hello_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE subscribe_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE server_info_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE actions_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE log_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE event_result_;
    } payload_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plugin_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PluginToHost_class_data_;
// -------------------------------------------------------------------

class HostToPlugin final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.HostToPlugin) */ {
 public:
  inline HostToPlugin() : HostToPlugin(nullptr) {}
  ~HostToPlugin() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HostToPlugin* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HostToPlugin));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HostToPlugin(::google::protobuf::internal::ConstantInitialized);

  inline HostToPlugin(const HostToPlugin& from) : HostToPlugin(nullptr, from) {}
  inline HostToPlugin(HostToPlugin&& from) noexcept
      : HostToPlugin(nullptr, ::std::move(from)) {}
  inline HostToPlugin& operator=(const HostToPlugin& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostToPlugin& operator=(HostToPlugin&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostToPlugin& default_instance() {
    return *reinterpret_cast<const HostToPlugin*>(
        &_HostToPlugin_default_instance_);
  }
  enum PayloadCase {
    kHello = 10,
    kShutdown = 11,
    kServerInfo = 12,
    kEvent = 20,
    kActionResult = 21,
    PAYLOAD_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(HostToPlugin& a, HostToPlugin& b) { a.Swap(&b); }
  inline void Swap(HostToPlugin* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostToPlugin* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostToPlugin* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HostToPlugin>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HostToPlugin& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HostToPlugin& from) { HostToPlugin::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HostToPlugin* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.HostToPlugin"; }

  explicit HostToPlugin(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HostToPlugin(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HostToPlugin& from);
  HostToPlugin(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HostToPlugin&& from) noexcept
      : HostToPlugin(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPluginIdFieldNumber = 1,
    kHelloFieldNumber = 10,
    kShutdownFieldNumber = 11,
    kServerInfoFieldNumber = 12,
    kEventFieldNumber = 20,
    kActionResultFieldNumber = 21,
  };
  // string plugin_id = 1 [json_name = "pluginId"];
  void clear_plugin_id() ;
  const ::std::string& plugin_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_plugin_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_plugin_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_plugin_id();
  void set_allocated_plugin_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_plugin_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_plugin_id();

  public:
  // .df.plugin.HostHello hello = 10 [json_name = "hello"];
  bool has_hello() const;
  private:
  bool _internal_has_hello() const;

  public:
  void clear_hello() ;
  const ::df::plugin::HostHello& hello() const;
  [[nodiscard]] ::df::plugin::HostHello* PROTOBUF_NULLABLE release_hello();
  ::df::plugin::HostHello* PROTOBUF_NONNULL mutable_hello();
  void set_allocated_hello(::df::plugin::HostHello* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hello(::df::plugin::HostHello* PROTOBUF_NULLABLE value);
  ::df::plugin::HostHello* PROTOBUF_NULLABLE unsafe_arena_release_hello();

  private:
  const ::df::plugin::HostHello& _internal_hello() const;
  ::df::plugin::HostHello* PROTOBUF_NONNULL _internal_mutable_hello();

  public:
  // .df.plugin.HostShutdown shutdown = 11 [json_name = "shutdown"];
  bool has_shutdown() const;
  private:
  bool _internal_has_shutdown() const;

  public:
  void clear_shutdown() ;
  const ::df::plugin::HostShutdown& shutdown() const;
  [[nodiscard]] ::df::plugin::HostShutdown* PROTOBUF_NULLABLE release_shutdown();
  ::df::plugin::HostShutdown* PROTOBUF_NONNULL mutable_shutdown();
  void set_allocated_shutdown(::df::plugin::HostShutdown* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shutdown(::df::plugin::HostShutdown* PROTOBUF_NULLABLE value);
  ::df::plugin::HostShutdown* PROTOBUF_NULLABLE unsafe_arena_release_shutdown();

  private:
  const ::df::plugin::HostShutdown& _internal_shutdown() const;
  ::df::plugin::HostShutdown* PROTOBUF_NONNULL _internal_mutable_shutdown();

  public:
  // .df.plugin.ServerInformationResponse server_info = 12 [json_name = "serverInfo"];
  bool has_server_info() const;
  private:
  bool _internal_has_server_info() const;

  public:
  void clear_server_info() ;
  const ::df::plugin::ServerInformationResponse& server_info() const;
  [[nodiscard]] ::df::plugin::ServerInformationResponse* PROTOBUF_NULLABLE release_server_info();
  ::df::plugin::ServerInformationResponse* PROTOBUF_NONNULL mutable_server_info();
  void set_allocated_server_info(::df::plugin::ServerInformationResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_server_info(::df::plugin::ServerInformationResponse* PROTOBUF_NULLABLE value);
  ::df::plugin::ServerInformationResponse* PROTOBUF_NULLABLE unsafe_arena_release_server_info();

  private:
  const ::df::plugin::ServerInformationResponse& _internal_server_info() const;
  ::df::plugin::ServerInformationResponse* PROTOBUF_NONNULL _internal_mutable_server_info();

  public:
  // .df.plugin.EventEnvelope event = 20 [json_name = "event"];
  bool has_event() const;
  private:
  bool _internal_has_event() const;

  public:
  void clear_event() ;
  const ::df::plugin::EventEnvelope& event() const;
  [[nodiscard]] ::df::plugin::EventEnvelope* PROTOBUF_NULLABLE release_event();
  ::df::plugin::EventEnvelope* PROTOBUF_NONNULL mutable_event();
  void set_allocated_event(::df::plugin::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_event(::df::plugin::EventEnvelope* PROTOBUF_NULLABLE value);
  ::df::plugin::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_event();

  private:
  const ::df::plugin::EventEnvelope& _internal_event() const;
  ::df::plugin::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_event();

  public:
  // .df.plugin.ActionResult action_result = 21 [json_name = "actionResult"];
  bool has_action_result() const;
  private:
  bool _internal_has_action_result() const;

  public:
  void clear_action_result() ;
  const ::df::plugin::ActionResult& action_result() const;
  [[nodiscard]] ::df::plugin::ActionResult* PROTOBUF_NULLABLE release_action_result();
  ::df::plugin::ActionResult* PROTOBUF_NONNULL mutable_action_result();
  void set_allocated_action_result(::df::plugin::ActionResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_action_result(::df::plugin::ActionResult* PROTOBUF_NULLABLE value);
  ::df::plugin::ActionResult* PROTOBUF_NULLABLE unsafe_arena_release_action_result();

  private:
  const ::df::plugin::ActionResult& _internal_action_result() const;
  ::df::plugin::ActionResult* PROTOBUF_NONNULL _internal_mutable_action_result();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:df.plugin.HostToPlugin)
 private:
  class _Internal;
  void set_has_hello();
  void set_has_shutdown();
  void set_has_server_info();
  void set_has_event();
  void set_has_action_result();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 6,
                                   5, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HostToPlugin& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr plugin_id_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE hello_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE shutdown_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE server_info_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE event_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE action_result_;
    } payload_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plugin_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HostToPlugin_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// HostToPlugin

// string plugin_id = 1 [json_name = "pluginId"];
inline void HostToPlugin::clear_plugin_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plugin_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& HostToPlugin::plugin_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.HostToPlugin.plugin_id)
  return _internal_plugin_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HostToPlugin::set_plugin_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.plugin_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.HostToPlugin.plugin_id)
}
inline ::std::string* PROTOBUF_NONNULL HostToPlugin::mutable_plugin_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:df.plugin.HostToPlugin.plugin_id)
  return _s;
}
inline const ::std::string& HostToPlugin::_internal_plugin_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.plugin_id_.Get();
}
inline void HostToPlugin::_internal_set_plugin_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plugin_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HostToPlugin::_internal_mutable_plugin_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.plugin_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HostToPlugin::release_plugin_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.HostToPlugin.plugin_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.plugin_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.plugin_id_.Set("", GetArena());
  }
  return released;
}
inline void HostToPlugin::set_allocated_plugin_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.plugin_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.plugin_id_.IsDefault()) {
    _impl_.plugin_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.HostToPlugin.plugin_id)
}

// .df.plugin.HostHello hello = 10 [json_name = "hello"];
inline bool HostToPlugin::has_hello() const {
  return payload_case() == kHello;
}
inline bool HostToPlugin::_internal_has_hello() const {
  return payload_case() == kHello;
}
inline void HostToPlugin::set_has_hello() {
  _impl_._oneof_case_[0] = kHello;
}
inline void HostToPlugin::clear_hello() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kHello) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.hello_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.hello_);
    }
    clear_has_payload();
  }
}
inline ::df::plugin::HostHello* PROTOBUF_NULLABLE HostToPlugin::release_hello() {
  // @@protoc_insertion_point(field_release:df.plugin.HostToPlugin.hello)
  if (payload_case() == kHello) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::HostHello*>(_impl_.payload_.hello_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.hello_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::HostHello& HostToPlugin::_internal_hello() const {
  return payload_case() == kHello ? static_cast<const ::df::plugin::HostHello&>(*reinterpret_cast<::df::plugin::HostHello*>(_impl_.payload_.hello_))
                     : reinterpret_cast<const ::df::plugin::HostHello&>(::df::plugin::_HostHello_default_instance_);
}
inline const ::df::plugin::HostHello& HostToPlugin::hello() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.HostToPlugin.hello)
  return _internal_hello();
}
inline ::df::plugin::HostHello* PROTOBUF_NULLABLE HostToPlugin::unsafe_arena_release_hello() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.HostToPlugin.hello)
  if (payload_case() == kHello) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::HostHello*>(_impl_.payload_.hello_);
    _impl_.payload_.hello_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HostToPlugin::unsafe_arena_set_allocated_hello(
    ::df::plugin::HostHello* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_hello();
    _impl_.payload_.hello_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.HostToPlugin.hello)
}
inline ::df::plugin::HostHello* PROTOBUF_NONNULL HostToPlugin::_internal_mutable_hello() {
  if (payload_case() != kHello) {
    clear_payload();
    set_has_hello();
    _impl_.payload_.hello_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::HostHello>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::HostHello*>(_impl_.payload_.hello_);
}
inline ::df::plugin::HostHello* PROTOBUF_NONNULL HostToPlugin::mutable_hello()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::HostHello* _msg = _internal_mutable_hello();
  // @@protoc_insertion_point(field_mutable:df.plugin.HostToPlugin.hello)
  return _msg;
}

// .df.plugin.HostShutdown shutdown = 11 [json_name = "shutdown"];
inline bool HostToPlugin::has_shutdown() const {
  return payload_case() == kShutdown;
}
inline bool HostToPlugin::_internal_has_shutdown() const {
  return payload_case() == kShutdown;
}
inline void HostToPlugin::set_has_shutdown() {
  _impl_._oneof_case_[0] = kShutdown;
}
inline void HostToPlugin::clear_shutdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kShutdown) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.shutdown_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.shutdown_);
    }
    clear_has_payload();
  }
}
inline ::df::plugin::HostShutdown* PROTOBUF_NULLABLE HostToPlugin::release_shutdown() {
  // @@protoc_insertion_point(field_release:df.plugin.HostToPlugin.shutdown)
  if (payload_case() == kShutdown) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::HostShutdown*>(_impl_.payload_.shutdown_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.shutdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::HostShutdown& HostToPlugin::_internal_shutdown() const {
  return payload_case() == kShutdown ? static_cast<const ::df::plugin::HostShutdown&>(*reinterpret_cast<::df::plugin::HostShutdown*>(_impl_.payload_.shutdown_))
                     : reinterpret_cast<const ::df::plugin::HostShutdown&>(::df::plugin::_HostShutdown_default_instance_);
}
inline const ::df::plugin::HostShutdown& HostToPlugin::shutdown() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.HostToPlugin.shutdown)
  return _internal_shutdown();
}
inline ::df::plugin::HostShutdown* PROTOBUF_NULLABLE HostToPlugin::unsafe_arena_release_shutdown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.HostToPlugin.shutdown)
  if (payload_case() == kShutdown) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::HostShutdown*>(_impl_.payload_.shutdown_);
    _impl_.payload_.shutdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HostToPlugin::unsafe_arena_set_allocated_shutdown(
    ::df::plugin::HostShutdown* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_shutdown();
    _impl_.payload_.shutdown_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.HostToPlugin.shutdown)
}
inline ::df::plugin::HostShutdown* PROTOBUF_NONNULL HostToPlugin::_internal_mutable_shutdown() {
  if (payload_case() != kShutdown) {
    clear_payload();
    set_has_shutdown();
    _impl_.payload_.shutdown_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::HostShutdown>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::HostShutdown*>(_impl_.payload_.shutdown_);
}
inline ::df::plugin::HostShutdown* PROTOBUF_NONNULL HostToPlugin::mutable_shutdown()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::HostShutdown* _msg = _internal_mutable_shutdown();
  // @@protoc_insertion_point(field_mutable:df.plugin.HostToPlugin.shutdown)
  return _msg;
}

// .df.plugin.ServerInformationResponse server_info = 12 [json_name = "serverInfo"];
inline bool HostToPlugin::has_server_info() const {
  return payload_case() == kServerInfo;
}
inline bool HostToPlugin::_internal_has_server_info() const {
  return payload_case() == kServerInfo;
}
inline void HostToPlugin::set_has_server_info() {
  _impl_._oneof_case_[0] = kServerInfo;
}
inline void HostToPlugin::clear_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kServerInfo) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.server_info_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.server_info_);
    }
    clear_has_payload();
  }
}
inline ::df::plugin::ServerInformationResponse* PROTOBUF_NULLABLE HostToPlugin::release_server_info() {
  // @@protoc_insertion_point(field_release:df.plugin.HostToPlugin.server_info)
  if (payload_case() == kServerInfo) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::ServerInformationResponse*>(_impl_.payload_.server_info_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.server_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::ServerInformationResponse& HostToPlugin::_internal_server_info() const {
  return payload_case() == kServerInfo ? static_cast<const ::df::plugin::ServerInformationResponse&>(*reinterpret_cast<::df::plugin::ServerInformationResponse*>(_impl_.payload_.server_info_))
                     : reinterpret_cast<const ::df::plugin::ServerInformationResponse&>(::df::plugin::_ServerInformationResponse_default_instance_);
}
inline const ::df::plugin::ServerInformationResponse& HostToPlugin::server_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.HostToPlugin.server_info)
  return _internal_server_info();
}
inline ::df::plugin::ServerInformationResponse* PROTOBUF_NULLABLE HostToPlugin::unsafe_arena_release_server_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.HostToPlugin.server_info)
  if (payload_case() == kServerInfo) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::ServerInformationResponse*>(_impl_.payload_.server_info_);
    _impl_.payload_.server_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HostToPlugin::unsafe_arena_set_allocated_server_info(
    ::df::plugin::ServerInformationResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_server_info();
    _impl_.payload_.server_info_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.HostToPlugin.server_info)
}
inline ::df::plugin::ServerInformationResponse* PROTOBUF_NONNULL HostToPlugin::_internal_mutable_server_info() {
  if (payload_case() != kServerInfo) {
    clear_payload();
    set_has_server_info();
    _impl_.payload_.server_info_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::ServerInformationResponse>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::ServerInformationResponse*>(_impl_.payload_.server_info_);
}
inline ::df::plugin::ServerInformationResponse* PROTOBUF_NONNULL HostToPlugin::mutable_server_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::ServerInformationResponse* _msg = _internal_mutable_server_info();
  // @@protoc_insertion_point(field_mutable:df.plugin.HostToPlugin.server_info)
  return _msg;
}

// .df.plugin.EventEnvelope event = 20 [json_name = "event"];
inline bool HostToPlugin::has_event() const {
  return payload_case() == kEvent;
}
inline bool HostToPlugin::_internal_has_event() const {
  return payload_case() == kEvent;
}
inline void HostToPlugin::set_has_event() {
  _impl_._oneof_case_[0] = kEvent;
}
inline void HostToPlugin::clear_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kEvent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.event_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.event_);
    }
    clear_has_payload();
  }
}
inline ::df::plugin::EventEnvelope* PROTOBUF_NULLABLE HostToPlugin::release_event() {
  // @@protoc_insertion_point(field_release:df.plugin.HostToPlugin.event)
  if (payload_case() == kEvent) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::EventEnvelope*>(_impl_.payload_.event_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::EventEnvelope& HostToPlugin::_internal_event() const {
  return payload_case() == kEvent ? static_cast<const ::df::plugin::EventEnvelope&>(*reinterpret_cast<::df::plugin::EventEnvelope*>(_impl_.payload_.event_))
                     : reinterpret_cast<const ::df::plugin::EventEnvelope&>(::df::plugin::_EventEnvelope_default_instance_);
}
inline const ::df::plugin::EventEnvelope& HostToPlugin::event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.HostToPlugin.event)
  return _internal_event();
}
inline ::df::plugin::EventEnvelope* PROTOBUF_NULLABLE HostToPlugin::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.HostToPlugin.event)
  if (payload_case() == kEvent) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::EventEnvelope*>(_impl_.payload_.event_);
    _impl_.payload_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HostToPlugin::unsafe_arena_set_allocated_event(
    ::df::plugin::EventEnvelope* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_event();
    _impl_.payload_.event_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.HostToPlugin.event)
}
inline ::df::plugin::EventEnvelope* PROTOBUF_NONNULL HostToPlugin::_internal_mutable_event() {
  if (payload_case() != kEvent) {
    clear_payload();
    set_has_event();
    _impl_.payload_.event_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::EventEnvelope>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::EventEnvelope*>(_impl_.payload_.event_);
}
inline ::df::plugin::EventEnvelope* PROTOBUF_NONNULL HostToPlugin::mutable_event()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::EventEnvelope* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:df.plugin.HostToPlugin.event)
  return _msg;
}

// .df.plugin.ActionResult action_result = 21 [json_name = "actionResult"];
inline bool HostToPlugin::has_action_result() const {
  return payload_case() == kActionResult;
}
inline bool HostToPlugin::_internal_has_action_result() const {
  return payload_case() == kActionResult;
}
inline void HostToPlugin::set_has_action_result() {
  _impl_._oneof_case_[0] = kActionResult;
}
inline ::df::plugin::ActionResult* PROTOBUF_NULLABLE HostToPlugin::release_action_result() {
  // @@protoc_insertion_point(field_release:df.plugin.HostToPlugin.action_result)
  if (payload_case() == kActionResult) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::ActionResult*>(_impl_.payload_.action_result_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.action_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::ActionResult& HostToPlugin::_internal_action_result() const {
  return payload_case() == kActionResult ? static_cast<const ::df::plugin::ActionResult&>(*reinterpret_cast<::df::plugin::ActionResult*>(_impl_.payload_.action_result_))
                     : reinterpret_cast<const ::df::plugin::ActionResult&>(::df::plugin::_ActionResult_default_instance_);
}
inline const ::df::plugin::ActionResult& HostToPlugin::action_result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.HostToPlugin.action_result)
  return _internal_action_result();
}
inline ::df::plugin::ActionResult* PROTOBUF_NULLABLE HostToPlugin::unsafe_arena_release_action_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.HostToPlugin.action_result)
  if (payload_case() == kActionResult) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::ActionResult*>(_impl_.payload_.action_result_);
    _impl_.payload_.action_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HostToPlugin::unsafe_arena_set_allocated_action_result(
    ::df::plugin::ActionResult* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_action_result();
    _impl_.payload_.action_result_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.HostToPlugin.action_result)
}
inline ::df::plugin::ActionResult* PROTOBUF_NONNULL HostToPlugin::_internal_mutable_action_result() {
  if (payload_case() != kActionResult) {
    clear_payload();
    set_has_action_result();
    _impl_.payload_.action_result_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::ActionResult>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::ActionResult*>(_impl_.payload_.action_result_);
}
inline ::df::plugin::ActionResult* PROTOBUF_NONNULL HostToPlugin::mutable_action_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::ActionResult* _msg = _internal_mutable_action_result();
  // @@protoc_insertion_point(field_mutable:df.plugin.HostToPlugin.action_result)
  return _msg;
}

inline bool HostToPlugin::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void HostToPlugin::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline HostToPlugin::PayloadCase HostToPlugin::payload_case() const {
  return HostToPlugin::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerInformationRequest

// -------------------------------------------------------------------

// ServerInformationResponse

// repeated string plugins = 1 [json_name = "plugins"];
inline int ServerInformationResponse::_internal_plugins_size() const {
  return _internal_plugins().size();
}
inline int ServerInformationResponse::plugins_size() const {
  return _internal_plugins_size();
}
inline void ServerInformationResponse::clear_plugins() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plugins_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL ServerInformationResponse::add_plugins()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_plugins()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:df.plugin.ServerInformationResponse.plugins)
  return _s;
}
inline const ::std::string& ServerInformationResponse::plugins(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.ServerInformationResponse.plugins)
  return _internal_plugins().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL ServerInformationResponse::mutable_plugins(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:df.plugin.ServerInformationResponse.plugins)
  return _internal_mutable_plugins()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ServerInformationResponse::set_plugins(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_plugins()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:df.plugin.ServerInformationResponse.plugins)
}
template <typename Arg_, typename... Args_>
inline void ServerInformationResponse::add_plugins(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_plugins(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:df.plugin.ServerInformationResponse.plugins)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& ServerInformationResponse::plugins()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:df.plugin.ServerInformationResponse.plugins)
  return _internal_plugins();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ServerInformationResponse::mutable_plugins() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:df.plugin.ServerInformationResponse.plugins)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_plugins();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ServerInformationResponse::_internal_plugins() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.plugins_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ServerInformationResponse::_internal_mutable_plugins() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.plugins_;
}

// -------------------------------------------------------------------

// HostHello

// string api_version = 1 [json_name = "apiVersion"];
inline void HostHello::clear_api_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.api_version_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& HostHello::api_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.HostHello.api_version)
  return _internal_api_version();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HostHello::set_api_version(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.api_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.HostHello.api_version)
}
inline ::std::string* PROTOBUF_NONNULL HostHello::mutable_api_version()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_api_version();
  // @@protoc_insertion_point(field_mutable:df.plugin.HostHello.api_version)
  return _s;
}
inline const ::std::string& HostHello::_internal_api_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.api_version_.Get();
}
inline void HostHello::_internal_set_api_version(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.api_version_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HostHello::_internal_mutable_api_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.api_version_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HostHello::release_api_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.HostHello.api_version)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.api_version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.api_version_.Set("", GetArena());
  }
  return released;
}
inline void HostHello::set_allocated_api_version(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.api_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.api_version_.IsDefault()) {
    _impl_.api_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.HostHello.api_version)
}

// -------------------------------------------------------------------

// HostShutdown

// string reason = 1 [json_name = "reason"];
inline void HostShutdown::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& HostShutdown::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.HostShutdown.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HostShutdown::set_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.HostShutdown.reason)
}
inline ::std::string* PROTOBUF_NONNULL HostShutdown::mutable_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:df.plugin.HostShutdown.reason)
  return _s;
}
inline const ::std::string& HostShutdown::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void HostShutdown::_internal_set_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HostShutdown::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HostShutdown::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.HostShutdown.reason)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reason_.Set("", GetArena());
  }
  return released;
}
inline void HostShutdown::set_allocated_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.HostShutdown.reason)
}

// -------------------------------------------------------------------

// EventEnvelope

// string event_id = 1 [json_name = "eventId"];
inline void EventEnvelope::clear_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& EventEnvelope::event_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.event_id)
  return _internal_event_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EventEnvelope::set_event_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.event_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.EventEnvelope.event_id)
}
inline ::std::string* PROTOBUF_NONNULL EventEnvelope::mutable_event_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.event_id)
  return _s;
}
inline const ::std::string& EventEnvelope::_internal_event_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.event_id_.Get();
}
inline void EventEnvelope::_internal_set_event_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.event_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EventEnvelope::release_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.event_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.event_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.event_id_.Set("", GetArena());
  }
  return released;
}
inline void EventEnvelope::set_allocated_event_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.event_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.EventEnvelope.event_id)
}

// .df.plugin.EventType type = 2 [json_name = "type"];
inline void EventEnvelope::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::df::plugin::EventType EventEnvelope::type() const {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.type)
  return _internal_type();
}
inline void EventEnvelope::set_type(::df::plugin::EventType value) {
  _internal_set_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:df.plugin.EventEnvelope.type)
}
inline ::df::plugin::EventType EventEnvelope::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::df::plugin::EventType>(_impl_.type_);
}
inline void EventEnvelope::_internal_set_type(::df::plugin::EventType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// bool expects_response = 3 [json_name = "expectsResponse"];
inline void EventEnvelope::clear_expects_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expects_response_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool EventEnvelope::expects_response() const {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.expects_response)
  return _internal_expects_response();
}
inline void EventEnvelope::set_expects_response(bool value) {
  _internal_set_expects_response(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:df.plugin.EventEnvelope.expects_response)
}
inline bool EventEnvelope::_internal_expects_response() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expects_response_;
}
inline void EventEnvelope::_internal_set_expects_response(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expects_response_ = value;
}

// .df.plugin.PlayerJoinEvent player_join = 10 [json_name = "playerJoin"];
inline bool EventEnvelope::has_player_join() const {
  return payload_case() == kPlayerJoin;
}
inline bool EventEnvelope::_internal_has_player_join() const {
  return payload_case() == kPlayerJoin;
}
inline void EventEnvelope::set_has_player_join() {
  _impl_._oneof_case_[0] = kPlayerJoin;
}
inline ::df::plugin::PlayerJoinEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_join() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_join)
  if (payload_case() == kPlayerJoin) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerJoinEvent*>(_impl_.payload_.player_join_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerJoinEvent& EventEnvelope::_internal_player_join() const {
  return payload_case() == kPlayerJoin ? static_cast<const ::df::plugin::PlayerJoinEvent&>(*reinterpret_cast<::df::plugin::PlayerJoinEvent*>(_impl_.payload_.player_join_))
                     : reinterpret_cast<const ::df::plugin::PlayerJoinEvent&>(::df::plugin::_PlayerJoinEvent_default_instance_);
}
inline const ::df::plugin::PlayerJoinEvent& EventEnvelope::player_join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_join)
  return _internal_player_join();
}
inline ::df::plugin::PlayerJoinEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_join)
  if (payload_case() == kPlayerJoin) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerJoinEvent*>(_impl_.payload_.player_join_);
    _impl_.payload_.player_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_join(
    ::df::plugin::PlayerJoinEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_join();
    _impl_.payload_.player_join_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_join)
}
inline ::df::plugin::PlayerJoinEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_join() {
  if (payload_case() != kPlayerJoin) {
    clear_payload();
    set_has_player_join();
    _impl_.payload_.player_join_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerJoinEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerJoinEvent*>(_impl_.payload_.player_join_);
}
inline ::df::plugin::PlayerJoinEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_join()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerJoinEvent* _msg = _internal_mutable_player_join();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_join)
  return _msg;
}

// .df.plugin.PlayerQuitEvent player_quit = 11 [json_name = "playerQuit"];
inline bool EventEnvelope::has_player_quit() const {
  return payload_case() == kPlayerQuit;
}
inline bool EventEnvelope::_internal_has_player_quit() const {
  return payload_case() == kPlayerQuit;
}
inline void EventEnvelope::set_has_player_quit() {
  _impl_._oneof_case_[0] = kPlayerQuit;
}
inline ::df::plugin::PlayerQuitEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_quit() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_quit)
  if (payload_case() == kPlayerQuit) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerQuitEvent*>(_impl_.payload_.player_quit_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_quit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerQuitEvent& EventEnvelope::_internal_player_quit() const {
  return payload_case() == kPlayerQuit ? static_cast<const ::df::plugin::PlayerQuitEvent&>(*reinterpret_cast<::df::plugin::PlayerQuitEvent*>(_impl_.payload_.player_quit_))
                     : reinterpret_cast<const ::df::plugin::PlayerQuitEvent&>(::df::plugin::_PlayerQuitEvent_default_instance_);
}
inline const ::df::plugin::PlayerQuitEvent& EventEnvelope::player_quit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_quit)
  return _internal_player_quit();
}
inline ::df::plugin::PlayerQuitEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_quit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_quit)
  if (payload_case() == kPlayerQuit) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerQuitEvent*>(_impl_.payload_.player_quit_);
    _impl_.payload_.player_quit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_quit(
    ::df::plugin::PlayerQuitEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_quit();
    _impl_.payload_.player_quit_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_quit)
}
inline ::df::plugin::PlayerQuitEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_quit() {
  if (payload_case() != kPlayerQuit) {
    clear_payload();
    set_has_player_quit();
    _impl_.payload_.player_quit_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerQuitEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerQuitEvent*>(_impl_.payload_.player_quit_);
}
inline ::df::plugin::PlayerQuitEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_quit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerQuitEvent* _msg = _internal_mutable_player_quit();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_quit)
  return _msg;
}

// .df.plugin.PlayerMoveEvent player_move = 12 [json_name = "playerMove"];
inline bool EventEnvelope::has_player_move() const {
  return payload_case() == kPlayerMove;
}
inline bool EventEnvelope::_internal_has_player_move() const {
  return payload_case() == kPlayerMove;
}
inline void EventEnvelope::set_has_player_move() {
  _impl_._oneof_case_[0] = kPlayerMove;
}
inline ::df::plugin::PlayerMoveEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_move() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_move)
  if (payload_case() == kPlayerMove) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerMoveEvent*>(_impl_.payload_.player_move_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerMoveEvent& EventEnvelope::_internal_player_move() const {
  return payload_case() == kPlayerMove ? static_cast<const ::df::plugin::PlayerMoveEvent&>(*reinterpret_cast<::df::plugin::PlayerMoveEvent*>(_impl_.payload_.player_move_))
                     : reinterpret_cast<const ::df::plugin::PlayerMoveEvent&>(::df::plugin::_PlayerMoveEvent_default_instance_);
}
inline const ::df::plugin::PlayerMoveEvent& EventEnvelope::player_move() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_move)
  return _internal_player_move();
}
inline ::df::plugin::PlayerMoveEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_move)
  if (payload_case() == kPlayerMove) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerMoveEvent*>(_impl_.payload_.player_move_);
    _impl_.payload_.player_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_move(
    ::df::plugin::PlayerMoveEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_move();
    _impl_.payload_.player_move_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_move)
}
inline ::df::plugin::PlayerMoveEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_move() {
  if (payload_case() != kPlayerMove) {
    clear_payload();
    set_has_player_move();
    _impl_.payload_.player_move_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerMoveEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerMoveEvent*>(_impl_.payload_.player_move_);
}
inline ::df::plugin::PlayerMoveEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_move()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerMoveEvent* _msg = _internal_mutable_player_move();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_move)
  return _msg;
}

// .df.plugin.PlayerJumpEvent player_jump = 13 [json_name = "playerJump"];
inline bool EventEnvelope::has_player_jump() const {
  return payload_case() == kPlayerJump;
}
inline bool EventEnvelope::_internal_has_player_jump() const {
  return payload_case() == kPlayerJump;
}
inline void EventEnvelope::set_has_player_jump() {
  _impl_._oneof_case_[0] = kPlayerJump;
}
inline ::df::plugin::PlayerJumpEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_jump() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_jump)
  if (payload_case() == kPlayerJump) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerJumpEvent*>(_impl_.payload_.player_jump_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_jump_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerJumpEvent& EventEnvelope::_internal_player_jump() const {
  return payload_case() == kPlayerJump ? static_cast<const ::df::plugin::PlayerJumpEvent&>(*reinterpret_cast<::df::plugin::PlayerJumpEvent*>(_impl_.payload_.player_jump_))
                     : reinterpret_cast<const ::df::plugin::PlayerJumpEvent&>(::df::plugin::_PlayerJumpEvent_default_instance_);
}
inline const ::df::plugin::PlayerJumpEvent& EventEnvelope::player_jump() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_jump)
  return _internal_player_jump();
}
inline ::df::plugin::PlayerJumpEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_jump() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_jump)
  if (payload_case() == kPlayerJump) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerJumpEvent*>(_impl_.payload_.player_jump_);
    _impl_.payload_.player_jump_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_jump(
    ::df::plugin::PlayerJumpEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_jump();
    _impl_.payload_.player_jump_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_jump)
}
inline ::df::plugin::PlayerJumpEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_jump() {
  if (payload_case() != kPlayerJump) {
    clear_payload();
    set_has_player_jump();
    _impl_.payload_.player_jump_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerJumpEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerJumpEvent*>(_impl_.payload_.player_jump_);
}
inline ::df::plugin::PlayerJumpEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_jump()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerJumpEvent* _msg = _internal_mutable_player_jump();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_jump)
  return _msg;
}

// .df.plugin.PlayerTeleportEvent player_teleport = 14 [json_name = "playerTeleport"];
inline bool EventEnvelope::has_player_teleport() const {
  return payload_case() == kPlayerTeleport;
}
inline bool EventEnvelope::_internal_has_player_teleport() const {
  return payload_case() == kPlayerTeleport;
}
inline void EventEnvelope::set_has_player_teleport() {
  _impl_._oneof_case_[0] = kPlayerTeleport;
}
inline ::df::plugin::PlayerTeleportEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_teleport() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_teleport)
  if (payload_case() == kPlayerTeleport) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerTeleportEvent*>(_impl_.payload_.player_teleport_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_teleport_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerTeleportEvent& EventEnvelope::_internal_player_teleport() const {
  return payload_case() == kPlayerTeleport ? static_cast<const ::df::plugin::PlayerTeleportEvent&>(*reinterpret_cast<::df::plugin::PlayerTeleportEvent*>(_impl_.payload_.player_teleport_))
                     : reinterpret_cast<const ::df::plugin::PlayerTeleportEvent&>(::df::plugin::_PlayerTeleportEvent_default_instance_);
}
inline const ::df::plugin::PlayerTeleportEvent& EventEnvelope::player_teleport() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_teleport)
  return _internal_player_teleport();
}
inline ::df::plugin::PlayerTeleportEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_teleport() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_teleport)
  if (payload_case() == kPlayerTeleport) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerTeleportEvent*>(_impl_.payload_.player_teleport_);
    _impl_.payload_.player_teleport_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_teleport(
    ::df::plugin::PlayerTeleportEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_teleport();
    _impl_.payload_.player_teleport_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_teleport)
}
inline ::df::plugin::PlayerTeleportEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_teleport() {
  if (payload_case() != kPlayerTeleport) {
    clear_payload();
    set_has_player_teleport();
    _impl_.payload_.player_teleport_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerTeleportEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerTeleportEvent*>(_impl_.payload_.player_teleport_);
}
inline ::df::plugin::PlayerTeleportEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_teleport()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerTeleportEvent* _msg = _internal_mutable_player_teleport();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_teleport)
  return _msg;
}

// .df.plugin.PlayerChangeWorldEvent player_change_world = 15 [json_name = "playerChangeWorld"];
inline bool EventEnvelope::has_player_change_world() const {
  return payload_case() == kPlayerChangeWorld;
}
inline bool EventEnvelope::_internal_has_player_change_world() const {
  return payload_case() == kPlayerChangeWorld;
}
inline void EventEnvelope::set_has_player_change_world() {
  _impl_._oneof_case_[0] = kPlayerChangeWorld;
}
inline ::df::plugin::PlayerChangeWorldEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_change_world() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_change_world)
  if (payload_case() == kPlayerChangeWorld) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerChangeWorldEvent*>(_impl_.payload_.player_change_world_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_change_world_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerChangeWorldEvent& EventEnvelope::_internal_player_change_world() const {
  return payload_case() == kPlayerChangeWorld ? static_cast<const ::df::plugin::PlayerChangeWorldEvent&>(*reinterpret_cast<::df::plugin::PlayerChangeWorldEvent*>(_impl_.payload_.player_change_world_))
                     : reinterpret_cast<const ::df::plugin::PlayerChangeWorldEvent&>(::df::plugin::_PlayerChangeWorldEvent_default_instance_);
}
inline const ::df::plugin::PlayerChangeWorldEvent& EventEnvelope::player_change_world() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_change_world)
  return _internal_player_change_world();
}
inline ::df::plugin::PlayerChangeWorldEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_change_world() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_change_world)
  if (payload_case() == kPlayerChangeWorld) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerChangeWorldEvent*>(_impl_.payload_.player_change_world_);
    _impl_.payload_.player_change_world_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_change_world(
    ::df::plugin::PlayerChangeWorldEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_change_world();
    _impl_.payload_.player_change_world_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_change_world)
}
inline ::df::plugin::PlayerChangeWorldEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_change_world() {
  if (payload_case() != kPlayerChangeWorld) {
    clear_payload();
    set_has_player_change_world();
    _impl_.payload_.player_change_world_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerChangeWorldEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerChangeWorldEvent*>(_impl_.payload_.player_change_world_);
}
inline ::df::plugin::PlayerChangeWorldEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_change_world()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerChangeWorldEvent* _msg = _internal_mutable_player_change_world();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_change_world)
  return _msg;
}

// .df.plugin.PlayerToggleSprintEvent player_toggle_sprint = 16 [json_name = "playerToggleSprint"];
inline bool EventEnvelope::has_player_toggle_sprint() const {
  return payload_case() == kPlayerToggleSprint;
}
inline bool EventEnvelope::_internal_has_player_toggle_sprint() const {
  return payload_case() == kPlayerToggleSprint;
}
inline void EventEnvelope::set_has_player_toggle_sprint() {
  _impl_._oneof_case_[0] = kPlayerToggleSprint;
}
inline ::df::plugin::PlayerToggleSprintEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_toggle_sprint() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_toggle_sprint)
  if (payload_case() == kPlayerToggleSprint) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerToggleSprintEvent*>(_impl_.payload_.player_toggle_sprint_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_toggle_sprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerToggleSprintEvent& EventEnvelope::_internal_player_toggle_sprint() const {
  return payload_case() == kPlayerToggleSprint ? static_cast<const ::df::plugin::PlayerToggleSprintEvent&>(*reinterpret_cast<::df::plugin::PlayerToggleSprintEvent*>(_impl_.payload_.player_toggle_sprint_))
                     : reinterpret_cast<const ::df::plugin::PlayerToggleSprintEvent&>(::df::plugin::_PlayerToggleSprintEvent_default_instance_);
}
inline const ::df::plugin::PlayerToggleSprintEvent& EventEnvelope::player_toggle_sprint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_toggle_sprint)
  return _internal_player_toggle_sprint();
}
inline ::df::plugin::PlayerToggleSprintEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_toggle_sprint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_toggle_sprint)
  if (payload_case() == kPlayerToggleSprint) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerToggleSprintEvent*>(_impl_.payload_.player_toggle_sprint_);
    _impl_.payload_.player_toggle_sprint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_toggle_sprint(
    ::df::plugin::PlayerToggleSprintEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_toggle_sprint();
    _impl_.payload_.player_toggle_sprint_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_toggle_sprint)
}
inline ::df::plugin::PlayerToggleSprintEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_toggle_sprint() {
  if (payload_case() != kPlayerToggleSprint) {
    clear_payload();
    set_has_player_toggle_sprint();
    _impl_.payload_.player_toggle_sprint_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerToggleSprintEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerToggleSprintEvent*>(_impl_.payload_.player_toggle_sprint_);
}
inline ::df::plugin::PlayerToggleSprintEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_toggle_sprint()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerToggleSprintEvent* _msg = _internal_mutable_player_toggle_sprint();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_toggle_sprint)
  return _msg;
}

// .df.plugin.PlayerToggleSneakEvent player_toggle_sneak = 17 [json_name = "playerToggleSneak"];
inline bool EventEnvelope::has_player_toggle_sneak() const {
  return payload_case() == kPlayerToggleSneak;
}
inline bool EventEnvelope::_internal_has_player_toggle_sneak() const {
  return payload_case() == kPlayerToggleSneak;
}
inline void EventEnvelope::set_has_player_toggle_sneak() {
  _impl_._oneof_case_[0] = kPlayerToggleSneak;
}
inline ::df::plugin::PlayerToggleSneakEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_toggle_sneak() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_toggle_sneak)
  if (payload_case() == kPlayerToggleSneak) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerToggleSneakEvent*>(_impl_.payload_.player_toggle_sneak_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_toggle_sneak_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerToggleSneakEvent& EventEnvelope::_internal_player_toggle_sneak() const {
  return payload_case() == kPlayerToggleSneak ? static_cast<const ::df::plugin::PlayerToggleSneakEvent&>(*reinterpret_cast<::df::plugin::PlayerToggleSneakEvent*>(_impl_.payload_.player_toggle_sneak_))
                     : reinterpret_cast<const ::df::plugin::PlayerToggleSneakEvent&>(::df::plugin::_PlayerToggleSneakEvent_default_instance_);
}
inline const ::df::plugin::PlayerToggleSneakEvent& EventEnvelope::player_toggle_sneak() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_toggle_sneak)
  return _internal_player_toggle_sneak();
}
inline ::df::plugin::PlayerToggleSneakEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_toggle_sneak() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_toggle_sneak)
  if (payload_case() == kPlayerToggleSneak) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerToggleSneakEvent*>(_impl_.payload_.player_toggle_sneak_);
    _impl_.payload_.player_toggle_sneak_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_toggle_sneak(
    ::df::plugin::PlayerToggleSneakEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_toggle_sneak();
    _impl_.payload_.player_toggle_sneak_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_toggle_sneak)
}
inline ::df::plugin::PlayerToggleSneakEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_toggle_sneak() {
  if (payload_case() != kPlayerToggleSneak) {
    clear_payload();
    set_has_player_toggle_sneak();
    _impl_.payload_.player_toggle_sneak_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerToggleSneakEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerToggleSneakEvent*>(_impl_.payload_.player_toggle_sneak_);
}
inline ::df::plugin::PlayerToggleSneakEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_toggle_sneak()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerToggleSneakEvent* _msg = _internal_mutable_player_toggle_sneak();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_toggle_sneak)
  return _msg;
}

// .df.plugin.ChatEvent chat = 18 [json_name = "chat"];
inline bool EventEnvelope::has_chat() const {
  return payload_case() == kChat;
}
inline bool EventEnvelope::_internal_has_chat() const {
  return payload_case() == kChat;
}
inline void EventEnvelope::set_has_chat() {
  _impl_._oneof_case_[0] = kChat;
}
inline ::df::plugin::ChatEvent* PROTOBUF_NULLABLE EventEnvelope::release_chat() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.chat)
  if (payload_case() == kChat) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::ChatEvent*>(_impl_.payload_.chat_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.chat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::ChatEvent& EventEnvelope::_internal_chat() const {
  return payload_case() == kChat ? static_cast<const ::df::plugin::ChatEvent&>(*reinterpret_cast<::df::plugin::ChatEvent*>(_impl_.payload_.chat_))
                     : reinterpret_cast<const ::df::plugin::ChatEvent&>(::df::plugin::_ChatEvent_default_instance_);
}
inline const ::df::plugin::ChatEvent& EventEnvelope::chat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.chat)
  return _internal_chat();
}
inline ::df::plugin::ChatEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_chat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.chat)
  if (payload_case() == kChat) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::ChatEvent*>(_impl_.payload_.chat_);
    _impl_.payload_.chat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_chat(
    ::df::plugin::ChatEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_chat();
    _impl_.payload_.chat_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.chat)
}
inline ::df::plugin::ChatEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_chat() {
  if (payload_case() != kChat) {
    clear_payload();
    set_has_chat();
    _impl_.payload_.chat_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::ChatEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::ChatEvent*>(_impl_.payload_.chat_);
}
inline ::df::plugin::ChatEvent* PROTOBUF_NONNULL EventEnvelope::mutable_chat()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::ChatEvent* _msg = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.chat)
  return _msg;
}

// .df.plugin.PlayerFoodLossEvent player_food_loss = 19 [json_name = "playerFoodLoss"];
inline bool EventEnvelope::has_player_food_loss() const {
  return payload_case() == kPlayerFoodLoss;
}
inline bool EventEnvelope::_internal_has_player_food_loss() const {
  return payload_case() == kPlayerFoodLoss;
}
inline void EventEnvelope::set_has_player_food_loss() {
  _impl_._oneof_case_[0] = kPlayerFoodLoss;
}
inline ::df::plugin::PlayerFoodLossEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_food_loss() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_food_loss)
  if (payload_case() == kPlayerFoodLoss) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerFoodLossEvent*>(_impl_.payload_.player_food_loss_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_food_loss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerFoodLossEvent& EventEnvelope::_internal_player_food_loss() const {
  return payload_case() == kPlayerFoodLoss ? static_cast<const ::df::plugin::PlayerFoodLossEvent&>(*reinterpret_cast<::df::plugin::PlayerFoodLossEvent*>(_impl_.payload_.player_food_loss_))
                     : reinterpret_cast<const ::df::plugin::PlayerFoodLossEvent&>(::df::plugin::_PlayerFoodLossEvent_default_instance_);
}
inline const ::df::plugin::PlayerFoodLossEvent& EventEnvelope::player_food_loss() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_food_loss)
  return _internal_player_food_loss();
}
inline ::df::plugin::PlayerFoodLossEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_food_loss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_food_loss)
  if (payload_case() == kPlayerFoodLoss) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerFoodLossEvent*>(_impl_.payload_.player_food_loss_);
    _impl_.payload_.player_food_loss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_food_loss(
    ::df::plugin::PlayerFoodLossEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_food_loss();
    _impl_.payload_.player_food_loss_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_food_loss)
}
inline ::df::plugin::PlayerFoodLossEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_food_loss() {
  if (payload_case() != kPlayerFoodLoss) {
    clear_payload();
    set_has_player_food_loss();
    _impl_.payload_.player_food_loss_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerFoodLossEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerFoodLossEvent*>(_impl_.payload_.player_food_loss_);
}
inline ::df::plugin::PlayerFoodLossEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_food_loss()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerFoodLossEvent* _msg = _internal_mutable_player_food_loss();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_food_loss)
  return _msg;
}

// .df.plugin.PlayerHealEvent player_heal = 20 [json_name = "playerHeal"];
inline bool EventEnvelope::has_player_heal() const {
  return payload_case() == kPlayerHeal;
}
inline bool EventEnvelope::_internal_has_player_heal() const {
  return payload_case() == kPlayerHeal;
}
inline void EventEnvelope::set_has_player_heal() {
  _impl_._oneof_case_[0] = kPlayerHeal;
}
inline ::df::plugin::PlayerHealEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_heal() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_heal)
  if (payload_case() == kPlayerHeal) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerHealEvent*>(_impl_.payload_.player_heal_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_heal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerHealEvent& EventEnvelope::_internal_player_heal() const {
  return payload_case() == kPlayerHeal ? static_cast<const ::df::plugin::PlayerHealEvent&>(*reinterpret_cast<::df::plugin::PlayerHealEvent*>(_impl_.payload_.player_heal_))
                     : reinterpret_cast<const ::df::plugin::PlayerHealEvent&>(::df::plugin::_PlayerHealEvent_default_instance_);
}
inline const ::df::plugin::PlayerHealEvent& EventEnvelope::player_heal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_heal)
  return _internal_player_heal();
}
inline ::df::plugin::PlayerHealEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_heal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_heal)
  if (payload_case() == kPlayerHeal) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerHealEvent*>(_impl_.payload_.player_heal_);
    _impl_.payload_.player_heal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_heal(
    ::df::plugin::PlayerHealEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_heal();
    _impl_.payload_.player_heal_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_heal)
}
inline ::df::plugin::PlayerHealEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_heal() {
  if (payload_case() != kPlayerHeal) {
    clear_payload();
    set_has_player_heal();
    _impl_.payload_.player_heal_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerHealEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerHealEvent*>(_impl_.payload_.player_heal_);
}
inline ::df::plugin::PlayerHealEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_heal()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerHealEvent* _msg = _internal_mutable_player_heal();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_heal)
  return _msg;
}

// .df.plugin.PlayerHurtEvent player_hurt = 21 [json_name = "playerHurt"];
inline bool EventEnvelope::has_player_hurt() const {
  return payload_case() == kPlayerHurt;
}
inline bool EventEnvelope::_internal_has_player_hurt() const {
  return payload_case() == kPlayerHurt;
}
inline void EventEnvelope::set_has_player_hurt() {
  _impl_._oneof_case_[0] = kPlayerHurt;
}
inline ::df::plugin::PlayerHurtEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_hurt() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_hurt)
  if (payload_case() == kPlayerHurt) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerHurtEvent*>(_impl_.payload_.player_hurt_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_hurt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerHurtEvent& EventEnvelope::_internal_player_hurt() const {
  return payload_case() == kPlayerHurt ? static_cast<const ::df::plugin::PlayerHurtEvent&>(*reinterpret_cast<::df::plugin::PlayerHurtEvent*>(_impl_.payload_.player_hurt_))
                     : reinterpret_cast<const ::df::plugin::PlayerHurtEvent&>(::df::plugin::_PlayerHurtEvent_default_instance_);
}
inline const ::df::plugin::PlayerHurtEvent& EventEnvelope::player_hurt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_hurt)
  return _internal_player_hurt();
}
inline ::df::plugin::PlayerHurtEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_hurt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_hurt)
  if (payload_case() == kPlayerHurt) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerHurtEvent*>(_impl_.payload_.player_hurt_);
    _impl_.payload_.player_hurt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_hurt(
    ::df::plugin::PlayerHurtEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_hurt();
    _impl_.payload_.player_hurt_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_hurt)
}
inline ::df::plugin::PlayerHurtEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_hurt() {
  if (payload_case() != kPlayerHurt) {
    clear_payload();
    set_has_player_hurt();
    _impl_.payload_.player_hurt_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerHurtEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerHurtEvent*>(_impl_.payload_.player_hurt_);
}
inline ::df::plugin::PlayerHurtEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_hurt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerHurtEvent* _msg = _internal_mutable_player_hurt();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_hurt)
  return _msg;
}

// .df.plugin.PlayerDeathEvent player_death = 22 [json_name = "playerDeath"];
inline bool EventEnvelope::has_player_death() const {
  return payload_case() == kPlayerDeath;
}
inline bool EventEnvelope::_internal_has_player_death() const {
  return payload_case() == kPlayerDeath;
}
inline void EventEnvelope::set_has_player_death() {
  _impl_._oneof_case_[0] = kPlayerDeath;
}
inline ::df::plugin::PlayerDeathEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_death() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_death)
  if (payload_case() == kPlayerDeath) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerDeathEvent*>(_impl_.payload_.player_death_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_death_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerDeathEvent& EventEnvelope::_internal_player_death() const {
  return payload_case() == kPlayerDeath ? static_cast<const ::df::plugin::PlayerDeathEvent&>(*reinterpret_cast<::df::plugin::PlayerDeathEvent*>(_impl_.payload_.player_death_))
                     : reinterpret_cast<const ::df::plugin::PlayerDeathEvent&>(::df::plugin::_PlayerDeathEvent_default_instance_);
}
inline const ::df::plugin::PlayerDeathEvent& EventEnvelope::player_death() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_death)
  return _internal_player_death();
}
inline ::df::plugin::PlayerDeathEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_death() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_death)
  if (payload_case() == kPlayerDeath) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerDeathEvent*>(_impl_.payload_.player_death_);
    _impl_.payload_.player_death_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_death(
    ::df::plugin::PlayerDeathEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_death();
    _impl_.payload_.player_death_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_death)
}
inline ::df::plugin::PlayerDeathEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_death() {
  if (payload_case() != kPlayerDeath) {
    clear_payload();
    set_has_player_death();
    _impl_.payload_.player_death_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerDeathEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerDeathEvent*>(_impl_.payload_.player_death_);
}
inline ::df::plugin::PlayerDeathEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_death()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerDeathEvent* _msg = _internal_mutable_player_death();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_death)
  return _msg;
}

// .df.plugin.PlayerRespawnEvent player_respawn = 23 [json_name = "playerRespawn"];
inline bool EventEnvelope::has_player_respawn() const {
  return payload_case() == kPlayerRespawn;
}
inline bool EventEnvelope::_internal_has_player_respawn() const {
  return payload_case() == kPlayerRespawn;
}
inline void EventEnvelope::set_has_player_respawn() {
  _impl_._oneof_case_[0] = kPlayerRespawn;
}
inline ::df::plugin::PlayerRespawnEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_respawn() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_respawn)
  if (payload_case() == kPlayerRespawn) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerRespawnEvent*>(_impl_.payload_.player_respawn_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_respawn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerRespawnEvent& EventEnvelope::_internal_player_respawn() const {
  return payload_case() == kPlayerRespawn ? static_cast<const ::df::plugin::PlayerRespawnEvent&>(*reinterpret_cast<::df::plugin::PlayerRespawnEvent*>(_impl_.payload_.player_respawn_))
                     : reinterpret_cast<const ::df::plugin::PlayerRespawnEvent&>(::df::plugin::_PlayerRespawnEvent_default_instance_);
}
inline const ::df::plugin::PlayerRespawnEvent& EventEnvelope::player_respawn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_respawn)
  return _internal_player_respawn();
}
inline ::df::plugin::PlayerRespawnEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_respawn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_respawn)
  if (payload_case() == kPlayerRespawn) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerRespawnEvent*>(_impl_.payload_.player_respawn_);
    _impl_.payload_.player_respawn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_respawn(
    ::df::plugin::PlayerRespawnEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_respawn();
    _impl_.payload_.player_respawn_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_respawn)
}
inline ::df::plugin::PlayerRespawnEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_respawn() {
  if (payload_case() != kPlayerRespawn) {
    clear_payload();
    set_has_player_respawn();
    _impl_.payload_.player_respawn_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerRespawnEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerRespawnEvent*>(_impl_.payload_.player_respawn_);
}
inline ::df::plugin::PlayerRespawnEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_respawn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerRespawnEvent* _msg = _internal_mutable_player_respawn();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_respawn)
  return _msg;
}

// .df.plugin.PlayerSkinChangeEvent player_skin_change = 24 [json_name = "playerSkinChange"];
inline bool EventEnvelope::has_player_skin_change() const {
  return payload_case() == kPlayerSkinChange;
}
inline bool EventEnvelope::_internal_has_player_skin_change() const {
  return payload_case() == kPlayerSkinChange;
}
inline void EventEnvelope::set_has_player_skin_change() {
  _impl_._oneof_case_[0] = kPlayerSkinChange;
}
inline ::df::plugin::PlayerSkinChangeEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_skin_change() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_skin_change)
  if (payload_case() == kPlayerSkinChange) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerSkinChangeEvent*>(_impl_.payload_.player_skin_change_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_skin_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerSkinChangeEvent& EventEnvelope::_internal_player_skin_change() const {
  return payload_case() == kPlayerSkinChange ? static_cast<const ::df::plugin::PlayerSkinChangeEvent&>(*reinterpret_cast<::df::plugin::PlayerSkinChangeEvent*>(_impl_.payload_.player_skin_change_))
                     : reinterpret_cast<const ::df::plugin::PlayerSkinChangeEvent&>(::df::plugin::_PlayerSkinChangeEvent_default_instance_);
}
inline const ::df::plugin::PlayerSkinChangeEvent& EventEnvelope::player_skin_change() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_skin_change)
  return _internal_player_skin_change();
}
inline ::df::plugin::PlayerSkinChangeEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_skin_change() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_skin_change)
  if (payload_case() == kPlayerSkinChange) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerSkinChangeEvent*>(_impl_.payload_.player_skin_change_);
    _impl_.payload_.player_skin_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_skin_change(
    ::df::plugin::PlayerSkinChangeEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_skin_change();
    _impl_.payload_.player_skin_change_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_skin_change)
}
inline ::df::plugin::PlayerSkinChangeEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_skin_change() {
  if (payload_case() != kPlayerSkinChange) {
    clear_payload();
    set_has_player_skin_change();
    _impl_.payload_.player_skin_change_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerSkinChangeEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerSkinChangeEvent*>(_impl_.payload_.player_skin_change_);
}
inline ::df::plugin::PlayerSkinChangeEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_skin_change()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerSkinChangeEvent* _msg = _internal_mutable_player_skin_change();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_skin_change)
  return _msg;
}

// .df.plugin.PlayerFireExtinguishEvent player_fire_extinguish = 25 [json_name = "playerFireExtinguish"];
inline bool EventEnvelope::has_player_fire_extinguish() const {
  return payload_case() == kPlayerFireExtinguish;
}
inline bool EventEnvelope::_internal_has_player_fire_extinguish() const {
  return payload_case() == kPlayerFireExtinguish;
}
inline void EventEnvelope::set_has_player_fire_extinguish() {
  _impl_._oneof_case_[0] = kPlayerFireExtinguish;
}
inline ::df::plugin::PlayerFireExtinguishEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_fire_extinguish() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_fire_extinguish)
  if (payload_case() == kPlayerFireExtinguish) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerFireExtinguishEvent*>(_impl_.payload_.player_fire_extinguish_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_fire_extinguish_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerFireExtinguishEvent& EventEnvelope::_internal_player_fire_extinguish() const {
  return payload_case() == kPlayerFireExtinguish ? static_cast<const ::df::plugin::PlayerFireExtinguishEvent&>(*reinterpret_cast<::df::plugin::PlayerFireExtinguishEvent*>(_impl_.payload_.player_fire_extinguish_))
                     : reinterpret_cast<const ::df::plugin::PlayerFireExtinguishEvent&>(::df::plugin::_PlayerFireExtinguishEvent_default_instance_);
}
inline const ::df::plugin::PlayerFireExtinguishEvent& EventEnvelope::player_fire_extinguish() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_fire_extinguish)
  return _internal_player_fire_extinguish();
}
inline ::df::plugin::PlayerFireExtinguishEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_fire_extinguish() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_fire_extinguish)
  if (payload_case() == kPlayerFireExtinguish) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerFireExtinguishEvent*>(_impl_.payload_.player_fire_extinguish_);
    _impl_.payload_.player_fire_extinguish_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_fire_extinguish(
    ::df::plugin::PlayerFireExtinguishEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_fire_extinguish();
    _impl_.payload_.player_fire_extinguish_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_fire_extinguish)
}
inline ::df::plugin::PlayerFireExtinguishEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_fire_extinguish() {
  if (payload_case() != kPlayerFireExtinguish) {
    clear_payload();
    set_has_player_fire_extinguish();
    _impl_.payload_.player_fire_extinguish_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerFireExtinguishEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerFireExtinguishEvent*>(_impl_.payload_.player_fire_extinguish_);
}
inline ::df::plugin::PlayerFireExtinguishEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_fire_extinguish()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerFireExtinguishEvent* _msg = _internal_mutable_player_fire_extinguish();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_fire_extinguish)
  return _msg;
}

// .df.plugin.PlayerStartBreakEvent player_start_break = 26 [json_name = "playerStartBreak"];
inline bool EventEnvelope::has_player_start_break() const {
  return payload_case() == kPlayerStartBreak;
}
inline bool EventEnvelope::_internal_has_player_start_break() const {
  return payload_case() == kPlayerStartBreak;
}
inline void EventEnvelope::set_has_player_start_break() {
  _impl_._oneof_case_[0] = kPlayerStartBreak;
}
inline ::df::plugin::PlayerStartBreakEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_start_break() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_start_break)
  if (payload_case() == kPlayerStartBreak) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerStartBreakEvent*>(_impl_.payload_.player_start_break_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_start_break_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerStartBreakEvent& EventEnvelope::_internal_player_start_break() const {
  return payload_case() == kPlayerStartBreak ? static_cast<const ::df::plugin::PlayerStartBreakEvent&>(*reinterpret_cast<::df::plugin::PlayerStartBreakEvent*>(_impl_.payload_.player_start_break_))
                     : reinterpret_cast<const ::df::plugin::PlayerStartBreakEvent&>(::df::plugin::_PlayerStartBreakEvent_default_instance_);
}
inline const ::df::plugin::PlayerStartBreakEvent& EventEnvelope::player_start_break() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_start_break)
  return _internal_player_start_break();
}
inline ::df::plugin::PlayerStartBreakEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_start_break() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_start_break)
  if (payload_case() == kPlayerStartBreak) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerStartBreakEvent*>(_impl_.payload_.player_start_break_);
    _impl_.payload_.player_start_break_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_start_break(
    ::df::plugin::PlayerStartBreakEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_start_break();
    _impl_.payload_.player_start_break_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_start_break)
}
inline ::df::plugin::PlayerStartBreakEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_start_break() {
  if (payload_case() != kPlayerStartBreak) {
    clear_payload();
    set_has_player_start_break();
    _impl_.payload_.player_start_break_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerStartBreakEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerStartBreakEvent*>(_impl_.payload_.player_start_break_);
}
inline ::df::plugin::PlayerStartBreakEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_start_break()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerStartBreakEvent* _msg = _internal_mutable_player_start_break();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_start_break)
  return _msg;
}

// .df.plugin.BlockBreakEvent block_break = 27 [json_name = "blockBreak"];
inline bool EventEnvelope::has_block_break() const {
  return payload_case() == kBlockBreak;
}
inline bool EventEnvelope::_internal_has_block_break() const {
  return payload_case() == kBlockBreak;
}
inline void EventEnvelope::set_has_block_break() {
  _impl_._oneof_case_[0] = kBlockBreak;
}
inline ::df::plugin::BlockBreakEvent* PROTOBUF_NULLABLE EventEnvelope::release_block_break() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.block_break)
  if (payload_case() == kBlockBreak) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::BlockBreakEvent*>(_impl_.payload_.block_break_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.block_break_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::BlockBreakEvent& EventEnvelope::_internal_block_break() const {
  return payload_case() == kBlockBreak ? static_cast<const ::df::plugin::BlockBreakEvent&>(*reinterpret_cast<::df::plugin::BlockBreakEvent*>(_impl_.payload_.block_break_))
                     : reinterpret_cast<const ::df::plugin::BlockBreakEvent&>(::df::plugin::_BlockBreakEvent_default_instance_);
}
inline const ::df::plugin::BlockBreakEvent& EventEnvelope::block_break() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.block_break)
  return _internal_block_break();
}
inline ::df::plugin::BlockBreakEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_block_break() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.block_break)
  if (payload_case() == kBlockBreak) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::BlockBreakEvent*>(_impl_.payload_.block_break_);
    _impl_.payload_.block_break_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_block_break(
    ::df::plugin::BlockBreakEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_block_break();
    _impl_.payload_.block_break_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.block_break)
}
inline ::df::plugin::BlockBreakEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_block_break() {
  if (payload_case() != kBlockBreak) {
    clear_payload();
    set_has_block_break();
    _impl_.payload_.block_break_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::BlockBreakEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::BlockBreakEvent*>(_impl_.payload_.block_break_);
}
inline ::df::plugin::BlockBreakEvent* PROTOBUF_NONNULL EventEnvelope::mutable_block_break()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::BlockBreakEvent* _msg = _internal_mutable_block_break();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.block_break)
  return _msg;
}

// .df.plugin.PlayerBlockPlaceEvent player_block_place = 28 [json_name = "playerBlockPlace"];
inline bool EventEnvelope::has_player_block_place() const {
  return payload_case() == kPlayerBlockPlace;
}
inline bool EventEnvelope::_internal_has_player_block_place() const {
  return payload_case() == kPlayerBlockPlace;
}
inline void EventEnvelope::set_has_player_block_place() {
  _impl_._oneof_case_[0] = kPlayerBlockPlace;
}
inline ::df::plugin::PlayerBlockPlaceEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_block_place() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_block_place)
  if (payload_case() == kPlayerBlockPlace) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerBlockPlaceEvent*>(_impl_.payload_.player_block_place_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_block_place_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerBlockPlaceEvent& EventEnvelope::_internal_player_block_place() const {
  return payload_case() == kPlayerBlockPlace ? static_cast<const ::df::plugin::PlayerBlockPlaceEvent&>(*reinterpret_cast<::df::plugin::PlayerBlockPlaceEvent*>(_impl_.payload_.player_block_place_))
                     : reinterpret_cast<const ::df::plugin::PlayerBlockPlaceEvent&>(::df::plugin::_PlayerBlockPlaceEvent_default_instance_);
}
inline const ::df::plugin::PlayerBlockPlaceEvent& EventEnvelope::player_block_place() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_block_place)
  return _internal_player_block_place();
}
inline ::df::plugin::PlayerBlockPlaceEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_block_place() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_block_place)
  if (payload_case() == kPlayerBlockPlace) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerBlockPlaceEvent*>(_impl_.payload_.player_block_place_);
    _impl_.payload_.player_block_place_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_block_place(
    ::df::plugin::PlayerBlockPlaceEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_block_place();
    _impl_.payload_.player_block_place_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_block_place)
}
inline ::df::plugin::PlayerBlockPlaceEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_block_place() {
  if (payload_case() != kPlayerBlockPlace) {
    clear_payload();
    set_has_player_block_place();
    _impl_.payload_.player_block_place_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerBlockPlaceEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerBlockPlaceEvent*>(_impl_.payload_.player_block_place_);
}
inline ::df::plugin::PlayerBlockPlaceEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_block_place()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerBlockPlaceEvent* _msg = _internal_mutable_player_block_place();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_block_place)
  return _msg;
}

// .df.plugin.PlayerBlockPickEvent player_block_pick = 29 [json_name = "playerBlockPick"];
inline bool EventEnvelope::has_player_block_pick() const {
  return payload_case() == kPlayerBlockPick;
}
inline bool EventEnvelope::_internal_has_player_block_pick() const {
  return payload_case() == kPlayerBlockPick;
}
inline void EventEnvelope::set_has_player_block_pick() {
  _impl_._oneof_case_[0] = kPlayerBlockPick;
}
inline ::df::plugin::PlayerBlockPickEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_block_pick() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_block_pick)
  if (payload_case() == kPlayerBlockPick) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerBlockPickEvent*>(_impl_.payload_.player_block_pick_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_block_pick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerBlockPickEvent& EventEnvelope::_internal_player_block_pick() const {
  return payload_case() == kPlayerBlockPick ? static_cast<const ::df::plugin::PlayerBlockPickEvent&>(*reinterpret_cast<::df::plugin::PlayerBlockPickEvent*>(_impl_.payload_.player_block_pick_))
                     : reinterpret_cast<const ::df::plugin::PlayerBlockPickEvent&>(::df::plugin::_PlayerBlockPickEvent_default_instance_);
}
inline const ::df::plugin::PlayerBlockPickEvent& EventEnvelope::player_block_pick() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_block_pick)
  return _internal_player_block_pick();
}
inline ::df::plugin::PlayerBlockPickEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_block_pick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_block_pick)
  if (payload_case() == kPlayerBlockPick) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerBlockPickEvent*>(_impl_.payload_.player_block_pick_);
    _impl_.payload_.player_block_pick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_block_pick(
    ::df::plugin::PlayerBlockPickEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_block_pick();
    _impl_.payload_.player_block_pick_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_block_pick)
}
inline ::df::plugin::PlayerBlockPickEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_block_pick() {
  if (payload_case() != kPlayerBlockPick) {
    clear_payload();
    set_has_player_block_pick();
    _impl_.payload_.player_block_pick_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerBlockPickEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerBlockPickEvent*>(_impl_.payload_.player_block_pick_);
}
inline ::df::plugin::PlayerBlockPickEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_block_pick()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerBlockPickEvent* _msg = _internal_mutable_player_block_pick();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_block_pick)
  return _msg;
}

// .df.plugin.PlayerItemUseEvent player_item_use = 30 [json_name = "playerItemUse"];
inline bool EventEnvelope::has_player_item_use() const {
  return payload_case() == kPlayerItemUse;
}
inline bool EventEnvelope::_internal_has_player_item_use() const {
  return payload_case() == kPlayerItemUse;
}
inline void EventEnvelope::set_has_player_item_use() {
  _impl_._oneof_case_[0] = kPlayerItemUse;
}
inline ::df::plugin::PlayerItemUseEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_item_use() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_item_use)
  if (payload_case() == kPlayerItemUse) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemUseEvent*>(_impl_.payload_.player_item_use_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_item_use_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerItemUseEvent& EventEnvelope::_internal_player_item_use() const {
  return payload_case() == kPlayerItemUse ? static_cast<const ::df::plugin::PlayerItemUseEvent&>(*reinterpret_cast<::df::plugin::PlayerItemUseEvent*>(_impl_.payload_.player_item_use_))
                     : reinterpret_cast<const ::df::plugin::PlayerItemUseEvent&>(::df::plugin::_PlayerItemUseEvent_default_instance_);
}
inline const ::df::plugin::PlayerItemUseEvent& EventEnvelope::player_item_use() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_item_use)
  return _internal_player_item_use();
}
inline ::df::plugin::PlayerItemUseEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_item_use() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_item_use)
  if (payload_case() == kPlayerItemUse) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemUseEvent*>(_impl_.payload_.player_item_use_);
    _impl_.payload_.player_item_use_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_item_use(
    ::df::plugin::PlayerItemUseEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_item_use();
    _impl_.payload_.player_item_use_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_item_use)
}
inline ::df::plugin::PlayerItemUseEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_item_use() {
  if (payload_case() != kPlayerItemUse) {
    clear_payload();
    set_has_player_item_use();
    _impl_.payload_.player_item_use_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerItemUseEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerItemUseEvent*>(_impl_.payload_.player_item_use_);
}
inline ::df::plugin::PlayerItemUseEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_item_use()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerItemUseEvent* _msg = _internal_mutable_player_item_use();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_item_use)
  return _msg;
}

// .df.plugin.PlayerItemUseOnBlockEvent player_item_use_on_block = 31 [json_name = "playerItemUseOnBlock"];
inline bool EventEnvelope::has_player_item_use_on_block() const {
  return payload_case() == kPlayerItemUseOnBlock;
}
inline bool EventEnvelope::_internal_has_player_item_use_on_block() const {
  return payload_case() == kPlayerItemUseOnBlock;
}
inline void EventEnvelope::set_has_player_item_use_on_block() {
  _impl_._oneof_case_[0] = kPlayerItemUseOnBlock;
}
inline ::df::plugin::PlayerItemUseOnBlockEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_item_use_on_block() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_item_use_on_block)
  if (payload_case() == kPlayerItemUseOnBlock) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemUseOnBlockEvent*>(_impl_.payload_.player_item_use_on_block_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_item_use_on_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerItemUseOnBlockEvent& EventEnvelope::_internal_player_item_use_on_block() const {
  return payload_case() == kPlayerItemUseOnBlock ? static_cast<const ::df::plugin::PlayerItemUseOnBlockEvent&>(*reinterpret_cast<::df::plugin::PlayerItemUseOnBlockEvent*>(_impl_.payload_.player_item_use_on_block_))
                     : reinterpret_cast<const ::df::plugin::PlayerItemUseOnBlockEvent&>(::df::plugin::_PlayerItemUseOnBlockEvent_default_instance_);
}
inline const ::df::plugin::PlayerItemUseOnBlockEvent& EventEnvelope::player_item_use_on_block() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_item_use_on_block)
  return _internal_player_item_use_on_block();
}
inline ::df::plugin::PlayerItemUseOnBlockEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_item_use_on_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_item_use_on_block)
  if (payload_case() == kPlayerItemUseOnBlock) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemUseOnBlockEvent*>(_impl_.payload_.player_item_use_on_block_);
    _impl_.payload_.player_item_use_on_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_item_use_on_block(
    ::df::plugin::PlayerItemUseOnBlockEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_item_use_on_block();
    _impl_.payload_.player_item_use_on_block_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_item_use_on_block)
}
inline ::df::plugin::PlayerItemUseOnBlockEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_item_use_on_block() {
  if (payload_case() != kPlayerItemUseOnBlock) {
    clear_payload();
    set_has_player_item_use_on_block();
    _impl_.payload_.player_item_use_on_block_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerItemUseOnBlockEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerItemUseOnBlockEvent*>(_impl_.payload_.player_item_use_on_block_);
}
inline ::df::plugin::PlayerItemUseOnBlockEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_item_use_on_block()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerItemUseOnBlockEvent* _msg = _internal_mutable_player_item_use_on_block();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_item_use_on_block)
  return _msg;
}

// .df.plugin.PlayerItemUseOnEntityEvent player_item_use_on_entity = 32 [json_name = "playerItemUseOnEntity"];
inline bool EventEnvelope::has_player_item_use_on_entity() const {
  return payload_case() == kPlayerItemUseOnEntity;
}
inline bool EventEnvelope::_internal_has_player_item_use_on_entity() const {
  return payload_case() == kPlayerItemUseOnEntity;
}
inline void EventEnvelope::set_has_player_item_use_on_entity() {
  _impl_._oneof_case_[0] = kPlayerItemUseOnEntity;
}
inline ::df::plugin::PlayerItemUseOnEntityEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_item_use_on_entity() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_item_use_on_entity)
  if (payload_case() == kPlayerItemUseOnEntity) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemUseOnEntityEvent*>(_impl_.payload_.player_item_use_on_entity_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_item_use_on_entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerItemUseOnEntityEvent& EventEnvelope::_internal_player_item_use_on_entity() const {
  return payload_case() == kPlayerItemUseOnEntity ? static_cast<const ::df::plugin::PlayerItemUseOnEntityEvent&>(*reinterpret_cast<::df::plugin::PlayerItemUseOnEntityEvent*>(_impl_.payload_.player_item_use_on_entity_))
                     : reinterpret_cast<const ::df::plugin::PlayerItemUseOnEntityEvent&>(::df::plugin::_PlayerItemUseOnEntityEvent_default_instance_);
}
inline const ::df::plugin::PlayerItemUseOnEntityEvent& EventEnvelope::player_item_use_on_entity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_item_use_on_entity)
  return _internal_player_item_use_on_entity();
}
inline ::df::plugin::PlayerItemUseOnEntityEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_item_use_on_entity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_item_use_on_entity)
  if (payload_case() == kPlayerItemUseOnEntity) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemUseOnEntityEvent*>(_impl_.payload_.player_item_use_on_entity_);
    _impl_.payload_.player_item_use_on_entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_item_use_on_entity(
    ::df::plugin::PlayerItemUseOnEntityEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_item_use_on_entity();
    _impl_.payload_.player_item_use_on_entity_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_item_use_on_entity)
}
inline ::df::plugin::PlayerItemUseOnEntityEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_item_use_on_entity() {
  if (payload_case() != kPlayerItemUseOnEntity) {
    clear_payload();
    set_has_player_item_use_on_entity();
    _impl_.payload_.player_item_use_on_entity_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerItemUseOnEntityEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerItemUseOnEntityEvent*>(_impl_.payload_.player_item_use_on_entity_);
}
inline ::df::plugin::PlayerItemUseOnEntityEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_item_use_on_entity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerItemUseOnEntityEvent* _msg = _internal_mutable_player_item_use_on_entity();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_item_use_on_entity)
  return _msg;
}

// .df.plugin.PlayerItemReleaseEvent player_item_release = 33 [json_name = "playerItemRelease"];
inline bool EventEnvelope::has_player_item_release() const {
  return payload_case() == kPlayerItemRelease;
}
inline bool EventEnvelope::_internal_has_player_item_release() const {
  return payload_case() == kPlayerItemRelease;
}
inline void EventEnvelope::set_has_player_item_release() {
  _impl_._oneof_case_[0] = kPlayerItemRelease;
}
inline ::df::plugin::PlayerItemReleaseEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_item_release() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_item_release)
  if (payload_case() == kPlayerItemRelease) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemReleaseEvent*>(_impl_.payload_.player_item_release_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_item_release_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerItemReleaseEvent& EventEnvelope::_internal_player_item_release() const {
  return payload_case() == kPlayerItemRelease ? static_cast<const ::df::plugin::PlayerItemReleaseEvent&>(*reinterpret_cast<::df::plugin::PlayerItemReleaseEvent*>(_impl_.payload_.player_item_release_))
                     : reinterpret_cast<const ::df::plugin::PlayerItemReleaseEvent&>(::df::plugin::_PlayerItemReleaseEvent_default_instance_);
}
inline const ::df::plugin::PlayerItemReleaseEvent& EventEnvelope::player_item_release() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_item_release)
  return _internal_player_item_release();
}
inline ::df::plugin::PlayerItemReleaseEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_item_release() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_item_release)
  if (payload_case() == kPlayerItemRelease) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemReleaseEvent*>(_impl_.payload_.player_item_release_);
    _impl_.payload_.player_item_release_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_item_release(
    ::df::plugin::PlayerItemReleaseEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_item_release();
    _impl_.payload_.player_item_release_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_item_release)
}
inline ::df::plugin::PlayerItemReleaseEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_item_release() {
  if (payload_case() != kPlayerItemRelease) {
    clear_payload();
    set_has_player_item_release();
    _impl_.payload_.player_item_release_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerItemReleaseEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerItemReleaseEvent*>(_impl_.payload_.player_item_release_);
}
inline ::df::plugin::PlayerItemReleaseEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_item_release()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerItemReleaseEvent* _msg = _internal_mutable_player_item_release();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_item_release)
  return _msg;
}

// .df.plugin.PlayerItemConsumeEvent player_item_consume = 34 [json_name = "playerItemConsume"];
inline bool EventEnvelope::has_player_item_consume() const {
  return payload_case() == kPlayerItemConsume;
}
inline bool EventEnvelope::_internal_has_player_item_consume() const {
  return payload_case() == kPlayerItemConsume;
}
inline void EventEnvelope::set_has_player_item_consume() {
  _impl_._oneof_case_[0] = kPlayerItemConsume;
}
inline ::df::plugin::PlayerItemConsumeEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_item_consume() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_item_consume)
  if (payload_case() == kPlayerItemConsume) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemConsumeEvent*>(_impl_.payload_.player_item_consume_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_item_consume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerItemConsumeEvent& EventEnvelope::_internal_player_item_consume() const {
  return payload_case() == kPlayerItemConsume ? static_cast<const ::df::plugin::PlayerItemConsumeEvent&>(*reinterpret_cast<::df::plugin::PlayerItemConsumeEvent*>(_impl_.payload_.player_item_consume_))
                     : reinterpret_cast<const ::df::plugin::PlayerItemConsumeEvent&>(::df::plugin::_PlayerItemConsumeEvent_default_instance_);
}
inline const ::df::plugin::PlayerItemConsumeEvent& EventEnvelope::player_item_consume() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_item_consume)
  return _internal_player_item_consume();
}
inline ::df::plugin::PlayerItemConsumeEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_item_consume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_item_consume)
  if (payload_case() == kPlayerItemConsume) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemConsumeEvent*>(_impl_.payload_.player_item_consume_);
    _impl_.payload_.player_item_consume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_item_consume(
    ::df::plugin::PlayerItemConsumeEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_item_consume();
    _impl_.payload_.player_item_consume_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_item_consume)
}
inline ::df::plugin::PlayerItemConsumeEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_item_consume() {
  if (payload_case() != kPlayerItemConsume) {
    clear_payload();
    set_has_player_item_consume();
    _impl_.payload_.player_item_consume_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerItemConsumeEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerItemConsumeEvent*>(_impl_.payload_.player_item_consume_);
}
inline ::df::plugin::PlayerItemConsumeEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_item_consume()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerItemConsumeEvent* _msg = _internal_mutable_player_item_consume();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_item_consume)
  return _msg;
}

// .df.plugin.PlayerAttackEntityEvent player_attack_entity = 35 [json_name = "playerAttackEntity"];
inline bool EventEnvelope::has_player_attack_entity() const {
  return payload_case() == kPlayerAttackEntity;
}
inline bool EventEnvelope::_internal_has_player_attack_entity() const {
  return payload_case() == kPlayerAttackEntity;
}
inline void EventEnvelope::set_has_player_attack_entity() {
  _impl_._oneof_case_[0] = kPlayerAttackEntity;
}
inline ::df::plugin::PlayerAttackEntityEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_attack_entity() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_attack_entity)
  if (payload_case() == kPlayerAttackEntity) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerAttackEntityEvent*>(_impl_.payload_.player_attack_entity_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_attack_entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerAttackEntityEvent& EventEnvelope::_internal_player_attack_entity() const {
  return payload_case() == kPlayerAttackEntity ? static_cast<const ::df::plugin::PlayerAttackEntityEvent&>(*reinterpret_cast<::df::plugin::PlayerAttackEntityEvent*>(_impl_.payload_.player_attack_entity_))
                     : reinterpret_cast<const ::df::plugin::PlayerAttackEntityEvent&>(::df::plugin::_PlayerAttackEntityEvent_default_instance_);
}
inline const ::df::plugin::PlayerAttackEntityEvent& EventEnvelope::player_attack_entity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_attack_entity)
  return _internal_player_attack_entity();
}
inline ::df::plugin::PlayerAttackEntityEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_attack_entity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_attack_entity)
  if (payload_case() == kPlayerAttackEntity) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerAttackEntityEvent*>(_impl_.payload_.player_attack_entity_);
    _impl_.payload_.player_attack_entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_attack_entity(
    ::df::plugin::PlayerAttackEntityEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_attack_entity();
    _impl_.payload_.player_attack_entity_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_attack_entity)
}
inline ::df::plugin::PlayerAttackEntityEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_attack_entity() {
  if (payload_case() != kPlayerAttackEntity) {
    clear_payload();
    set_has_player_attack_entity();
    _impl_.payload_.player_attack_entity_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerAttackEntityEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerAttackEntityEvent*>(_impl_.payload_.player_attack_entity_);
}
inline ::df::plugin::PlayerAttackEntityEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_attack_entity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerAttackEntityEvent* _msg = _internal_mutable_player_attack_entity();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_attack_entity)
  return _msg;
}

// .df.plugin.PlayerExperienceGainEvent player_experience_gain = 36 [json_name = "playerExperienceGain"];
inline bool EventEnvelope::has_player_experience_gain() const {
  return payload_case() == kPlayerExperienceGain;
}
inline bool EventEnvelope::_internal_has_player_experience_gain() const {
  return payload_case() == kPlayerExperienceGain;
}
inline void EventEnvelope::set_has_player_experience_gain() {
  _impl_._oneof_case_[0] = kPlayerExperienceGain;
}
inline ::df::plugin::PlayerExperienceGainEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_experience_gain() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_experience_gain)
  if (payload_case() == kPlayerExperienceGain) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerExperienceGainEvent*>(_impl_.payload_.player_experience_gain_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_experience_gain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerExperienceGainEvent& EventEnvelope::_internal_player_experience_gain() const {
  return payload_case() == kPlayerExperienceGain ? static_cast<const ::df::plugin::PlayerExperienceGainEvent&>(*reinterpret_cast<::df::plugin::PlayerExperienceGainEvent*>(_impl_.payload_.player_experience_gain_))
                     : reinterpret_cast<const ::df::plugin::PlayerExperienceGainEvent&>(::df::plugin::_PlayerExperienceGainEvent_default_instance_);
}
inline const ::df::plugin::PlayerExperienceGainEvent& EventEnvelope::player_experience_gain() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_experience_gain)
  return _internal_player_experience_gain();
}
inline ::df::plugin::PlayerExperienceGainEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_experience_gain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_experience_gain)
  if (payload_case() == kPlayerExperienceGain) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerExperienceGainEvent*>(_impl_.payload_.player_experience_gain_);
    _impl_.payload_.player_experience_gain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_experience_gain(
    ::df::plugin::PlayerExperienceGainEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_experience_gain();
    _impl_.payload_.player_experience_gain_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_experience_gain)
}
inline ::df::plugin::PlayerExperienceGainEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_experience_gain() {
  if (payload_case() != kPlayerExperienceGain) {
    clear_payload();
    set_has_player_experience_gain();
    _impl_.payload_.player_experience_gain_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerExperienceGainEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerExperienceGainEvent*>(_impl_.payload_.player_experience_gain_);
}
inline ::df::plugin::PlayerExperienceGainEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_experience_gain()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerExperienceGainEvent* _msg = _internal_mutable_player_experience_gain();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_experience_gain)
  return _msg;
}

// .df.plugin.PlayerPunchAirEvent player_punch_air = 37 [json_name = "playerPunchAir"];
inline bool EventEnvelope::has_player_punch_air() const {
  return payload_case() == kPlayerPunchAir;
}
inline bool EventEnvelope::_internal_has_player_punch_air() const {
  return payload_case() == kPlayerPunchAir;
}
inline void EventEnvelope::set_has_player_punch_air() {
  _impl_._oneof_case_[0] = kPlayerPunchAir;
}
inline ::df::plugin::PlayerPunchAirEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_punch_air() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_punch_air)
  if (payload_case() == kPlayerPunchAir) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerPunchAirEvent*>(_impl_.payload_.player_punch_air_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_punch_air_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerPunchAirEvent& EventEnvelope::_internal_player_punch_air() const {
  return payload_case() == kPlayerPunchAir ? static_cast<const ::df::plugin::PlayerPunchAirEvent&>(*reinterpret_cast<::df::plugin::PlayerPunchAirEvent*>(_impl_.payload_.player_punch_air_))
                     : reinterpret_cast<const ::df::plugin::PlayerPunchAirEvent&>(::df::plugin::_PlayerPunchAirEvent_default_instance_);
}
inline const ::df::plugin::PlayerPunchAirEvent& EventEnvelope::player_punch_air() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_punch_air)
  return _internal_player_punch_air();
}
inline ::df::plugin::PlayerPunchAirEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_punch_air() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_punch_air)
  if (payload_case() == kPlayerPunchAir) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerPunchAirEvent*>(_impl_.payload_.player_punch_air_);
    _impl_.payload_.player_punch_air_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_punch_air(
    ::df::plugin::PlayerPunchAirEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_punch_air();
    _impl_.payload_.player_punch_air_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_punch_air)
}
inline ::df::plugin::PlayerPunchAirEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_punch_air() {
  if (payload_case() != kPlayerPunchAir) {
    clear_payload();
    set_has_player_punch_air();
    _impl_.payload_.player_punch_air_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerPunchAirEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerPunchAirEvent*>(_impl_.payload_.player_punch_air_);
}
inline ::df::plugin::PlayerPunchAirEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_punch_air()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerPunchAirEvent* _msg = _internal_mutable_player_punch_air();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_punch_air)
  return _msg;
}

// .df.plugin.PlayerSignEditEvent player_sign_edit = 38 [json_name = "playerSignEdit"];
inline bool EventEnvelope::has_player_sign_edit() const {
  return payload_case() == kPlayerSignEdit;
}
inline bool EventEnvelope::_internal_has_player_sign_edit() const {
  return payload_case() == kPlayerSignEdit;
}
inline void EventEnvelope::set_has_player_sign_edit() {
  _impl_._oneof_case_[0] = kPlayerSignEdit;
}
inline ::df::plugin::PlayerSignEditEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_sign_edit() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_sign_edit)
  if (payload_case() == kPlayerSignEdit) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerSignEditEvent*>(_impl_.payload_.player_sign_edit_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_sign_edit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerSignEditEvent& EventEnvelope::_internal_player_sign_edit() const {
  return payload_case() == kPlayerSignEdit ? static_cast<const ::df::plugin::PlayerSignEditEvent&>(*reinterpret_cast<::df::plugin::PlayerSignEditEvent*>(_impl_.payload_.player_sign_edit_))
                     : reinterpret_cast<const ::df::plugin::PlayerSignEditEvent&>(::df::plugin::_PlayerSignEditEvent_default_instance_);
}
inline const ::df::plugin::PlayerSignEditEvent& EventEnvelope::player_sign_edit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_sign_edit)
  return _internal_player_sign_edit();
}
inline ::df::plugin::PlayerSignEditEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_sign_edit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_sign_edit)
  if (payload_case() == kPlayerSignEdit) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerSignEditEvent*>(_impl_.payload_.player_sign_edit_);
    _impl_.payload_.player_sign_edit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_sign_edit(
    ::df::plugin::PlayerSignEditEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_sign_edit();
    _impl_.payload_.player_sign_edit_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_sign_edit)
}
inline ::df::plugin::PlayerSignEditEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_sign_edit() {
  if (payload_case() != kPlayerSignEdit) {
    clear_payload();
    set_has_player_sign_edit();
    _impl_.payload_.player_sign_edit_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerSignEditEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerSignEditEvent*>(_impl_.payload_.player_sign_edit_);
}
inline ::df::plugin::PlayerSignEditEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_sign_edit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerSignEditEvent* _msg = _internal_mutable_player_sign_edit();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_sign_edit)
  return _msg;
}

// .df.plugin.PlayerLecternPageTurnEvent player_lectern_page_turn = 39 [json_name = "playerLecternPageTurn"];
inline bool EventEnvelope::has_player_lectern_page_turn() const {
  return payload_case() == kPlayerLecternPageTurn;
}
inline bool EventEnvelope::_internal_has_player_lectern_page_turn() const {
  return payload_case() == kPlayerLecternPageTurn;
}
inline void EventEnvelope::set_has_player_lectern_page_turn() {
  _impl_._oneof_case_[0] = kPlayerLecternPageTurn;
}
inline ::df::plugin::PlayerLecternPageTurnEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_lectern_page_turn() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_lectern_page_turn)
  if (payload_case() == kPlayerLecternPageTurn) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerLecternPageTurnEvent*>(_impl_.payload_.player_lectern_page_turn_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_lectern_page_turn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerLecternPageTurnEvent& EventEnvelope::_internal_player_lectern_page_turn() const {
  return payload_case() == kPlayerLecternPageTurn ? static_cast<const ::df::plugin::PlayerLecternPageTurnEvent&>(*reinterpret_cast<::df::plugin::PlayerLecternPageTurnEvent*>(_impl_.payload_.player_lectern_page_turn_))
                     : reinterpret_cast<const ::df::plugin::PlayerLecternPageTurnEvent&>(::df::plugin::_PlayerLecternPageTurnEvent_default_instance_);
}
inline const ::df::plugin::PlayerLecternPageTurnEvent& EventEnvelope::player_lectern_page_turn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_lectern_page_turn)
  return _internal_player_lectern_page_turn();
}
inline ::df::plugin::PlayerLecternPageTurnEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_lectern_page_turn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_lectern_page_turn)
  if (payload_case() == kPlayerLecternPageTurn) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerLecternPageTurnEvent*>(_impl_.payload_.player_lectern_page_turn_);
    _impl_.payload_.player_lectern_page_turn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_lectern_page_turn(
    ::df::plugin::PlayerLecternPageTurnEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_lectern_page_turn();
    _impl_.payload_.player_lectern_page_turn_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_lectern_page_turn)
}
inline ::df::plugin::PlayerLecternPageTurnEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_lectern_page_turn() {
  if (payload_case() != kPlayerLecternPageTurn) {
    clear_payload();
    set_has_player_lectern_page_turn();
    _impl_.payload_.player_lectern_page_turn_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerLecternPageTurnEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerLecternPageTurnEvent*>(_impl_.payload_.player_lectern_page_turn_);
}
inline ::df::plugin::PlayerLecternPageTurnEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_lectern_page_turn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerLecternPageTurnEvent* _msg = _internal_mutable_player_lectern_page_turn();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_lectern_page_turn)
  return _msg;
}

// .df.plugin.PlayerItemDamageEvent player_item_damage = 40 [json_name = "playerItemDamage"];
inline bool EventEnvelope::has_player_item_damage() const {
  return payload_case() == kPlayerItemDamage;
}
inline bool EventEnvelope::_internal_has_player_item_damage() const {
  return payload_case() == kPlayerItemDamage;
}
inline void EventEnvelope::set_has_player_item_damage() {
  _impl_._oneof_case_[0] = kPlayerItemDamage;
}
inline ::df::plugin::PlayerItemDamageEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_item_damage() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_item_damage)
  if (payload_case() == kPlayerItemDamage) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemDamageEvent*>(_impl_.payload_.player_item_damage_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_item_damage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerItemDamageEvent& EventEnvelope::_internal_player_item_damage() const {
  return payload_case() == kPlayerItemDamage ? static_cast<const ::df::plugin::PlayerItemDamageEvent&>(*reinterpret_cast<::df::plugin::PlayerItemDamageEvent*>(_impl_.payload_.player_item_damage_))
                     : reinterpret_cast<const ::df::plugin::PlayerItemDamageEvent&>(::df::plugin::_PlayerItemDamageEvent_default_instance_);
}
inline const ::df::plugin::PlayerItemDamageEvent& EventEnvelope::player_item_damage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_item_damage)
  return _internal_player_item_damage();
}
inline ::df::plugin::PlayerItemDamageEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_item_damage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_item_damage)
  if (payload_case() == kPlayerItemDamage) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemDamageEvent*>(_impl_.payload_.player_item_damage_);
    _impl_.payload_.player_item_damage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_item_damage(
    ::df::plugin::PlayerItemDamageEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_item_damage();
    _impl_.payload_.player_item_damage_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_item_damage)
}
inline ::df::plugin::PlayerItemDamageEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_item_damage() {
  if (payload_case() != kPlayerItemDamage) {
    clear_payload();
    set_has_player_item_damage();
    _impl_.payload_.player_item_damage_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerItemDamageEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerItemDamageEvent*>(_impl_.payload_.player_item_damage_);
}
inline ::df::plugin::PlayerItemDamageEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_item_damage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerItemDamageEvent* _msg = _internal_mutable_player_item_damage();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_item_damage)
  return _msg;
}

// .df.plugin.PlayerItemPickupEvent player_item_pickup = 41 [json_name = "playerItemPickup"];
inline bool EventEnvelope::has_player_item_pickup() const {
  return payload_case() == kPlayerItemPickup;
}
inline bool EventEnvelope::_internal_has_player_item_pickup() const {
  return payload_case() == kPlayerItemPickup;
}
inline void EventEnvelope::set_has_player_item_pickup() {
  _impl_._oneof_case_[0] = kPlayerItemPickup;
}
inline ::df::plugin::PlayerItemPickupEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_item_pickup() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_item_pickup)
  if (payload_case() == kPlayerItemPickup) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemPickupEvent*>(_impl_.payload_.player_item_pickup_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_item_pickup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerItemPickupEvent& EventEnvelope::_internal_player_item_pickup() const {
  return payload_case() == kPlayerItemPickup ? static_cast<const ::df::plugin::PlayerItemPickupEvent&>(*reinterpret_cast<::df::plugin::PlayerItemPickupEvent*>(_impl_.payload_.player_item_pickup_))
                     : reinterpret_cast<const ::df::plugin::PlayerItemPickupEvent&>(::df::plugin::_PlayerItemPickupEvent_default_instance_);
}
inline const ::df::plugin::PlayerItemPickupEvent& EventEnvelope::player_item_pickup() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_item_pickup)
  return _internal_player_item_pickup();
}
inline ::df::plugin::PlayerItemPickupEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_item_pickup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_item_pickup)
  if (payload_case() == kPlayerItemPickup) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemPickupEvent*>(_impl_.payload_.player_item_pickup_);
    _impl_.payload_.player_item_pickup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_item_pickup(
    ::df::plugin::PlayerItemPickupEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_item_pickup();
    _impl_.payload_.player_item_pickup_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_item_pickup)
}
inline ::df::plugin::PlayerItemPickupEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_item_pickup() {
  if (payload_case() != kPlayerItemPickup) {
    clear_payload();
    set_has_player_item_pickup();
    _impl_.payload_.player_item_pickup_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerItemPickupEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerItemPickupEvent*>(_impl_.payload_.player_item_pickup_);
}
inline ::df::plugin::PlayerItemPickupEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_item_pickup()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerItemPickupEvent* _msg = _internal_mutable_player_item_pickup();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_item_pickup)
  return _msg;
}

// .df.plugin.PlayerHeldSlotChangeEvent player_held_slot_change = 42 [json_name = "playerHeldSlotChange"];
inline bool EventEnvelope::has_player_held_slot_change() const {
  return payload_case() == kPlayerHeldSlotChange;
}
inline bool EventEnvelope::_internal_has_player_held_slot_change() const {
  return payload_case() == kPlayerHeldSlotChange;
}
inline void EventEnvelope::set_has_player_held_slot_change() {
  _impl_._oneof_case_[0] = kPlayerHeldSlotChange;
}
inline ::df::plugin::PlayerHeldSlotChangeEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_held_slot_change() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_held_slot_change)
  if (payload_case() == kPlayerHeldSlotChange) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerHeldSlotChangeEvent*>(_impl_.payload_.player_held_slot_change_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_held_slot_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerHeldSlotChangeEvent& EventEnvelope::_internal_player_held_slot_change() const {
  return payload_case() == kPlayerHeldSlotChange ? static_cast<const ::df::plugin::PlayerHeldSlotChangeEvent&>(*reinterpret_cast<::df::plugin::PlayerHeldSlotChangeEvent*>(_impl_.payload_.player_held_slot_change_))
                     : reinterpret_cast<const ::df::plugin::PlayerHeldSlotChangeEvent&>(::df::plugin::_PlayerHeldSlotChangeEvent_default_instance_);
}
inline const ::df::plugin::PlayerHeldSlotChangeEvent& EventEnvelope::player_held_slot_change() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_held_slot_change)
  return _internal_player_held_slot_change();
}
inline ::df::plugin::PlayerHeldSlotChangeEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_held_slot_change() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_held_slot_change)
  if (payload_case() == kPlayerHeldSlotChange) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerHeldSlotChangeEvent*>(_impl_.payload_.player_held_slot_change_);
    _impl_.payload_.player_held_slot_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_held_slot_change(
    ::df::plugin::PlayerHeldSlotChangeEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_held_slot_change();
    _impl_.payload_.player_held_slot_change_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_held_slot_change)
}
inline ::df::plugin::PlayerHeldSlotChangeEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_held_slot_change() {
  if (payload_case() != kPlayerHeldSlotChange) {
    clear_payload();
    set_has_player_held_slot_change();
    _impl_.payload_.player_held_slot_change_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerHeldSlotChangeEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerHeldSlotChangeEvent*>(_impl_.payload_.player_held_slot_change_);
}
inline ::df::plugin::PlayerHeldSlotChangeEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_held_slot_change()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerHeldSlotChangeEvent* _msg = _internal_mutable_player_held_slot_change();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_held_slot_change)
  return _msg;
}

// .df.plugin.PlayerItemDropEvent player_item_drop = 43 [json_name = "playerItemDrop"];
inline bool EventEnvelope::has_player_item_drop() const {
  return payload_case() == kPlayerItemDrop;
}
inline bool EventEnvelope::_internal_has_player_item_drop() const {
  return payload_case() == kPlayerItemDrop;
}
inline void EventEnvelope::set_has_player_item_drop() {
  _impl_._oneof_case_[0] = kPlayerItemDrop;
}
inline ::df::plugin::PlayerItemDropEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_item_drop() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_item_drop)
  if (payload_case() == kPlayerItemDrop) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemDropEvent*>(_impl_.payload_.player_item_drop_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_item_drop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerItemDropEvent& EventEnvelope::_internal_player_item_drop() const {
  return payload_case() == kPlayerItemDrop ? static_cast<const ::df::plugin::PlayerItemDropEvent&>(*reinterpret_cast<::df::plugin::PlayerItemDropEvent*>(_impl_.payload_.player_item_drop_))
                     : reinterpret_cast<const ::df::plugin::PlayerItemDropEvent&>(::df::plugin::_PlayerItemDropEvent_default_instance_);
}
inline const ::df::plugin::PlayerItemDropEvent& EventEnvelope::player_item_drop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_item_drop)
  return _internal_player_item_drop();
}
inline ::df::plugin::PlayerItemDropEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_item_drop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_item_drop)
  if (payload_case() == kPlayerItemDrop) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerItemDropEvent*>(_impl_.payload_.player_item_drop_);
    _impl_.payload_.player_item_drop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_item_drop(
    ::df::plugin::PlayerItemDropEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_item_drop();
    _impl_.payload_.player_item_drop_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_item_drop)
}
inline ::df::plugin::PlayerItemDropEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_item_drop() {
  if (payload_case() != kPlayerItemDrop) {
    clear_payload();
    set_has_player_item_drop();
    _impl_.payload_.player_item_drop_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerItemDropEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerItemDropEvent*>(_impl_.payload_.player_item_drop_);
}
inline ::df::plugin::PlayerItemDropEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_item_drop()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerItemDropEvent* _msg = _internal_mutable_player_item_drop();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_item_drop)
  return _msg;
}

// .df.plugin.PlayerTransferEvent player_transfer = 44 [json_name = "playerTransfer"];
inline bool EventEnvelope::has_player_transfer() const {
  return payload_case() == kPlayerTransfer;
}
inline bool EventEnvelope::_internal_has_player_transfer() const {
  return payload_case() == kPlayerTransfer;
}
inline void EventEnvelope::set_has_player_transfer() {
  _impl_._oneof_case_[0] = kPlayerTransfer;
}
inline ::df::plugin::PlayerTransferEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_transfer() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_transfer)
  if (payload_case() == kPlayerTransfer) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerTransferEvent*>(_impl_.payload_.player_transfer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerTransferEvent& EventEnvelope::_internal_player_transfer() const {
  return payload_case() == kPlayerTransfer ? static_cast<const ::df::plugin::PlayerTransferEvent&>(*reinterpret_cast<::df::plugin::PlayerTransferEvent*>(_impl_.payload_.player_transfer_))
                     : reinterpret_cast<const ::df::plugin::PlayerTransferEvent&>(::df::plugin::_PlayerTransferEvent_default_instance_);
}
inline const ::df::plugin::PlayerTransferEvent& EventEnvelope::player_transfer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_transfer)
  return _internal_player_transfer();
}
inline ::df::plugin::PlayerTransferEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_transfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_transfer)
  if (payload_case() == kPlayerTransfer) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerTransferEvent*>(_impl_.payload_.player_transfer_);
    _impl_.payload_.player_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_transfer(
    ::df::plugin::PlayerTransferEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_transfer();
    _impl_.payload_.player_transfer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_transfer)
}
inline ::df::plugin::PlayerTransferEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_transfer() {
  if (payload_case() != kPlayerTransfer) {
    clear_payload();
    set_has_player_transfer();
    _impl_.payload_.player_transfer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerTransferEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerTransferEvent*>(_impl_.payload_.player_transfer_);
}
inline ::df::plugin::PlayerTransferEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_transfer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerTransferEvent* _msg = _internal_mutable_player_transfer();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_transfer)
  return _msg;
}

// .df.plugin.CommandEvent command = 45 [json_name = "command"];
inline bool EventEnvelope::has_command() const {
  return payload_case() == kCommand;
}
inline bool EventEnvelope::_internal_has_command() const {
  return payload_case() == kCommand;
}
inline void EventEnvelope::set_has_command() {
  _impl_._oneof_case_[0] = kCommand;
}
inline ::df::plugin::CommandEvent* PROTOBUF_NULLABLE EventEnvelope::release_command() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.command)
  if (payload_case() == kCommand) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::CommandEvent*>(_impl_.payload_.command_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::CommandEvent& EventEnvelope::_internal_command() const {
  return payload_case() == kCommand ? static_cast<const ::df::plugin::CommandEvent&>(*reinterpret_cast<::df::plugin::CommandEvent*>(_impl_.payload_.command_))
                     : reinterpret_cast<const ::df::plugin::CommandEvent&>(::df::plugin::_CommandEvent_default_instance_);
}
inline const ::df::plugin::CommandEvent& EventEnvelope::command() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.command)
  return _internal_command();
}
inline ::df::plugin::CommandEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.command)
  if (payload_case() == kCommand) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::CommandEvent*>(_impl_.payload_.command_);
    _impl_.payload_.command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_command(
    ::df::plugin::CommandEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_command();
    _impl_.payload_.command_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.command)
}
inline ::df::plugin::CommandEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_command() {
  if (payload_case() != kCommand) {
    clear_payload();
    set_has_command();
    _impl_.payload_.command_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::CommandEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::CommandEvent*>(_impl_.payload_.command_);
}
inline ::df::plugin::CommandEvent* PROTOBUF_NONNULL EventEnvelope::mutable_command()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::CommandEvent* _msg = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.command)
  return _msg;
}

// .df.plugin.PlayerDiagnosticsEvent player_diagnostics = 46 [json_name = "playerDiagnostics"];
inline bool EventEnvelope::has_player_diagnostics() const {
  return payload_case() == kPlayerDiagnostics;
}
inline bool EventEnvelope::_internal_has_player_diagnostics() const {
  return payload_case() == kPlayerDiagnostics;
}
inline void EventEnvelope::set_has_player_diagnostics() {
  _impl_._oneof_case_[0] = kPlayerDiagnostics;
}
inline ::df::plugin::PlayerDiagnosticsEvent* PROTOBUF_NULLABLE EventEnvelope::release_player_diagnostics() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.player_diagnostics)
  if (payload_case() == kPlayerDiagnostics) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerDiagnosticsEvent*>(_impl_.payload_.player_diagnostics_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_diagnostics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PlayerDiagnosticsEvent& EventEnvelope::_internal_player_diagnostics() const {
  return payload_case() == kPlayerDiagnostics ? static_cast<const ::df::plugin::PlayerDiagnosticsEvent&>(*reinterpret_cast<::df::plugin::PlayerDiagnosticsEvent*>(_impl_.payload_.player_diagnostics_))
                     : reinterpret_cast<const ::df::plugin::PlayerDiagnosticsEvent&>(::df::plugin::_PlayerDiagnosticsEvent_default_instance_);
}
inline const ::df::plugin::PlayerDiagnosticsEvent& EventEnvelope::player_diagnostics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.player_diagnostics)
  return _internal_player_diagnostics();
}
inline ::df::plugin::PlayerDiagnosticsEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_player_diagnostics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.player_diagnostics)
  if (payload_case() == kPlayerDiagnostics) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PlayerDiagnosticsEvent*>(_impl_.payload_.player_diagnostics_);
    _impl_.payload_.player_diagnostics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_player_diagnostics(
    ::df::plugin::PlayerDiagnosticsEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_diagnostics();
    _impl_.payload_.player_diagnostics_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.player_diagnostics)
}
inline ::df::plugin::PlayerDiagnosticsEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_player_diagnostics() {
  if (payload_case() != kPlayerDiagnostics) {
    clear_payload();
    set_has_player_diagnostics();
    _impl_.payload_.player_diagnostics_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PlayerDiagnosticsEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PlayerDiagnosticsEvent*>(_impl_.payload_.player_diagnostics_);
}
inline ::df::plugin::PlayerDiagnosticsEvent* PROTOBUF_NONNULL EventEnvelope::mutable_player_diagnostics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PlayerDiagnosticsEvent* _msg = _internal_mutable_player_diagnostics();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.player_diagnostics)
  return _msg;
}

// .df.plugin.WorldLiquidFlowEvent world_liquid_flow = 70 [json_name = "worldLiquidFlow"];
inline bool EventEnvelope::has_world_liquid_flow() const {
  return payload_case() == kWorldLiquidFlow;
}
inline bool EventEnvelope::_internal_has_world_liquid_flow() const {
  return payload_case() == kWorldLiquidFlow;
}
inline void EventEnvelope::set_has_world_liquid_flow() {
  _impl_._oneof_case_[0] = kWorldLiquidFlow;
}
inline ::df::plugin::WorldLiquidFlowEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_liquid_flow() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_liquid_flow)
  if (payload_case() == kWorldLiquidFlow) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldLiquidFlowEvent*>(_impl_.payload_.world_liquid_flow_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_liquid_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldLiquidFlowEvent& EventEnvelope::_internal_world_liquid_flow() const {
  return payload_case() == kWorldLiquidFlow ? static_cast<const ::df::plugin::WorldLiquidFlowEvent&>(*reinterpret_cast<::df::plugin::WorldLiquidFlowEvent*>(_impl_.payload_.world_liquid_flow_))
                     : reinterpret_cast<const ::df::plugin::WorldLiquidFlowEvent&>(::df::plugin::_WorldLiquidFlowEvent_default_instance_);
}
inline const ::df::plugin::WorldLiquidFlowEvent& EventEnvelope::world_liquid_flow() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_liquid_flow)
  return _internal_world_liquid_flow();
}
inline ::df::plugin::WorldLiquidFlowEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_liquid_flow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_liquid_flow)
  if (payload_case() == kWorldLiquidFlow) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldLiquidFlowEvent*>(_impl_.payload_.world_liquid_flow_);
    _impl_.payload_.world_liquid_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_liquid_flow(
    ::df::plugin::WorldLiquidFlowEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_liquid_flow();
    _impl_.payload_.world_liquid_flow_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_liquid_flow)
}
inline ::df::plugin::WorldLiquidFlowEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_liquid_flow() {
  if (payload_case() != kWorldLiquidFlow) {
    clear_payload();
    set_has_world_liquid_flow();
    _impl_.payload_.world_liquid_flow_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldLiquidFlowEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldLiquidFlowEvent*>(_impl_.payload_.world_liquid_flow_);
}
inline ::df::plugin::WorldLiquidFlowEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_liquid_flow()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldLiquidFlowEvent* _msg = _internal_mutable_world_liquid_flow();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_liquid_flow)
  return _msg;
}

// .df.plugin.WorldLiquidDecayEvent world_liquid_decay = 71 [json_name = "worldLiquidDecay"];
inline bool EventEnvelope::has_world_liquid_decay() const {
  return payload_case() == kWorldLiquidDecay;
}
inline bool EventEnvelope::_internal_has_world_liquid_decay() const {
  return payload_case() == kWorldLiquidDecay;
}
inline void EventEnvelope::set_has_world_liquid_decay() {
  _impl_._oneof_case_[0] = kWorldLiquidDecay;
}
inline ::df::plugin::WorldLiquidDecayEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_liquid_decay() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_liquid_decay)
  if (payload_case() == kWorldLiquidDecay) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldLiquidDecayEvent*>(_impl_.payload_.world_liquid_decay_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_liquid_decay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldLiquidDecayEvent& EventEnvelope::_internal_world_liquid_decay() const {
  return payload_case() == kWorldLiquidDecay ? static_cast<const ::df::plugin::WorldLiquidDecayEvent&>(*reinterpret_cast<::df::plugin::WorldLiquidDecayEvent*>(_impl_.payload_.world_liquid_decay_))
                     : reinterpret_cast<const ::df::plugin::WorldLiquidDecayEvent&>(::df::plugin::_WorldLiquidDecayEvent_default_instance_);
}
inline const ::df::plugin::WorldLiquidDecayEvent& EventEnvelope::world_liquid_decay() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_liquid_decay)
  return _internal_world_liquid_decay();
}
inline ::df::plugin::WorldLiquidDecayEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_liquid_decay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_liquid_decay)
  if (payload_case() == kWorldLiquidDecay) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldLiquidDecayEvent*>(_impl_.payload_.world_liquid_decay_);
    _impl_.payload_.world_liquid_decay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_liquid_decay(
    ::df::plugin::WorldLiquidDecayEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_liquid_decay();
    _impl_.payload_.world_liquid_decay_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_liquid_decay)
}
inline ::df::plugin::WorldLiquidDecayEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_liquid_decay() {
  if (payload_case() != kWorldLiquidDecay) {
    clear_payload();
    set_has_world_liquid_decay();
    _impl_.payload_.world_liquid_decay_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldLiquidDecayEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldLiquidDecayEvent*>(_impl_.payload_.world_liquid_decay_);
}
inline ::df::plugin::WorldLiquidDecayEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_liquid_decay()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldLiquidDecayEvent* _msg = _internal_mutable_world_liquid_decay();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_liquid_decay)
  return _msg;
}

// .df.plugin.WorldLiquidHardenEvent world_liquid_harden = 72 [json_name = "worldLiquidHarden"];
inline bool EventEnvelope::has_world_liquid_harden() const {
  return payload_case() == kWorldLiquidHarden;
}
inline bool EventEnvelope::_internal_has_world_liquid_harden() const {
  return payload_case() == kWorldLiquidHarden;
}
inline void EventEnvelope::set_has_world_liquid_harden() {
  _impl_._oneof_case_[0] = kWorldLiquidHarden;
}
inline ::df::plugin::WorldLiquidHardenEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_liquid_harden() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_liquid_harden)
  if (payload_case() == kWorldLiquidHarden) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldLiquidHardenEvent*>(_impl_.payload_.world_liquid_harden_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_liquid_harden_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldLiquidHardenEvent& EventEnvelope::_internal_world_liquid_harden() const {
  return payload_case() == kWorldLiquidHarden ? static_cast<const ::df::plugin::WorldLiquidHardenEvent&>(*reinterpret_cast<::df::plugin::WorldLiquidHardenEvent*>(_impl_.payload_.world_liquid_harden_))
                     : reinterpret_cast<const ::df::plugin::WorldLiquidHardenEvent&>(::df::plugin::_WorldLiquidHardenEvent_default_instance_);
}
inline const ::df::plugin::WorldLiquidHardenEvent& EventEnvelope::world_liquid_harden() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_liquid_harden)
  return _internal_world_liquid_harden();
}
inline ::df::plugin::WorldLiquidHardenEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_liquid_harden() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_liquid_harden)
  if (payload_case() == kWorldLiquidHarden) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldLiquidHardenEvent*>(_impl_.payload_.world_liquid_harden_);
    _impl_.payload_.world_liquid_harden_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_liquid_harden(
    ::df::plugin::WorldLiquidHardenEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_liquid_harden();
    _impl_.payload_.world_liquid_harden_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_liquid_harden)
}
inline ::df::plugin::WorldLiquidHardenEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_liquid_harden() {
  if (payload_case() != kWorldLiquidHarden) {
    clear_payload();
    set_has_world_liquid_harden();
    _impl_.payload_.world_liquid_harden_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldLiquidHardenEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldLiquidHardenEvent*>(_impl_.payload_.world_liquid_harden_);
}
inline ::df::plugin::WorldLiquidHardenEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_liquid_harden()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldLiquidHardenEvent* _msg = _internal_mutable_world_liquid_harden();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_liquid_harden)
  return _msg;
}

// .df.plugin.WorldSoundEvent world_sound = 73 [json_name = "worldSound"];
inline bool EventEnvelope::has_world_sound() const {
  return payload_case() == kWorldSound;
}
inline bool EventEnvelope::_internal_has_world_sound() const {
  return payload_case() == kWorldSound;
}
inline void EventEnvelope::set_has_world_sound() {
  _impl_._oneof_case_[0] = kWorldSound;
}
inline ::df::plugin::WorldSoundEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_sound() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_sound)
  if (payload_case() == kWorldSound) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldSoundEvent*>(_impl_.payload_.world_sound_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_sound_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldSoundEvent& EventEnvelope::_internal_world_sound() const {
  return payload_case() == kWorldSound ? static_cast<const ::df::plugin::WorldSoundEvent&>(*reinterpret_cast<::df::plugin::WorldSoundEvent*>(_impl_.payload_.world_sound_))
                     : reinterpret_cast<const ::df::plugin::WorldSoundEvent&>(::df::plugin::_WorldSoundEvent_default_instance_);
}
inline const ::df::plugin::WorldSoundEvent& EventEnvelope::world_sound() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_sound)
  return _internal_world_sound();
}
inline ::df::plugin::WorldSoundEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_sound() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_sound)
  if (payload_case() == kWorldSound) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldSoundEvent*>(_impl_.payload_.world_sound_);
    _impl_.payload_.world_sound_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_sound(
    ::df::plugin::WorldSoundEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_sound();
    _impl_.payload_.world_sound_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_sound)
}
inline ::df::plugin::WorldSoundEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_sound() {
  if (payload_case() != kWorldSound) {
    clear_payload();
    set_has_world_sound();
    _impl_.payload_.world_sound_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldSoundEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldSoundEvent*>(_impl_.payload_.world_sound_);
}
inline ::df::plugin::WorldSoundEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_sound()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldSoundEvent* _msg = _internal_mutable_world_sound();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_sound)
  return _msg;
}

// .df.plugin.WorldFireSpreadEvent world_fire_spread = 74 [json_name = "worldFireSpread"];
inline bool EventEnvelope::has_world_fire_spread() const {
  return payload_case() == kWorldFireSpread;
}
inline bool EventEnvelope::_internal_has_world_fire_spread() const {
  return payload_case() == kWorldFireSpread;
}
inline void EventEnvelope::set_has_world_fire_spread() {
  _impl_._oneof_case_[0] = kWorldFireSpread;
}
inline ::df::plugin::WorldFireSpreadEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_fire_spread() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_fire_spread)
  if (payload_case() == kWorldFireSpread) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldFireSpreadEvent*>(_impl_.payload_.world_fire_spread_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_fire_spread_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldFireSpreadEvent& EventEnvelope::_internal_world_fire_spread() const {
  return payload_case() == kWorldFireSpread ? static_cast<const ::df::plugin::WorldFireSpreadEvent&>(*reinterpret_cast<::df::plugin::WorldFireSpreadEvent*>(_impl_.payload_.world_fire_spread_))
                     : reinterpret_cast<const ::df::plugin::WorldFireSpreadEvent&>(::df::plugin::_WorldFireSpreadEvent_default_instance_);
}
inline const ::df::plugin::WorldFireSpreadEvent& EventEnvelope::world_fire_spread() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_fire_spread)
  return _internal_world_fire_spread();
}
inline ::df::plugin::WorldFireSpreadEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_fire_spread() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_fire_spread)
  if (payload_case() == kWorldFireSpread) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldFireSpreadEvent*>(_impl_.payload_.world_fire_spread_);
    _impl_.payload_.world_fire_spread_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_fire_spread(
    ::df::plugin::WorldFireSpreadEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_fire_spread();
    _impl_.payload_.world_fire_spread_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_fire_spread)
}
inline ::df::plugin::WorldFireSpreadEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_fire_spread() {
  if (payload_case() != kWorldFireSpread) {
    clear_payload();
    set_has_world_fire_spread();
    _impl_.payload_.world_fire_spread_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldFireSpreadEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldFireSpreadEvent*>(_impl_.payload_.world_fire_spread_);
}
inline ::df::plugin::WorldFireSpreadEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_fire_spread()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldFireSpreadEvent* _msg = _internal_mutable_world_fire_spread();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_fire_spread)
  return _msg;
}

// .df.plugin.WorldBlockBurnEvent world_block_burn = 75 [json_name = "worldBlockBurn"];
inline bool EventEnvelope::has_world_block_burn() const {
  return payload_case() == kWorldBlockBurn;
}
inline bool EventEnvelope::_internal_has_world_block_burn() const {
  return payload_case() == kWorldBlockBurn;
}
inline void EventEnvelope::set_has_world_block_burn() {
  _impl_._oneof_case_[0] = kWorldBlockBurn;
}
inline ::df::plugin::WorldBlockBurnEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_block_burn() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_block_burn)
  if (payload_case() == kWorldBlockBurn) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldBlockBurnEvent*>(_impl_.payload_.world_block_burn_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_block_burn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldBlockBurnEvent& EventEnvelope::_internal_world_block_burn() const {
  return payload_case() == kWorldBlockBurn ? static_cast<const ::df::plugin::WorldBlockBurnEvent&>(*reinterpret_cast<::df::plugin::WorldBlockBurnEvent*>(_impl_.payload_.world_block_burn_))
                     : reinterpret_cast<const ::df::plugin::WorldBlockBurnEvent&>(::df::plugin::_WorldBlockBurnEvent_default_instance_);
}
inline const ::df::plugin::WorldBlockBurnEvent& EventEnvelope::world_block_burn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_block_burn)
  return _internal_world_block_burn();
}
inline ::df::plugin::WorldBlockBurnEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_block_burn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_block_burn)
  if (payload_case() == kWorldBlockBurn) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldBlockBurnEvent*>(_impl_.payload_.world_block_burn_);
    _impl_.payload_.world_block_burn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_block_burn(
    ::df::plugin::WorldBlockBurnEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_block_burn();
    _impl_.payload_.world_block_burn_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_block_burn)
}
inline ::df::plugin::WorldBlockBurnEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_block_burn() {
  if (payload_case() != kWorldBlockBurn) {
    clear_payload();
    set_has_world_block_burn();
    _impl_.payload_.world_block_burn_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldBlockBurnEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldBlockBurnEvent*>(_impl_.payload_.world_block_burn_);
}
inline ::df::plugin::WorldBlockBurnEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_block_burn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldBlockBurnEvent* _msg = _internal_mutable_world_block_burn();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_block_burn)
  return _msg;
}

// .df.plugin.WorldCropTrampleEvent world_crop_trample = 76 [json_name = "worldCropTrample"];
inline bool EventEnvelope::has_world_crop_trample() const {
  return payload_case() == kWorldCropTrample;
}
inline bool EventEnvelope::_internal_has_world_crop_trample() const {
  return payload_case() == kWorldCropTrample;
}
inline void EventEnvelope::set_has_world_crop_trample() {
  _impl_._oneof_case_[0] = kWorldCropTrample;
}
inline ::df::plugin::WorldCropTrampleEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_crop_trample() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_crop_trample)
  if (payload_case() == kWorldCropTrample) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldCropTrampleEvent*>(_impl_.payload_.world_crop_trample_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_crop_trample_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldCropTrampleEvent& EventEnvelope::_internal_world_crop_trample() const {
  return payload_case() == kWorldCropTrample ? static_cast<const ::df::plugin::WorldCropTrampleEvent&>(*reinterpret_cast<::df::plugin::WorldCropTrampleEvent*>(_impl_.payload_.world_crop_trample_))
                     : reinterpret_cast<const ::df::plugin::WorldCropTrampleEvent&>(::df::plugin::_WorldCropTrampleEvent_default_instance_);
}
inline const ::df::plugin::WorldCropTrampleEvent& EventEnvelope::world_crop_trample() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_crop_trample)
  return _internal_world_crop_trample();
}
inline ::df::plugin::WorldCropTrampleEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_crop_trample() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_crop_trample)
  if (payload_case() == kWorldCropTrample) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldCropTrampleEvent*>(_impl_.payload_.world_crop_trample_);
    _impl_.payload_.world_crop_trample_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_crop_trample(
    ::df::plugin::WorldCropTrampleEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_crop_trample();
    _impl_.payload_.world_crop_trample_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_crop_trample)
}
inline ::df::plugin::WorldCropTrampleEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_crop_trample() {
  if (payload_case() != kWorldCropTrample) {
    clear_payload();
    set_has_world_crop_trample();
    _impl_.payload_.world_crop_trample_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldCropTrampleEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldCropTrampleEvent*>(_impl_.payload_.world_crop_trample_);
}
inline ::df::plugin::WorldCropTrampleEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_crop_trample()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldCropTrampleEvent* _msg = _internal_mutable_world_crop_trample();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_crop_trample)
  return _msg;
}

// .df.plugin.WorldLeavesDecayEvent world_leaves_decay = 77 [json_name = "worldLeavesDecay"];
inline bool EventEnvelope::has_world_leaves_decay() const {
  return payload_case() == kWorldLeavesDecay;
}
inline bool EventEnvelope::_internal_has_world_leaves_decay() const {
  return payload_case() == kWorldLeavesDecay;
}
inline void EventEnvelope::set_has_world_leaves_decay() {
  _impl_._oneof_case_[0] = kWorldLeavesDecay;
}
inline ::df::plugin::WorldLeavesDecayEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_leaves_decay() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_leaves_decay)
  if (payload_case() == kWorldLeavesDecay) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldLeavesDecayEvent*>(_impl_.payload_.world_leaves_decay_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_leaves_decay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldLeavesDecayEvent& EventEnvelope::_internal_world_leaves_decay() const {
  return payload_case() == kWorldLeavesDecay ? static_cast<const ::df::plugin::WorldLeavesDecayEvent&>(*reinterpret_cast<::df::plugin::WorldLeavesDecayEvent*>(_impl_.payload_.world_leaves_decay_))
                     : reinterpret_cast<const ::df::plugin::WorldLeavesDecayEvent&>(::df::plugin::_WorldLeavesDecayEvent_default_instance_);
}
inline const ::df::plugin::WorldLeavesDecayEvent& EventEnvelope::world_leaves_decay() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_leaves_decay)
  return _internal_world_leaves_decay();
}
inline ::df::plugin::WorldLeavesDecayEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_leaves_decay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_leaves_decay)
  if (payload_case() == kWorldLeavesDecay) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldLeavesDecayEvent*>(_impl_.payload_.world_leaves_decay_);
    _impl_.payload_.world_leaves_decay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_leaves_decay(
    ::df::plugin::WorldLeavesDecayEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_leaves_decay();
    _impl_.payload_.world_leaves_decay_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_leaves_decay)
}
inline ::df::plugin::WorldLeavesDecayEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_leaves_decay() {
  if (payload_case() != kWorldLeavesDecay) {
    clear_payload();
    set_has_world_leaves_decay();
    _impl_.payload_.world_leaves_decay_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldLeavesDecayEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldLeavesDecayEvent*>(_impl_.payload_.world_leaves_decay_);
}
inline ::df::plugin::WorldLeavesDecayEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_leaves_decay()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldLeavesDecayEvent* _msg = _internal_mutable_world_leaves_decay();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_leaves_decay)
  return _msg;
}

// .df.plugin.WorldEntitySpawnEvent world_entity_spawn = 78 [json_name = "worldEntitySpawn"];
inline bool EventEnvelope::has_world_entity_spawn() const {
  return payload_case() == kWorldEntitySpawn;
}
inline bool EventEnvelope::_internal_has_world_entity_spawn() const {
  return payload_case() == kWorldEntitySpawn;
}
inline void EventEnvelope::set_has_world_entity_spawn() {
  _impl_._oneof_case_[0] = kWorldEntitySpawn;
}
inline ::df::plugin::WorldEntitySpawnEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_entity_spawn() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_entity_spawn)
  if (payload_case() == kWorldEntitySpawn) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldEntitySpawnEvent*>(_impl_.payload_.world_entity_spawn_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_entity_spawn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldEntitySpawnEvent& EventEnvelope::_internal_world_entity_spawn() const {
  return payload_case() == kWorldEntitySpawn ? static_cast<const ::df::plugin::WorldEntitySpawnEvent&>(*reinterpret_cast<::df::plugin::WorldEntitySpawnEvent*>(_impl_.payload_.world_entity_spawn_))
                     : reinterpret_cast<const ::df::plugin::WorldEntitySpawnEvent&>(::df::plugin::_WorldEntitySpawnEvent_default_instance_);
}
inline const ::df::plugin::WorldEntitySpawnEvent& EventEnvelope::world_entity_spawn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_entity_spawn)
  return _internal_world_entity_spawn();
}
inline ::df::plugin::WorldEntitySpawnEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_entity_spawn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_entity_spawn)
  if (payload_case() == kWorldEntitySpawn) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldEntitySpawnEvent*>(_impl_.payload_.world_entity_spawn_);
    _impl_.payload_.world_entity_spawn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_entity_spawn(
    ::df::plugin::WorldEntitySpawnEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_entity_spawn();
    _impl_.payload_.world_entity_spawn_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_entity_spawn)
}
inline ::df::plugin::WorldEntitySpawnEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_entity_spawn() {
  if (payload_case() != kWorldEntitySpawn) {
    clear_payload();
    set_has_world_entity_spawn();
    _impl_.payload_.world_entity_spawn_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldEntitySpawnEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldEntitySpawnEvent*>(_impl_.payload_.world_entity_spawn_);
}
inline ::df::plugin::WorldEntitySpawnEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_entity_spawn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldEntitySpawnEvent* _msg = _internal_mutable_world_entity_spawn();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_entity_spawn)
  return _msg;
}

// .df.plugin.WorldEntityDespawnEvent world_entity_despawn = 79 [json_name = "worldEntityDespawn"];
inline bool EventEnvelope::has_world_entity_despawn() const {
  return payload_case() == kWorldEntityDespawn;
}
inline bool EventEnvelope::_internal_has_world_entity_despawn() const {
  return payload_case() == kWorldEntityDespawn;
}
inline void EventEnvelope::set_has_world_entity_despawn() {
  _impl_._oneof_case_[0] = kWorldEntityDespawn;
}
inline ::df::plugin::WorldEntityDespawnEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_entity_despawn() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_entity_despawn)
  if (payload_case() == kWorldEntityDespawn) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldEntityDespawnEvent*>(_impl_.payload_.world_entity_despawn_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_entity_despawn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldEntityDespawnEvent& EventEnvelope::_internal_world_entity_despawn() const {
  return payload_case() == kWorldEntityDespawn ? static_cast<const ::df::plugin::WorldEntityDespawnEvent&>(*reinterpret_cast<::df::plugin::WorldEntityDespawnEvent*>(_impl_.payload_.world_entity_despawn_))
                     : reinterpret_cast<const ::df::plugin::WorldEntityDespawnEvent&>(::df::plugin::_WorldEntityDespawnEvent_default_instance_);
}
inline const ::df::plugin::WorldEntityDespawnEvent& EventEnvelope::world_entity_despawn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_entity_despawn)
  return _internal_world_entity_despawn();
}
inline ::df::plugin::WorldEntityDespawnEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_entity_despawn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_entity_despawn)
  if (payload_case() == kWorldEntityDespawn) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldEntityDespawnEvent*>(_impl_.payload_.world_entity_despawn_);
    _impl_.payload_.world_entity_despawn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_entity_despawn(
    ::df::plugin::WorldEntityDespawnEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_entity_despawn();
    _impl_.payload_.world_entity_despawn_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_entity_despawn)
}
inline ::df::plugin::WorldEntityDespawnEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_entity_despawn() {
  if (payload_case() != kWorldEntityDespawn) {
    clear_payload();
    set_has_world_entity_despawn();
    _impl_.payload_.world_entity_despawn_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldEntityDespawnEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldEntityDespawnEvent*>(_impl_.payload_.world_entity_despawn_);
}
inline ::df::plugin::WorldEntityDespawnEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_entity_despawn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldEntityDespawnEvent* _msg = _internal_mutable_world_entity_despawn();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_entity_despawn)
  return _msg;
}

// .df.plugin.WorldExplosionEvent world_explosion = 80 [json_name = "worldExplosion"];
inline bool EventEnvelope::has_world_explosion() const {
  return payload_case() == kWorldExplosion;
}
inline bool EventEnvelope::_internal_has_world_explosion() const {
  return payload_case() == kWorldExplosion;
}
inline void EventEnvelope::set_has_world_explosion() {
  _impl_._oneof_case_[0] = kWorldExplosion;
}
inline ::df::plugin::WorldExplosionEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_explosion() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_explosion)
  if (payload_case() == kWorldExplosion) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldExplosionEvent*>(_impl_.payload_.world_explosion_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_explosion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldExplosionEvent& EventEnvelope::_internal_world_explosion() const {
  return payload_case() == kWorldExplosion ? static_cast<const ::df::plugin::WorldExplosionEvent&>(*reinterpret_cast<::df::plugin::WorldExplosionEvent*>(_impl_.payload_.world_explosion_))
                     : reinterpret_cast<const ::df::plugin::WorldExplosionEvent&>(::df::plugin::_WorldExplosionEvent_default_instance_);
}
inline const ::df::plugin::WorldExplosionEvent& EventEnvelope::world_explosion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_explosion)
  return _internal_world_explosion();
}
inline ::df::plugin::WorldExplosionEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_explosion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_explosion)
  if (payload_case() == kWorldExplosion) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldExplosionEvent*>(_impl_.payload_.world_explosion_);
    _impl_.payload_.world_explosion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_explosion(
    ::df::plugin::WorldExplosionEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_explosion();
    _impl_.payload_.world_explosion_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_explosion)
}
inline ::df::plugin::WorldExplosionEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_explosion() {
  if (payload_case() != kWorldExplosion) {
    clear_payload();
    set_has_world_explosion();
    _impl_.payload_.world_explosion_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldExplosionEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldExplosionEvent*>(_impl_.payload_.world_explosion_);
}
inline ::df::plugin::WorldExplosionEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_explosion()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldExplosionEvent* _msg = _internal_mutable_world_explosion();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_explosion)
  return _msg;
}

// .df.plugin.WorldCloseEvent world_close = 81 [json_name = "worldClose"];
inline bool EventEnvelope::has_world_close() const {
  return payload_case() == kWorldClose;
}
inline bool EventEnvelope::_internal_has_world_close() const {
  return payload_case() == kWorldClose;
}
inline void EventEnvelope::set_has_world_close() {
  _impl_._oneof_case_[0] = kWorldClose;
}
inline ::df::plugin::WorldCloseEvent* PROTOBUF_NULLABLE EventEnvelope::release_world_close() {
  // @@protoc_insertion_point(field_release:df.plugin.EventEnvelope.world_close)
  if (payload_case() == kWorldClose) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldCloseEvent*>(_impl_.payload_.world_close_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.world_close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::WorldCloseEvent& EventEnvelope::_internal_world_close() const {
  return payload_case() == kWorldClose ? static_cast<const ::df::plugin::WorldCloseEvent&>(*reinterpret_cast<::df::plugin::WorldCloseEvent*>(_impl_.payload_.world_close_))
                     : reinterpret_cast<const ::df::plugin::WorldCloseEvent&>(::df::plugin::_WorldCloseEvent_default_instance_);
}
inline const ::df::plugin::WorldCloseEvent& EventEnvelope::world_close() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EventEnvelope.world_close)
  return _internal_world_close();
}
inline ::df::plugin::WorldCloseEvent* PROTOBUF_NULLABLE EventEnvelope::unsafe_arena_release_world_close() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.EventEnvelope.world_close)
  if (payload_case() == kWorldClose) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::WorldCloseEvent*>(_impl_.payload_.world_close_);
    _impl_.payload_.world_close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventEnvelope::unsafe_arena_set_allocated_world_close(
    ::df::plugin::WorldCloseEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_world_close();
    _impl_.payload_.world_close_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EventEnvelope.world_close)
}
inline ::df::plugin::WorldCloseEvent* PROTOBUF_NONNULL EventEnvelope::_internal_mutable_world_close() {
  if (payload_case() != kWorldClose) {
    clear_payload();
    set_has_world_close();
    _impl_.payload_.world_close_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::WorldCloseEvent>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::WorldCloseEvent*>(_impl_.payload_.world_close_);
}
inline ::df::plugin::WorldCloseEvent* PROTOBUF_NONNULL EventEnvelope::mutable_world_close()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::WorldCloseEvent* _msg = _internal_mutable_world_close();
  // @@protoc_insertion_point(field_mutable:df.plugin.EventEnvelope.world_close)
  return _msg;
}

inline bool EventEnvelope::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void EventEnvelope::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline EventEnvelope::PayloadCase EventEnvelope::payload_case() const {
  return EventEnvelope::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PluginToHost

// string plugin_id = 1 [json_name = "pluginId"];
inline void PluginToHost::clear_plugin_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plugin_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PluginToHost::plugin_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginToHost.plugin_id)
  return _internal_plugin_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PluginToHost::set_plugin_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.plugin_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.PluginToHost.plugin_id)
}
inline ::std::string* PROTOBUF_NONNULL PluginToHost::mutable_plugin_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_plugin_id();
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginToHost.plugin_id)
  return _s;
}
inline const ::std::string& PluginToHost::_internal_plugin_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.plugin_id_.Get();
}
inline void PluginToHost::_internal_set_plugin_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plugin_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PluginToHost::_internal_mutable_plugin_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.plugin_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PluginToHost::release_plugin_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.PluginToHost.plugin_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.plugin_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.plugin_id_.Set("", GetArena());
  }
  return released;
}
inline void PluginToHost::set_allocated_plugin_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.plugin_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.plugin_id_.IsDefault()) {
    _impl_.plugin_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.PluginToHost.plugin_id)
}

// .df.plugin.PluginHello hello = 10 [json_name = "hello"];
inline bool PluginToHost::has_hello() const {
  return payload_case() == kHello;
}
inline bool PluginToHost::_internal_has_hello() const {
  return payload_case() == kHello;
}
inline void PluginToHost::set_has_hello() {
  _impl_._oneof_case_[0] = kHello;
}
inline void PluginToHost::clear_hello() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kHello) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.hello_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.hello_);
    }
    clear_has_payload();
  }
}
inline ::df::plugin::PluginHello* PROTOBUF_NULLABLE PluginToHost::release_hello() {
  // @@protoc_insertion_point(field_release:df.plugin.PluginToHost.hello)
  if (payload_case() == kHello) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PluginHello*>(_impl_.payload_.hello_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.hello_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::PluginHello& PluginToHost::_internal_hello() const {
  return payload_case() == kHello ? static_cast<const ::df::plugin::PluginHello&>(*reinterpret_cast<::df::plugin::PluginHello*>(_impl_.payload_.hello_))
                     : reinterpret_cast<const ::df::plugin::PluginHello&>(::df::plugin::_PluginHello_default_instance_);
}
inline const ::df::plugin::PluginHello& PluginToHost::hello() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginToHost.hello)
  return _internal_hello();
}
inline ::df::plugin::PluginHello* PROTOBUF_NULLABLE PluginToHost::unsafe_arena_release_hello() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.PluginToHost.hello)
  if (payload_case() == kHello) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::PluginHello*>(_impl_.payload_.hello_);
    _impl_.payload_.hello_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PluginToHost::unsafe_arena_set_allocated_hello(
    ::df::plugin::PluginHello* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_hello();
    _impl_.payload_.hello_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.PluginToHost.hello)
}
inline ::df::plugin::PluginHello* PROTOBUF_NONNULL PluginToHost::_internal_mutable_hello() {
  if (payload_case() != kHello) {
    clear_payload();
    set_has_hello();
    _impl_.payload_.hello_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::PluginHello>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::PluginHello*>(_impl_.payload_.hello_);
}
inline ::df::plugin::PluginHello* PROTOBUF_NONNULL PluginToHost::mutable_hello()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::PluginHello* _msg = _internal_mutable_hello();
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginToHost.hello)
  return _msg;
}

// .df.plugin.EventSubscribe subscribe = 11 [json_name = "subscribe"];
inline bool PluginToHost::has_subscribe() const {
  return payload_case() == kSubscribe;
}
inline bool PluginToHost::_internal_has_subscribe() const {
  return payload_case() == kSubscribe;
}
inline void PluginToHost::set_has_subscribe() {
  _impl_._oneof_case_[0] = kSubscribe;
}
inline void PluginToHost::clear_subscribe() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kSubscribe) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.subscribe_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.subscribe_);
    }
    clear_has_payload();
  }
}
inline ::df::plugin::EventSubscribe* PROTOBUF_NULLABLE PluginToHost::release_subscribe() {
  // @@protoc_insertion_point(field_release:df.plugin.PluginToHost.subscribe)
  if (payload_case() == kSubscribe) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::EventSubscribe*>(_impl_.payload_.subscribe_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::EventSubscribe& PluginToHost::_internal_subscribe() const {
  return payload_case() == kSubscribe ? static_cast<const ::df::plugin::EventSubscribe&>(*reinterpret_cast<::df::plugin::EventSubscribe*>(_impl_.payload_.subscribe_))
                     : reinterpret_cast<const ::df::plugin::EventSubscribe&>(::df::plugin::_EventSubscribe_default_instance_);
}
inline const ::df::plugin::EventSubscribe& PluginToHost::subscribe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginToHost.subscribe)
  return _internal_subscribe();
}
inline ::df::plugin::EventSubscribe* PROTOBUF_NULLABLE PluginToHost::unsafe_arena_release_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.PluginToHost.subscribe)
  if (payload_case() == kSubscribe) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::EventSubscribe*>(_impl_.payload_.subscribe_);
    _impl_.payload_.subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PluginToHost::unsafe_arena_set_allocated_subscribe(
    ::df::plugin::EventSubscribe* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_subscribe();
    _impl_.payload_.subscribe_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.PluginToHost.subscribe)
}
inline ::df::plugin::EventSubscribe* PROTOBUF_NONNULL PluginToHost::_internal_mutable_subscribe() {
  if (payload_case() != kSubscribe) {
    clear_payload();
    set_has_subscribe();
    _impl_.payload_.subscribe_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::EventSubscribe>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::EventSubscribe*>(_impl_.payload_.subscribe_);
}
inline ::df::plugin::EventSubscribe* PROTOBUF_NONNULL PluginToHost::mutable_subscribe()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::EventSubscribe* _msg = _internal_mutable_subscribe();
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginToHost.subscribe)
  return _msg;
}

// .df.plugin.ServerInformationRequest server_info = 12 [json_name = "serverInfo"];
inline bool PluginToHost::has_server_info() const {
  return payload_case() == kServerInfo;
}
inline bool PluginToHost::_internal_has_server_info() const {
  return payload_case() == kServerInfo;
}
inline void PluginToHost::set_has_server_info() {
  _impl_._oneof_case_[0] = kServerInfo;
}
inline void PluginToHost::clear_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kServerInfo) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.server_info_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.server_info_);
    }
    clear_has_payload();
  }
}
inline ::df::plugin::ServerInformationRequest* PROTOBUF_NULLABLE PluginToHost::release_server_info() {
  // @@protoc_insertion_point(field_release:df.plugin.PluginToHost.server_info)
  if (payload_case() == kServerInfo) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::ServerInformationRequest*>(_impl_.payload_.server_info_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.server_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::ServerInformationRequest& PluginToHost::_internal_server_info() const {
  return payload_case() == kServerInfo ? static_cast<const ::df::plugin::ServerInformationRequest&>(*reinterpret_cast<::df::plugin::ServerInformationRequest*>(_impl_.payload_.server_info_))
                     : reinterpret_cast<const ::df::plugin::ServerInformationRequest&>(::df::plugin::_ServerInformationRequest_default_instance_);
}
inline const ::df::plugin::ServerInformationRequest& PluginToHost::server_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginToHost.server_info)
  return _internal_server_info();
}
inline ::df::plugin::ServerInformationRequest* PROTOBUF_NULLABLE PluginToHost::unsafe_arena_release_server_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.PluginToHost.server_info)
  if (payload_case() == kServerInfo) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::ServerInformationRequest*>(_impl_.payload_.server_info_);
    _impl_.payload_.server_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PluginToHost::unsafe_arena_set_allocated_server_info(
    ::df::plugin::ServerInformationRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_server_info();
    _impl_.payload_.server_info_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.PluginToHost.server_info)
}
inline ::df::plugin::ServerInformationRequest* PROTOBUF_NONNULL PluginToHost::_internal_mutable_server_info() {
  if (payload_case() != kServerInfo) {
    clear_payload();
    set_has_server_info();
    _impl_.payload_.server_info_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::ServerInformationRequest>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::ServerInformationRequest*>(_impl_.payload_.server_info_);
}
inline ::df::plugin::ServerInformationRequest* PROTOBUF_NONNULL PluginToHost::mutable_server_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::ServerInformationRequest* _msg = _internal_mutable_server_info();
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginToHost.server_info)
  return _msg;
}

// .df.plugin.ActionBatch actions = 20 [json_name = "actions"];
inline bool PluginToHost::has_actions() const {
  return payload_case() == kActions;
}
inline bool PluginToHost::_internal_has_actions() const {
  return payload_case() == kActions;
}
inline void PluginToHost::set_has_actions() {
  _impl_._oneof_case_[0] = kActions;
}
inline ::df::plugin::ActionBatch* PROTOBUF_NULLABLE PluginToHost::release_actions() {
  // @@protoc_insertion_point(field_release:df.plugin.PluginToHost.actions)
  if (payload_case() == kActions) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::ActionBatch*>(_impl_.payload_.actions_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.actions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::ActionBatch& PluginToHost::_internal_actions() const {
  return payload_case() == kActions ? static_cast<const ::df::plugin::ActionBatch&>(*reinterpret_cast<::df::plugin::ActionBatch*>(_impl_.payload_.actions_))
                     : reinterpret_cast<const ::df::plugin::ActionBatch&>(::df::plugin::_ActionBatch_default_instance_);
}
inline const ::df::plugin::ActionBatch& PluginToHost::actions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginToHost.actions)
  return _internal_actions();
}
inline ::df::plugin::ActionBatch* PROTOBUF_NULLABLE PluginToHost::unsafe_arena_release_actions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.PluginToHost.actions)
  if (payload_case() == kActions) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::ActionBatch*>(_impl_.payload_.actions_);
    _impl_.payload_.actions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PluginToHost::unsafe_arena_set_allocated_actions(
    ::df::plugin::ActionBatch* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_actions();
    _impl_.payload_.actions_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.PluginToHost.actions)
}
inline ::df::plugin::ActionBatch* PROTOBUF_NONNULL PluginToHost::_internal_mutable_actions() {
  if (payload_case() != kActions) {
    clear_payload();
    set_has_actions();
    _impl_.payload_.actions_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::ActionBatch>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::ActionBatch*>(_impl_.payload_.actions_);
}
inline ::df::plugin::ActionBatch* PROTOBUF_NONNULL PluginToHost::mutable_actions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::ActionBatch* _msg = _internal_mutable_actions();
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginToHost.actions)
  return _msg;
}

// .df.plugin.LogMessage log = 30 [json_name = "log"];
inline bool PluginToHost::has_log() const {
  return payload_case() == kLog;
}
inline bool PluginToHost::_internal_has_log() const {
  return payload_case() == kLog;
}
inline void PluginToHost::set_has_log() {
  _impl_._oneof_case_[0] = kLog;
}
inline void PluginToHost::clear_log() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kLog) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.log_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.log_);
    }
    clear_has_payload();
  }
}
inline ::df::plugin::LogMessage* PROTOBUF_NULLABLE PluginToHost::release_log() {
  // @@protoc_insertion_point(field_release:df.plugin.PluginToHost.log)
  if (payload_case() == kLog) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::LogMessage*>(_impl_.payload_.log_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::LogMessage& PluginToHost::_internal_log() const {
  return payload_case() == kLog ? static_cast<const ::df::plugin::LogMessage&>(*reinterpret_cast<::df::plugin::LogMessage*>(_impl_.payload_.log_))
                     : reinterpret_cast<const ::df::plugin::LogMessage&>(::df::plugin::_LogMessage_default_instance_);
}
inline const ::df::plugin::LogMessage& PluginToHost::log() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginToHost.log)
  return _internal_log();
}
inline ::df::plugin::LogMessage* PROTOBUF_NULLABLE PluginToHost::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.PluginToHost.log)
  if (payload_case() == kLog) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::LogMessage*>(_impl_.payload_.log_);
    _impl_.payload_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PluginToHost::unsafe_arena_set_allocated_log(
    ::df::plugin::LogMessage* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_log();
    _impl_.payload_.log_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.PluginToHost.log)
}
inline ::df::plugin::LogMessage* PROTOBUF_NONNULL PluginToHost::_internal_mutable_log() {
  if (payload_case() != kLog) {
    clear_payload();
    set_has_log();
    _impl_.payload_.log_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::LogMessage>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::LogMessage*>(_impl_.payload_.log_);
}
inline ::df::plugin::LogMessage* PROTOBUF_NONNULL PluginToHost::mutable_log()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::LogMessage* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginToHost.log)
  return _msg;
}

// .df.plugin.EventResult event_result = 40 [json_name = "eventResult"];
inline bool PluginToHost::has_event_result() const {
  return payload_case() == kEventResult;
}
inline bool PluginToHost::_internal_has_event_result() const {
  return payload_case() == kEventResult;
}
inline void PluginToHost::set_has_event_result() {
  _impl_._oneof_case_[0] = kEventResult;
}
inline ::df::plugin::EventResult* PROTOBUF_NULLABLE PluginToHost::release_event_result() {
  // @@protoc_insertion_point(field_release:df.plugin.PluginToHost.event_result)
  if (payload_case() == kEventResult) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::EventResult*>(_impl_.payload_.event_result_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.event_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::df::plugin::EventResult& PluginToHost::_internal_event_result() const {
  return payload_case() == kEventResult ? static_cast<const ::df::plugin::EventResult&>(*reinterpret_cast<::df::plugin::EventResult*>(_impl_.payload_.event_result_))
                     : reinterpret_cast<const ::df::plugin::EventResult&>(::df::plugin::_EventResult_default_instance_);
}
inline const ::df::plugin::EventResult& PluginToHost::event_result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginToHost.event_result)
  return _internal_event_result();
}
inline ::df::plugin::EventResult* PROTOBUF_NULLABLE PluginToHost::unsafe_arena_release_event_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:df.plugin.PluginToHost.event_result)
  if (payload_case() == kEventResult) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::df::plugin::EventResult*>(_impl_.payload_.event_result_);
    _impl_.payload_.event_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PluginToHost::unsafe_arena_set_allocated_event_result(
    ::df::plugin::EventResult* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_event_result();
    _impl_.payload_.event_result_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.PluginToHost.event_result)
}
inline ::df::plugin::EventResult* PROTOBUF_NONNULL PluginToHost::_internal_mutable_event_result() {
  if (payload_case() != kEventResult) {
    clear_payload();
    set_has_event_result();
    _impl_.payload_.event_result_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::df::plugin::EventResult>(GetArena()));
  }
  return reinterpret_cast<::df::plugin::EventResult*>(_impl_.payload_.event_result_);
}
inline ::df::plugin::EventResult* PROTOBUF_NONNULL PluginToHost::mutable_event_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::df::plugin::EventResult* _msg = _internal_mutable_event_result();
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginToHost.event_result)
  return _msg;
}

inline bool PluginToHost::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void PluginToHost::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline PluginToHost::PayloadCase PluginToHost::payload_case() const {
  return PluginToHost::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PluginHello

// string name = 1 [json_name = "name"];
inline void PluginHello::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& PluginHello::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginHello.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PluginHello::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.PluginHello.name)
}
inline ::std::string* PROTOBUF_NONNULL PluginHello::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginHello.name)
  return _s;
}
inline const ::std::string& PluginHello::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void PluginHello::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PluginHello::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PluginHello::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.PluginHello.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void PluginHello::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.PluginHello.name)
}

// string version = 2 [json_name = "version"];
inline void PluginHello::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& PluginHello::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginHello.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PluginHello::set_version(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.PluginHello.version)
}
inline ::std::string* PROTOBUF_NONNULL PluginHello::mutable_version()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginHello.version)
  return _s;
}
inline const ::std::string& PluginHello::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_.Get();
}
inline void PluginHello::_internal_set_version(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PluginHello::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.version_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PluginHello::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.PluginHello.version)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.version_.Set("", GetArena());
  }
  return released;
}
inline void PluginHello::set_allocated_version(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.PluginHello.version)
}

// string api_version = 3 [json_name = "apiVersion"];
inline void PluginHello::clear_api_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.api_version_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::std::string& PluginHello::api_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginHello.api_version)
  return _internal_api_version();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PluginHello::set_api_version(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  _impl_.api_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.PluginHello.api_version)
}
inline ::std::string* PROTOBUF_NONNULL PluginHello::mutable_api_version()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::std::string* _s = _internal_mutable_api_version();
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginHello.api_version)
  return _s;
}
inline const ::std::string& PluginHello::_internal_api_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.api_version_.Get();
}
inline void PluginHello::_internal_set_api_version(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.api_version_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PluginHello::_internal_mutable_api_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.api_version_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PluginHello::release_api_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.PluginHello.api_version)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000010U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  auto* released = _impl_.api_version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.api_version_.Set("", GetArena());
  }
  return released;
}
inline void PluginHello::set_allocated_api_version(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  _impl_.api_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.api_version_.IsDefault()) {
    _impl_.api_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.PluginHello.api_version)
}

// repeated .df.plugin.CommandSpec commands = 4 [json_name = "commands"];
inline int PluginHello::_internal_commands_size() const {
  return _internal_commands().size();
}
inline int PluginHello::commands_size() const {
  return _internal_commands_size();
}
inline ::df::plugin::CommandSpec* PROTOBUF_NONNULL PluginHello::mutable_commands(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginHello.commands)
  return _internal_mutable_commands()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::df::plugin::CommandSpec>* PROTOBUF_NONNULL PluginHello::mutable_commands()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:df.plugin.PluginHello.commands)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_commands();
}
inline const ::df::plugin::CommandSpec& PluginHello::commands(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginHello.commands)
  return _internal_commands().Get(index);
}
inline ::df::plugin::CommandSpec* PROTOBUF_NONNULL PluginHello::add_commands()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::df::plugin::CommandSpec* _add =
      _internal_mutable_commands()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:df.plugin.PluginHello.commands)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::df::plugin::CommandSpec>& PluginHello::commands() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:df.plugin.PluginHello.commands)
  return _internal_commands();
}
inline const ::google::protobuf::RepeatedPtrField<::df::plugin::CommandSpec>&
PluginHello::_internal_commands() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.commands_;
}
inline ::google::protobuf::RepeatedPtrField<::df::plugin::CommandSpec>* PROTOBUF_NONNULL
PluginHello::_internal_mutable_commands() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.commands_;
}

// repeated .df.plugin.CustomItemDefinition custom_items = 5 [json_name = "customItems"];
inline int PluginHello::_internal_custom_items_size() const {
  return _internal_custom_items().size();
}
inline int PluginHello::custom_items_size() const {
  return _internal_custom_items_size();
}
inline ::df::plugin::CustomItemDefinition* PROTOBUF_NONNULL PluginHello::mutable_custom_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:df.plugin.PluginHello.custom_items)
  return _internal_mutable_custom_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::df::plugin::CustomItemDefinition>* PROTOBUF_NONNULL PluginHello::mutable_custom_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:df.plugin.PluginHello.custom_items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_custom_items();
}
inline const ::df::plugin::CustomItemDefinition& PluginHello::custom_items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.PluginHello.custom_items)
  return _internal_custom_items().Get(index);
}
inline ::df::plugin::CustomItemDefinition* PROTOBUF_NONNULL PluginHello::add_custom_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::df::plugin::CustomItemDefinition* _add =
      _internal_mutable_custom_items()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:df.plugin.PluginHello.custom_items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::df::plugin::CustomItemDefinition>& PluginHello::custom_items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:df.plugin.PluginHello.custom_items)
  return _internal_custom_items();
}
inline const ::google::protobuf::RepeatedPtrField<::df::plugin::CustomItemDefinition>&
PluginHello::_internal_custom_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.custom_items_;
}
inline ::google::protobuf::RepeatedPtrField<::df::plugin::CustomItemDefinition>* PROTOBUF_NONNULL
PluginHello::_internal_mutable_custom_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.custom_items_;
}

// -------------------------------------------------------------------

// LogMessage

// string level = 1 [json_name = "level"];
inline void LogMessage::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& LogMessage::level() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.LogMessage.level)
  return _internal_level();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void LogMessage::set_level(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.level_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.LogMessage.level)
}
inline ::std::string* PROTOBUF_NONNULL LogMessage::mutable_level()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_level();
  // @@protoc_insertion_point(field_mutable:df.plugin.LogMessage.level)
  return _s;
}
inline const ::std::string& LogMessage::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_.Get();
}
inline void LogMessage::_internal_set_level(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL LogMessage::_internal_mutable_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.level_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE LogMessage::release_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.LogMessage.level)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.level_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.level_.Set("", GetArena());
  }
  return released;
}
inline void LogMessage::set_allocated_level(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.level_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.level_.IsDefault()) {
    _impl_.level_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.LogMessage.level)
}

// string message = 2 [json_name = "message"];
inline void LogMessage::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& LogMessage::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.LogMessage.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void LogMessage::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.LogMessage.message)
}
inline ::std::string* PROTOBUF_NONNULL LogMessage::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:df.plugin.LogMessage.message)
  return _s;
}
inline const ::std::string& LogMessage::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void LogMessage::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL LogMessage::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE LogMessage::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.LogMessage.message)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void LogMessage::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.LogMessage.message)
}

// -------------------------------------------------------------------

// EventSubscribe

// repeated .df.plugin.EventType events = 1 [json_name = "events"];
inline int EventSubscribe::_internal_events_size() const {
  return _internal_events().size();
}
inline int EventSubscribe::events_size() const {
  return _internal_events_size();
}
inline void EventSubscribe::clear_events() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.events_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::df::plugin::EventType EventSubscribe::events(int index) const {
  // @@protoc_insertion_point(field_get:df.plugin.EventSubscribe.events)
  return static_cast<::df::plugin::EventType>(_internal_events().Get(index));
}
inline void EventSubscribe::set_events(int index, ::df::plugin::EventType value) {
  _internal_mutable_events()->Set(index, value);
  // @@protoc_insertion_point(field_set:df.plugin.EventSubscribe.events)
}
inline void EventSubscribe::add_events(::df::plugin::EventType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_events()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:df.plugin.EventSubscribe.events)
}
inline const ::google::protobuf::RepeatedField<int>& EventSubscribe::events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:df.plugin.EventSubscribe.events)
  return _internal_events();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL EventSubscribe::mutable_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:df.plugin.EventSubscribe.events)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_events();
}
inline const ::google::protobuf::RepeatedField<int>& EventSubscribe::_internal_events()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.events_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
EventSubscribe::_internal_mutable_events() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.events_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace plugin
}  // namespace df


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::df::plugin::EventType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::df::plugin::EventType>() {
  return ::df::plugin::EventType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // plugin_2eproto_2epb_2eh
