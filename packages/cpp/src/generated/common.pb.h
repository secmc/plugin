// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: common.proto
// Protobuf C++ Version: 6.33.1

#ifndef common_2eproto_2epb_2eh
#define common_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_common_2eproto;
}  // extern "C"
namespace df {
namespace plugin {
enum Difficulty : int;
extern const uint32_t Difficulty_internal_data_[];
enum EffectType : int;
extern const uint32_t EffectType_internal_data_[];
enum GameMode : int;
extern const uint32_t GameMode_internal_data_[];
enum ItemCategory : int;
extern const uint32_t ItemCategory_internal_data_[];
enum Sound : int;
extern const uint32_t Sound_internal_data_[];
class Address;
struct AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Address_class_data_;
class BBox;
struct BBoxDefaultTypeInternal;
extern BBoxDefaultTypeInternal _BBox_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BBox_class_data_;
class BlockPos;
struct BlockPosDefaultTypeInternal;
extern BlockPosDefaultTypeInternal _BlockPos_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BlockPos_class_data_;
class BlockState;
struct BlockStateDefaultTypeInternal;
extern BlockStateDefaultTypeInternal _BlockState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BlockState_class_data_;
class BlockState_PropertiesEntry_DoNotUse;
struct BlockState_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern BlockState_PropertiesEntry_DoNotUseDefaultTypeInternal _BlockState_PropertiesEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BlockState_PropertiesEntry_DoNotUse_class_data_;
class CustomItemDefinition;
struct CustomItemDefinitionDefaultTypeInternal;
extern CustomItemDefinitionDefaultTypeInternal _CustomItemDefinition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CustomItemDefinition_class_data_;
class DamageSource;
struct DamageSourceDefaultTypeInternal;
extern DamageSourceDefaultTypeInternal _DamageSource_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DamageSource_class_data_;
class EntityRef;
struct EntityRefDefaultTypeInternal;
extern EntityRefDefaultTypeInternal _EntityRef_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EntityRef_class_data_;
class HealingSource;
struct HealingSourceDefaultTypeInternal;
extern HealingSourceDefaultTypeInternal _HealingSource_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HealingSource_class_data_;
class ItemStack;
struct ItemStackDefaultTypeInternal;
extern ItemStackDefaultTypeInternal _ItemStack_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ItemStack_class_data_;
class LiquidState;
struct LiquidStateDefaultTypeInternal;
extern LiquidStateDefaultTypeInternal _LiquidState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LiquidState_class_data_;
class Rotation;
struct RotationDefaultTypeInternal;
extern RotationDefaultTypeInternal _Rotation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Rotation_class_data_;
class Vec3;
struct Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Vec3_class_data_;
class WorldRef;
struct WorldRefDefaultTypeInternal;
extern WorldRefDefaultTypeInternal _WorldRef_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WorldRef_class_data_;
}  // namespace plugin
}  // namespace df
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::df::plugin::Difficulty_internal_data_>
    internal::EnumTraitsImpl::value<::df::plugin::Difficulty>;
template <>
internal::EnumTraitsT<::df::plugin::EffectType_internal_data_>
    internal::EnumTraitsImpl::value<::df::plugin::EffectType>;
template <>
internal::EnumTraitsT<::df::plugin::GameMode_internal_data_>
    internal::EnumTraitsImpl::value<::df::plugin::GameMode>;
template <>
internal::EnumTraitsT<::df::plugin::ItemCategory_internal_data_>
    internal::EnumTraitsImpl::value<::df::plugin::ItemCategory>;
template <>
internal::EnumTraitsT<::df::plugin::Sound_internal_data_>
    internal::EnumTraitsImpl::value<::df::plugin::Sound>;
}  // namespace protobuf
}  // namespace google

namespace df {
namespace plugin {
enum GameMode : int {
  SURVIVAL = 0,
  CREATIVE = 1,
  ADVENTURE = 2,
  SPECTATOR = 3,
  GameMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GameMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GameMode_internal_data_[];
inline constexpr GameMode GameMode_MIN =
    static_cast<GameMode>(0);
inline constexpr GameMode GameMode_MAX =
    static_cast<GameMode>(3);
inline bool GameMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int GameMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GameMode_descriptor();
template <typename T>
const ::std::string& GameMode_Name(T value) {
  static_assert(::std::is_same<T, GameMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GameMode_Name().");
  return GameMode_Name(static_cast<GameMode>(value));
}
template <>
inline const ::std::string& GameMode_Name(GameMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GameMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool GameMode_Parse(
    ::absl::string_view name, GameMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameMode>(GameMode_descriptor(), name,
                                           value);
}
enum Difficulty : int {
  PEACEFUL = 0,
  EASY = 1,
  NORMAL = 2,
  HARD = 3,
  Difficulty_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Difficulty_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Difficulty_internal_data_[];
inline constexpr Difficulty Difficulty_MIN =
    static_cast<Difficulty>(0);
inline constexpr Difficulty Difficulty_MAX =
    static_cast<Difficulty>(3);
inline bool Difficulty_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int Difficulty_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Difficulty_descriptor();
template <typename T>
const ::std::string& Difficulty_Name(T value) {
  static_assert(::std::is_same<T, Difficulty>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Difficulty_Name().");
  return Difficulty_Name(static_cast<Difficulty>(value));
}
template <>
inline const ::std::string& Difficulty_Name(Difficulty value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Difficulty_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool Difficulty_Parse(
    ::absl::string_view name, Difficulty* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Difficulty>(Difficulty_descriptor(), name,
                                           value);
}
enum EffectType : int {
  EFFECT_UNKNOWN = 0,
  SPEED = 1,
  SLOWNESS = 2,
  HASTE = 3,
  MINING_FATIGUE = 4,
  STRENGTH = 5,
  INSTANT_HEALTH = 6,
  INSTANT_DAMAGE = 7,
  JUMP_BOOST = 8,
  NAUSEA = 9,
  REGENERATION = 10,
  RESISTANCE = 11,
  FIRE_RESISTANCE = 12,
  WATER_BREATHING = 13,
  INVISIBILITY = 14,
  BLINDNESS = 15,
  NIGHT_VISION = 16,
  HUNGER = 17,
  WEAKNESS = 18,
  POISON = 19,
  WITHER = 20,
  HEALTH_BOOST = 21,
  ABSORPTION = 22,
  SATURATION = 23,
  LEVITATION = 24,
  FATAL_POISON = 25,
  CONDUIT_POWER = 26,
  SLOW_FALLING = 27,
  DARKNESS = 30,
  EffectType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EffectType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EffectType_internal_data_[];
inline constexpr EffectType EffectType_MIN =
    static_cast<EffectType>(0);
inline constexpr EffectType EffectType_MAX =
    static_cast<EffectType>(30);
inline bool EffectType_IsValid(int value) {
  return 0 <= value && value <= 30 && ((1342177279u >> value) & 1) != 0;
}
inline constexpr int EffectType_ARRAYSIZE = 30 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EffectType_descriptor();
template <typename T>
const ::std::string& EffectType_Name(T value) {
  static_assert(::std::is_same<T, EffectType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EffectType_Name().");
  return EffectType_Name(static_cast<EffectType>(value));
}
template <>
inline const ::std::string& EffectType_Name(EffectType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EffectType_descriptor, 0, 30>(
      static_cast<int>(value));
}
inline bool EffectType_Parse(
    ::absl::string_view name, EffectType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EffectType>(EffectType_descriptor(), name,
                                           value);
}
enum Sound : int {
  SOUND_UNKNOWN = 0,
  ATTACK = 1,
  DROWNING = 2,
  BURNING = 3,
  FALL = 4,
  BURP = 5,
  POP = 6,
  EXPLOSION = 7,
  THUNDER = 8,
  LEVEL_UP = 9,
  EXPERIENCE = 10,
  FIREWORK_LAUNCH = 11,
  FIREWORK_HUGE_BLAST = 12,
  FIREWORK_BLAST = 13,
  FIREWORK_TWINKLE = 14,
  TELEPORT = 15,
  ARROW_HIT = 16,
  ITEM_BREAK = 17,
  ITEM_THROW = 18,
  TOTEM = 19,
  FIRE_EXTINGUISH = 20,
  Sound_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Sound_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Sound_internal_data_[];
inline constexpr Sound Sound_MIN =
    static_cast<Sound>(0);
inline constexpr Sound Sound_MAX =
    static_cast<Sound>(20);
inline bool Sound_IsValid(int value) {
  return 0 <= value && value <= 20;
}
inline constexpr int Sound_ARRAYSIZE = 20 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Sound_descriptor();
template <typename T>
const ::std::string& Sound_Name(T value) {
  static_assert(::std::is_same<T, Sound>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Sound_Name().");
  return Sound_Name(static_cast<Sound>(value));
}
template <>
inline const ::std::string& Sound_Name(Sound value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Sound_descriptor, 0, 20>(
      static_cast<int>(value));
}
inline bool Sound_Parse(
    ::absl::string_view name, Sound* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Sound>(Sound_descriptor(), name,
                                           value);
}
enum ItemCategory : int {
  ITEM_CATEGORY_CONSTRUCTION = 0,
  ITEM_CATEGORY_NATURE = 1,
  ITEM_CATEGORY_EQUIPMENT = 2,
  ITEM_CATEGORY_ITEMS = 3,
  ItemCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ItemCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ItemCategory_internal_data_[];
inline constexpr ItemCategory ItemCategory_MIN =
    static_cast<ItemCategory>(0);
inline constexpr ItemCategory ItemCategory_MAX =
    static_cast<ItemCategory>(3);
inline bool ItemCategory_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ItemCategory_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ItemCategory_descriptor();
template <typename T>
const ::std::string& ItemCategory_Name(T value) {
  static_assert(::std::is_same<T, ItemCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ItemCategory_Name().");
  return ItemCategory_Name(static_cast<ItemCategory>(value));
}
template <>
inline const ::std::string& ItemCategory_Name(ItemCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemCategory_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ItemCategory_Parse(
    ::absl::string_view name, ItemCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemCategory>(ItemCategory_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class WorldRef final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.WorldRef) */ {
 public:
  inline WorldRef() : WorldRef(nullptr) {}
  ~WorldRef() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WorldRef* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WorldRef));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldRef(::google::protobuf::internal::ConstantInitialized);

  inline WorldRef(const WorldRef& from) : WorldRef(nullptr, from) {}
  inline WorldRef(WorldRef&& from) noexcept
      : WorldRef(nullptr, ::std::move(from)) {}
  inline WorldRef& operator=(const WorldRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldRef& operator=(WorldRef&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldRef& default_instance() {
    return *reinterpret_cast<const WorldRef*>(
        &_WorldRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(WorldRef& a, WorldRef& b) { a.Swap(&b); }
  inline void Swap(WorldRef* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldRef* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldRef* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WorldRef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorldRef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorldRef& from) { WorldRef::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WorldRef* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.WorldRef"; }

  explicit WorldRef(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WorldRef(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WorldRef& from);
  WorldRef(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WorldRef&& from) noexcept
      : WorldRef(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kDimensionFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string dimension = 2 [json_name = "dimension"];
  void clear_dimension() ;
  const ::std::string& dimension() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dimension(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dimension();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dimension();
  void set_allocated_dimension(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dimension() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dimension(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dimension();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.WorldRef)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WorldRef& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr dimension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WorldRef_class_data_;
// -------------------------------------------------------------------

class Vec3 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.Vec3) */ {
 public:
  inline Vec3() : Vec3(nullptr) {}
  ~Vec3() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vec3* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vec3));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vec3(::google::protobuf::internal::ConstantInitialized);

  inline Vec3(const Vec3& from) : Vec3(nullptr, from) {}
  inline Vec3(Vec3&& from) noexcept
      : Vec3(nullptr, ::std::move(from)) {}
  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3& default_instance() {
    return *reinterpret_cast<const Vec3*>(
        &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Vec3& a, Vec3& b) { a.Swap(&b); }
  inline void Swap(Vec3* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vec3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vec3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vec3& from) { Vec3::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vec3* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.Vec3"; }

  explicit Vec3(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Vec3(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Vec3& from);
  Vec3(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Vec3&& from) noexcept
      : Vec3(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1 [json_name = "x"];
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2 [json_name = "y"];
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3 [json_name = "z"];
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.Vec3)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Vec3& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Vec3_class_data_;
// -------------------------------------------------------------------

class Rotation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.Rotation) */ {
 public:
  inline Rotation() : Rotation(nullptr) {}
  ~Rotation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Rotation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Rotation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Rotation(::google::protobuf::internal::ConstantInitialized);

  inline Rotation(const Rotation& from) : Rotation(nullptr, from) {}
  inline Rotation(Rotation&& from) noexcept
      : Rotation(nullptr, ::std::move(from)) {}
  inline Rotation& operator=(const Rotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rotation& operator=(Rotation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rotation& default_instance() {
    return *reinterpret_cast<const Rotation*>(
        &_Rotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Rotation& a, Rotation& b) { a.Swap(&b); }
  inline void Swap(Rotation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rotation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rotation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Rotation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rotation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Rotation& from) { Rotation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Rotation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.Rotation"; }

  explicit Rotation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Rotation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Rotation& from);
  Rotation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Rotation&& from) noexcept
      : Rotation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kYawFieldNumber = 1,
    kPitchFieldNumber = 2,
  };
  // float yaw = 1 [json_name = "yaw"];
  void clear_yaw() ;
  float yaw() const;
  void set_yaw(float value);

  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);

  public:
  // float pitch = 2 [json_name = "pitch"];
  void clear_pitch() ;
  float pitch() const;
  void set_pitch(float value);

  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.Rotation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Rotation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    float yaw_;
    float pitch_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Rotation_class_data_;
// -------------------------------------------------------------------

class ItemStack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.ItemStack) */ {
 public:
  inline ItemStack() : ItemStack(nullptr) {}
  ~ItemStack() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ItemStack* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ItemStack));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ItemStack(::google::protobuf::internal::ConstantInitialized);

  inline ItemStack(const ItemStack& from) : ItemStack(nullptr, from) {}
  inline ItemStack(ItemStack&& from) noexcept
      : ItemStack(nullptr, ::std::move(from)) {}
  inline ItemStack& operator=(const ItemStack& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemStack& operator=(ItemStack&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemStack& default_instance() {
    return *reinterpret_cast<const ItemStack*>(
        &_ItemStack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ItemStack& a, ItemStack& b) { a.Swap(&b); }
  inline void Swap(ItemStack* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemStack* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemStack* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ItemStack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ItemStack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ItemStack& from) { ItemStack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ItemStack* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.ItemStack"; }

  explicit ItemStack(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ItemStack(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ItemStack& from);
  ItemStack(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ItemStack&& from) noexcept
      : ItemStack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kMetaFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // int32 meta = 2 [json_name = "meta"];
  void clear_meta() ;
  ::int32_t meta() const;
  void set_meta(::int32_t value);

  private:
  ::int32_t _internal_meta() const;
  void _internal_set_meta(::int32_t value);

  public:
  // int32 count = 3 [json_name = "count"];
  void clear_count() ;
  ::int32_t count() const;
  void set_count(::int32_t value);

  private:
  ::int32_t _internal_count() const;
  void _internal_set_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.ItemStack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 32,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ItemStack& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t meta_;
    ::int32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ItemStack_class_data_;
// -------------------------------------------------------------------

class HealingSource final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.HealingSource) */ {
 public:
  inline HealingSource() : HealingSource(nullptr) {}
  ~HealingSource() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HealingSource* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HealingSource));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HealingSource(::google::protobuf::internal::ConstantInitialized);

  inline HealingSource(const HealingSource& from) : HealingSource(nullptr, from) {}
  inline HealingSource(HealingSource&& from) noexcept
      : HealingSource(nullptr, ::std::move(from)) {}
  inline HealingSource& operator=(const HealingSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealingSource& operator=(HealingSource&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealingSource& default_instance() {
    return *reinterpret_cast<const HealingSource*>(
        &_HealingSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(HealingSource& a, HealingSource& b) { a.Swap(&b); }
  inline void Swap(HealingSource* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealingSource* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealingSource* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HealingSource>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HealingSource& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HealingSource& from) { HealingSource::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HealingSource* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.HealingSource"; }

  explicit HealingSource(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HealingSource(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HealingSource& from);
  HealingSource(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HealingSource&& from) noexcept
      : HealingSource(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // string type = 1 [json_name = "type"];
  void clear_type() ;
  const ::std::string& type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_type();
  void set_allocated_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_type();

  public:
  // optional string description = 2 [json_name = "description"];
  bool has_description() const;
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.HealingSource)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HealingSource& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HealingSource_class_data_;
// -------------------------------------------------------------------

class DamageSource final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.DamageSource) */ {
 public:
  inline DamageSource() : DamageSource(nullptr) {}
  ~DamageSource() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DamageSource* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DamageSource));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DamageSource(::google::protobuf::internal::ConstantInitialized);

  inline DamageSource(const DamageSource& from) : DamageSource(nullptr, from) {}
  inline DamageSource(DamageSource&& from) noexcept
      : DamageSource(nullptr, ::std::move(from)) {}
  inline DamageSource& operator=(const DamageSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline DamageSource& operator=(DamageSource&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DamageSource& default_instance() {
    return *reinterpret_cast<const DamageSource*>(
        &_DamageSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(DamageSource& a, DamageSource& b) { a.Swap(&b); }
  inline void Swap(DamageSource* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DamageSource* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DamageSource* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DamageSource>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DamageSource& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DamageSource& from) { DamageSource::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DamageSource* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.DamageSource"; }

  explicit DamageSource(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DamageSource(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DamageSource& from);
  DamageSource(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DamageSource&& from) noexcept
      : DamageSource(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // string type = 1 [json_name = "type"];
  void clear_type() ;
  const ::std::string& type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_type();
  void set_allocated_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_type();

  public:
  // optional string description = 2 [json_name = "description"];
  bool has_description() const;
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.DamageSource)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DamageSource& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DamageSource_class_data_;
// -------------------------------------------------------------------

class CustomItemDefinition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.CustomItemDefinition) */ {
 public:
  inline CustomItemDefinition() : CustomItemDefinition(nullptr) {}
  ~CustomItemDefinition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CustomItemDefinition* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CustomItemDefinition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CustomItemDefinition(::google::protobuf::internal::ConstantInitialized);

  inline CustomItemDefinition(const CustomItemDefinition& from) : CustomItemDefinition(nullptr, from) {}
  inline CustomItemDefinition(CustomItemDefinition&& from) noexcept
      : CustomItemDefinition(nullptr, ::std::move(from)) {}
  inline CustomItemDefinition& operator=(const CustomItemDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomItemDefinition& operator=(CustomItemDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomItemDefinition& default_instance() {
    return *reinterpret_cast<const CustomItemDefinition*>(
        &_CustomItemDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(CustomItemDefinition& a, CustomItemDefinition& b) { a.Swap(&b); }
  inline void Swap(CustomItemDefinition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomItemDefinition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomItemDefinition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CustomItemDefinition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomItemDefinition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CustomItemDefinition& from) { CustomItemDefinition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CustomItemDefinition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.CustomItemDefinition"; }

  explicit CustomItemDefinition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CustomItemDefinition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CustomItemDefinition& from);
  CustomItemDefinition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CustomItemDefinition&& from) noexcept
      : CustomItemDefinition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kTextureDataFieldNumber = 3,
    kGroupFieldNumber = 5,
    kCategoryFieldNumber = 4,
    kMetaFieldNumber = 6,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string display_name = 2 [json_name = "displayName"];
  void clear_display_name() ;
  const ::std::string& display_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_display_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_display_name();
  void set_allocated_display_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_display_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_display_name();

  public:
  // bytes texture_data = 3 [json_name = "textureData"];
  void clear_texture_data() ;
  const ::std::string& texture_data() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_texture_data(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_texture_data();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_texture_data();
  void set_allocated_texture_data(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_texture_data() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_texture_data(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_texture_data();

  public:
  // optional string group = 5 [json_name = "group"];
  bool has_group() const;
  void clear_group() ;
  const ::std::string& group() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_group();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_group();
  void set_allocated_group(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_group() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_group(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_group();

  public:
  // .df.plugin.ItemCategory category = 4 [json_name = "category"];
  void clear_category() ;
  ::df::plugin::ItemCategory category() const;
  void set_category(::df::plugin::ItemCategory value);

  private:
  ::df::plugin::ItemCategory _internal_category() const;
  void _internal_set_category(::df::plugin::ItemCategory value);

  public:
  // int32 meta = 6 [json_name = "meta"];
  void clear_meta() ;
  ::int32_t meta() const;
  void set_meta(::int32_t value);

  private:
  ::int32_t _internal_meta() const;
  void _internal_set_meta(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.CustomItemDefinition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CustomItemDefinition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::google::protobuf::internal::ArenaStringPtr texture_data_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    int category_;
    ::int32_t meta_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CustomItemDefinition_class_data_;
// -------------------------------------------------------------------

class BlockState_PropertiesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::std::string,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  BlockState_PropertiesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockState_PropertiesEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit BlockState_PropertiesEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_BlockState_PropertiesEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_common_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 53,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull BlockState_PropertiesEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class BlockPos final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.BlockPos) */ {
 public:
  inline BlockPos() : BlockPos(nullptr) {}
  ~BlockPos() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockPos* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockPos));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockPos(::google::protobuf::internal::ConstantInitialized);

  inline BlockPos(const BlockPos& from) : BlockPos(nullptr, from) {}
  inline BlockPos(BlockPos&& from) noexcept
      : BlockPos(nullptr, ::std::move(from)) {}
  inline BlockPos& operator=(const BlockPos& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockPos& operator=(BlockPos&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockPos& default_instance() {
    return *reinterpret_cast<const BlockPos*>(
        &_BlockPos_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(BlockPos& a, BlockPos& b) { a.Swap(&b); }
  inline void Swap(BlockPos* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockPos* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockPos* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockPos>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockPos& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockPos& from) { BlockPos::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockPos* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.BlockPos"; }

  explicit BlockPos(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BlockPos(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BlockPos& from);
  BlockPos(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BlockPos&& from) noexcept
      : BlockPos(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // int32 x = 1 [json_name = "x"];
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2 [json_name = "y"];
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // int32 z = 3 [json_name = "z"];
  void clear_z() ;
  ::int32_t z() const;
  void set_z(::int32_t value);

  private:
  ::int32_t _internal_z() const;
  void _internal_set_z(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.BlockPos)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BlockPos& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t x_;
    ::int32_t y_;
    ::int32_t z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BlockPos_class_data_;
// -------------------------------------------------------------------

class Address final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.Address) */ {
 public:
  inline Address() : Address(nullptr) {}
  ~Address() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Address* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Address));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Address(::google::protobuf::internal::ConstantInitialized);

  inline Address(const Address& from) : Address(nullptr, from) {}
  inline Address(Address&& from) noexcept
      : Address(nullptr, ::std::move(from)) {}
  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  inline Address& operator=(Address&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Address& default_instance() {
    return *reinterpret_cast<const Address*>(
        &_Address_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Address& a, Address& b) { a.Swap(&b); }
  inline void Swap(Address* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Address* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Address* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Address>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Address& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Address& from) { Address::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Address* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.Address"; }

  explicit Address(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Address(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Address& from);
  Address(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Address&& from) noexcept
      : Address(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHostFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string host = 1 [json_name = "host"];
  void clear_host() ;
  const ::std::string& host() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_host();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_host();
  void set_allocated_host(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_host() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_host(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_host();

  public:
  // int32 port = 2 [json_name = "port"];
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.Address)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 30,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Address& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr host_;
    ::int32_t port_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Address_class_data_;
// -------------------------------------------------------------------

class EntityRef final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.EntityRef) */ {
 public:
  inline EntityRef() : EntityRef(nullptr) {}
  ~EntityRef() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EntityRef* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EntityRef));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntityRef(::google::protobuf::internal::ConstantInitialized);

  inline EntityRef(const EntityRef& from) : EntityRef(nullptr, from) {}
  inline EntityRef(EntityRef&& from) noexcept
      : EntityRef(nullptr, ::std::move(from)) {}
  inline EntityRef& operator=(const EntityRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityRef& operator=(EntityRef&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityRef& default_instance() {
    return *reinterpret_cast<const EntityRef*>(
        &_EntityRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(EntityRef& a, EntityRef& b) { a.Swap(&b); }
  inline void Swap(EntityRef* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityRef* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityRef* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EntityRef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntityRef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntityRef& from) { EntityRef::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EntityRef* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.EntityRef"; }

  explicit EntityRef(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EntityRef(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EntityRef& from);
  EntityRef(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EntityRef&& from) noexcept
      : EntityRef(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUuidFieldNumber = 1,
    kTypeFieldNumber = 2,
    kNameFieldNumber = 3,
    kPositionFieldNumber = 4,
    kRotationFieldNumber = 5,
  };
  // string uuid = 1 [json_name = "uuid"];
  void clear_uuid() ;
  const ::std::string& uuid() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_uuid();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_uuid();
  void set_allocated_uuid(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_uuid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_uuid();

  public:
  // string type = 2 [json_name = "type"];
  void clear_type() ;
  const ::std::string& type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_type();
  void set_allocated_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_type();

  public:
  // optional string name = 3 [json_name = "name"];
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional .df.plugin.Vec3 position = 4 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::df::plugin::Vec3& position() const;
  [[nodiscard]] ::df::plugin::Vec3* PROTOBUF_NULLABLE release_position();
  ::df::plugin::Vec3* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::df::plugin::Vec3* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::df::plugin::Vec3* PROTOBUF_NULLABLE value);
  ::df::plugin::Vec3* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::df::plugin::Vec3& _internal_position() const;
  ::df::plugin::Vec3* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // optional .df.plugin.Rotation rotation = 5 [json_name = "rotation"];
  bool has_rotation() const;
  void clear_rotation() ;
  const ::df::plugin::Rotation& rotation() const;
  [[nodiscard]] ::df::plugin::Rotation* PROTOBUF_NULLABLE release_rotation();
  ::df::plugin::Rotation* PROTOBUF_NONNULL mutable_rotation();
  void set_allocated_rotation(::df::plugin::Rotation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rotation(::df::plugin::Rotation* PROTOBUF_NULLABLE value);
  ::df::plugin::Rotation* PROTOBUF_NULLABLE unsafe_arena_release_rotation();

  private:
  const ::df::plugin::Rotation& _internal_rotation() const;
  ::df::plugin::Rotation* PROTOBUF_NONNULL _internal_mutable_rotation();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.EntityRef)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   2, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EntityRef& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uuid_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::df::plugin::Vec3* PROTOBUF_NULLABLE position_;
    ::df::plugin::Rotation* PROTOBUF_NULLABLE rotation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EntityRef_class_data_;
// -------------------------------------------------------------------

class BlockState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.BlockState) */ {
 public:
  inline BlockState() : BlockState(nullptr) {}
  ~BlockState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockState* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockState(::google::protobuf::internal::ConstantInitialized);

  inline BlockState(const BlockState& from) : BlockState(nullptr, from) {}
  inline BlockState(BlockState&& from) noexcept
      : BlockState(nullptr, ::std::move(from)) {}
  inline BlockState& operator=(const BlockState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockState& operator=(BlockState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockState& default_instance() {
    return *reinterpret_cast<const BlockState*>(
        &_BlockState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(BlockState& a, BlockState& b) { a.Swap(&b); }
  inline void Swap(BlockState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockState& from) { BlockState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.BlockState"; }

  explicit BlockState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BlockState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BlockState& from);
  BlockState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BlockState&& from) noexcept
      : BlockState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kPropertiesFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // map<string, string> properties = 2 [json_name = "properties"];
  int properties_size() const;
  private:
  int _internal_properties_size() const;

  public:
  void clear_properties() ;
  const ::google::protobuf::Map<::std::string, ::std::string>& properties() const;
  ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL mutable_properties();

  private:
  const ::google::protobuf::Map<::std::string, ::std::string>& _internal_properties() const;
  ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL _internal_mutable_properties();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.BlockState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   1, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BlockState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::MapField<BlockState_PropertiesEntry_DoNotUse, ::std::string, ::std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        properties_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BlockState_class_data_;
// -------------------------------------------------------------------

class BBox final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.BBox) */ {
 public:
  inline BBox() : BBox(nullptr) {}
  ~BBox() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BBox* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BBox));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BBox(::google::protobuf::internal::ConstantInitialized);

  inline BBox(const BBox& from) : BBox(nullptr, from) {}
  inline BBox(BBox&& from) noexcept
      : BBox(nullptr, ::std::move(from)) {}
  inline BBox& operator=(const BBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline BBox& operator=(BBox&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BBox& default_instance() {
    return *reinterpret_cast<const BBox*>(
        &_BBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(BBox& a, BBox& b) { a.Swap(&b); }
  inline void Swap(BBox* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BBox* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BBox* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BBox>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BBox& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BBox& from) { BBox::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BBox* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.BBox"; }

  explicit BBox(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BBox(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BBox& from);
  BBox(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BBox&& from) noexcept
      : BBox(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // .df.plugin.Vec3 min = 1 [json_name = "min"];
  bool has_min() const;
  void clear_min() ;
  const ::df::plugin::Vec3& min() const;
  [[nodiscard]] ::df::plugin::Vec3* PROTOBUF_NULLABLE release_min();
  ::df::plugin::Vec3* PROTOBUF_NONNULL mutable_min();
  void set_allocated_min(::df::plugin::Vec3* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_min(::df::plugin::Vec3* PROTOBUF_NULLABLE value);
  ::df::plugin::Vec3* PROTOBUF_NULLABLE unsafe_arena_release_min();

  private:
  const ::df::plugin::Vec3& _internal_min() const;
  ::df::plugin::Vec3* PROTOBUF_NONNULL _internal_mutable_min();

  public:
  // .df.plugin.Vec3 max = 2 [json_name = "max"];
  bool has_max() const;
  void clear_max() ;
  const ::df::plugin::Vec3& max() const;
  [[nodiscard]] ::df::plugin::Vec3* PROTOBUF_NULLABLE release_max();
  ::df::plugin::Vec3* PROTOBUF_NONNULL mutable_max();
  void set_allocated_max(::df::plugin::Vec3* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_max(::df::plugin::Vec3* PROTOBUF_NULLABLE value);
  ::df::plugin::Vec3* PROTOBUF_NULLABLE unsafe_arena_release_max();

  private:
  const ::df::plugin::Vec3& _internal_max() const;
  ::df::plugin::Vec3* PROTOBUF_NONNULL _internal_mutable_max();

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.BBox)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BBox& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::df::plugin::Vec3* PROTOBUF_NULLABLE min_;
    ::df::plugin::Vec3* PROTOBUF_NULLABLE max_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BBox_class_data_;
// -------------------------------------------------------------------

class LiquidState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:df.plugin.LiquidState) */ {
 public:
  inline LiquidState() : LiquidState(nullptr) {}
  ~LiquidState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LiquidState* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LiquidState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LiquidState(::google::protobuf::internal::ConstantInitialized);

  inline LiquidState(const LiquidState& from) : LiquidState(nullptr, from) {}
  inline LiquidState(LiquidState&& from) noexcept
      : LiquidState(nullptr, ::std::move(from)) {}
  inline LiquidState& operator=(const LiquidState& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiquidState& operator=(LiquidState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiquidState& default_instance() {
    return *reinterpret_cast<const LiquidState*>(
        &_LiquidState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(LiquidState& a, LiquidState& b) { a.Swap(&b); }
  inline void Swap(LiquidState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiquidState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiquidState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LiquidState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LiquidState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LiquidState& from) { LiquidState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LiquidState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "df.plugin.LiquidState"; }

  explicit LiquidState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LiquidState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LiquidState& from);
  LiquidState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LiquidState&& from) noexcept
      : LiquidState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLiquidTypeFieldNumber = 4,
    kBlockFieldNumber = 1,
    kDepthFieldNumber = 2,
    kFallingFieldNumber = 3,
  };
  // string liquid_type = 4 [json_name = "liquidType"];
  void clear_liquid_type() ;
  const ::std::string& liquid_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_liquid_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_liquid_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_liquid_type();
  void set_allocated_liquid_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_liquid_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_liquid_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_liquid_type();

  public:
  // .df.plugin.BlockState block = 1 [json_name = "block"];
  bool has_block() const;
  void clear_block() ;
  const ::df::plugin::BlockState& block() const;
  [[nodiscard]] ::df::plugin::BlockState* PROTOBUF_NULLABLE release_block();
  ::df::plugin::BlockState* PROTOBUF_NONNULL mutable_block();
  void set_allocated_block(::df::plugin::BlockState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_block(::df::plugin::BlockState* PROTOBUF_NULLABLE value);
  ::df::plugin::BlockState* PROTOBUF_NULLABLE unsafe_arena_release_block();

  private:
  const ::df::plugin::BlockState& _internal_block() const;
  ::df::plugin::BlockState* PROTOBUF_NONNULL _internal_mutable_block();

  public:
  // int32 depth = 2 [json_name = "depth"];
  void clear_depth() ;
  ::int32_t depth() const;
  void set_depth(::int32_t value);

  private:
  ::int32_t _internal_depth() const;
  void _internal_set_depth(::int32_t value);

  public:
  // bool falling = 3 [json_name = "falling"];
  void clear_falling() ;
  bool falling() const;
  void set_falling(bool value);

  private:
  bool _internal_falling() const;
  void _internal_set_falling(bool value);

  public:
  // @@protoc_insertion_point(class_scope:df.plugin.LiquidState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LiquidState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr liquid_type_;
    ::df::plugin::BlockState* PROTOBUF_NULLABLE block_;
    ::int32_t depth_;
    bool falling_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LiquidState_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vec3

// double x = 1 [json_name = "x"];
inline void Vec3::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline double Vec3::x() const {
  // @@protoc_insertion_point(field_get:df.plugin.Vec3.x)
  return _internal_x();
}
inline void Vec3::set_x(double value) {
  _internal_set_x(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:df.plugin.Vec3.x)
}
inline double Vec3::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vec3::_internal_set_x(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// double y = 2 [json_name = "y"];
inline void Vec3::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline double Vec3::y() const {
  // @@protoc_insertion_point(field_get:df.plugin.Vec3.y)
  return _internal_y();
}
inline void Vec3::set_y(double value) {
  _internal_set_y(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:df.plugin.Vec3.y)
}
inline double Vec3::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vec3::_internal_set_y(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// double z = 3 [json_name = "z"];
inline void Vec3::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double Vec3::z() const {
  // @@protoc_insertion_point(field_get:df.plugin.Vec3.z)
  return _internal_z();
}
inline void Vec3::set_z(double value) {
  _internal_set_z(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:df.plugin.Vec3.z)
}
inline double Vec3::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vec3::_internal_set_z(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Rotation

// float yaw = 1 [json_name = "yaw"];
inline void Rotation::clear_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yaw_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float Rotation::yaw() const {
  // @@protoc_insertion_point(field_get:df.plugin.Rotation.yaw)
  return _internal_yaw();
}
inline void Rotation::set_yaw(float value) {
  _internal_set_yaw(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:df.plugin.Rotation.yaw)
}
inline float Rotation::_internal_yaw() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.yaw_;
}
inline void Rotation::_internal_set_yaw(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yaw_ = value;
}

// float pitch = 2 [json_name = "pitch"];
inline void Rotation::clear_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pitch_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline float Rotation::pitch() const {
  // @@protoc_insertion_point(field_get:df.plugin.Rotation.pitch)
  return _internal_pitch();
}
inline void Rotation::set_pitch(float value) {
  _internal_set_pitch(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:df.plugin.Rotation.pitch)
}
inline float Rotation::_internal_pitch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pitch_;
}
inline void Rotation::_internal_set_pitch(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pitch_ = value;
}

// -------------------------------------------------------------------

// BBox

// .df.plugin.Vec3 min = 1 [json_name = "min"];
inline bool BBox::has_min() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.min_ != nullptr);
  return value;
}
inline void BBox::clear_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.min_ != nullptr) _impl_.min_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::df::plugin::Vec3& BBox::_internal_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::Vec3* p = _impl_.min_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::Vec3&>(::df::plugin::_Vec3_default_instance_);
}
inline const ::df::plugin::Vec3& BBox::min() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.BBox.min)
  return _internal_min();
}
inline void BBox::unsafe_arena_set_allocated_min(
    ::df::plugin::Vec3* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_);
  }
  _impl_.min_ = reinterpret_cast<::df::plugin::Vec3*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.BBox.min)
}
inline ::df::plugin::Vec3* PROTOBUF_NULLABLE BBox::release_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::Vec3* released = _impl_.min_;
  _impl_.min_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::Vec3* PROTOBUF_NULLABLE BBox::unsafe_arena_release_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.BBox.min)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::Vec3* temp = _impl_.min_;
  _impl_.min_ = nullptr;
  return temp;
}
inline ::df::plugin::Vec3* PROTOBUF_NONNULL BBox::_internal_mutable_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.min_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::Vec3>(GetArena());
    _impl_.min_ = reinterpret_cast<::df::plugin::Vec3*>(p);
  }
  return _impl_.min_;
}
inline ::df::plugin::Vec3* PROTOBUF_NONNULL BBox::mutable_min()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::df::plugin::Vec3* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:df.plugin.BBox.min)
  return _msg;
}
inline void BBox::set_allocated_min(::df::plugin::Vec3* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.min_ = reinterpret_cast<::df::plugin::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.BBox.min)
}

// .df.plugin.Vec3 max = 2 [json_name = "max"];
inline bool BBox::has_max() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.max_ != nullptr);
  return value;
}
inline void BBox::clear_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.max_ != nullptr) _impl_.max_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::df::plugin::Vec3& BBox::_internal_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::Vec3* p = _impl_.max_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::Vec3&>(::df::plugin::_Vec3_default_instance_);
}
inline const ::df::plugin::Vec3& BBox::max() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.BBox.max)
  return _internal_max();
}
inline void BBox::unsafe_arena_set_allocated_max(
    ::df::plugin::Vec3* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_);
  }
  _impl_.max_ = reinterpret_cast<::df::plugin::Vec3*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.BBox.max)
}
inline ::df::plugin::Vec3* PROTOBUF_NULLABLE BBox::release_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::Vec3* released = _impl_.max_;
  _impl_.max_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::Vec3* PROTOBUF_NULLABLE BBox::unsafe_arena_release_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.BBox.max)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::Vec3* temp = _impl_.max_;
  _impl_.max_ = nullptr;
  return temp;
}
inline ::df::plugin::Vec3* PROTOBUF_NONNULL BBox::_internal_mutable_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.max_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::Vec3>(GetArena());
    _impl_.max_ = reinterpret_cast<::df::plugin::Vec3*>(p);
  }
  return _impl_.max_;
}
inline ::df::plugin::Vec3* PROTOBUF_NONNULL BBox::mutable_max()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::Vec3* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:df.plugin.BBox.max)
  return _msg;
}
inline void BBox::set_allocated_max(::df::plugin::Vec3* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.max_ = reinterpret_cast<::df::plugin::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.BBox.max)
}

// -------------------------------------------------------------------

// BlockPos

// int32 x = 1 [json_name = "x"];
inline void BlockPos::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t BlockPos::x() const {
  // @@protoc_insertion_point(field_get:df.plugin.BlockPos.x)
  return _internal_x();
}
inline void BlockPos::set_x(::int32_t value) {
  _internal_set_x(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:df.plugin.BlockPos.x)
}
inline ::int32_t BlockPos::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void BlockPos::_internal_set_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// int32 y = 2 [json_name = "y"];
inline void BlockPos::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t BlockPos::y() const {
  // @@protoc_insertion_point(field_get:df.plugin.BlockPos.y)
  return _internal_y();
}
inline void BlockPos::set_y(::int32_t value) {
  _internal_set_y(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:df.plugin.BlockPos.y)
}
inline ::int32_t BlockPos::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void BlockPos::_internal_set_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// int32 z = 3 [json_name = "z"];
inline void BlockPos::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t BlockPos::z() const {
  // @@protoc_insertion_point(field_get:df.plugin.BlockPos.z)
  return _internal_z();
}
inline void BlockPos::set_z(::int32_t value) {
  _internal_set_z(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:df.plugin.BlockPos.z)
}
inline ::int32_t BlockPos::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void BlockPos::_internal_set_z(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// ItemStack

// string name = 1 [json_name = "name"];
inline void ItemStack::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ItemStack::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.ItemStack.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ItemStack::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.ItemStack.name)
}
inline ::std::string* PROTOBUF_NONNULL ItemStack::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:df.plugin.ItemStack.name)
  return _s;
}
inline const ::std::string& ItemStack::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ItemStack::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ItemStack::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ItemStack::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.ItemStack.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void ItemStack::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.ItemStack.name)
}

// int32 meta = 2 [json_name = "meta"];
inline void ItemStack::clear_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meta_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t ItemStack::meta() const {
  // @@protoc_insertion_point(field_get:df.plugin.ItemStack.meta)
  return _internal_meta();
}
inline void ItemStack::set_meta(::int32_t value) {
  _internal_set_meta(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:df.plugin.ItemStack.meta)
}
inline ::int32_t ItemStack::_internal_meta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.meta_;
}
inline void ItemStack::_internal_set_meta(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meta_ = value;
}

// int32 count = 3 [json_name = "count"];
inline void ItemStack::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t ItemStack::count() const {
  // @@protoc_insertion_point(field_get:df.plugin.ItemStack.count)
  return _internal_count();
}
inline void ItemStack::set_count(::int32_t value) {
  _internal_set_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:df.plugin.ItemStack.count)
}
inline ::int32_t ItemStack::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void ItemStack::_internal_set_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BlockState

// string name = 1 [json_name = "name"];
inline void BlockState::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& BlockState::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.BlockState.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BlockState::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.BlockState.name)
}
inline ::std::string* PROTOBUF_NONNULL BlockState::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:df.plugin.BlockState.name)
  return _s;
}
inline const ::std::string& BlockState::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void BlockState::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BlockState::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BlockState::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.BlockState.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void BlockState::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.BlockState.name)
}

// map<string, string> properties = 2 [json_name = "properties"];
inline int BlockState::_internal_properties_size() const {
  return _internal_properties().size();
}
inline int BlockState::properties_size() const {
  return _internal_properties_size();
}
inline void BlockState::clear_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.properties_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::google::protobuf::Map<::std::string, ::std::string>& BlockState::_internal_properties() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.properties_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::std::string>& BlockState::properties() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:df.plugin.BlockState.properties)
  return _internal_properties();
}
inline ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL BlockState::_internal_mutable_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.properties_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL BlockState::mutable_properties()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_map:df.plugin.BlockState.properties)
  return _internal_mutable_properties();
}

// -------------------------------------------------------------------

// LiquidState

// .df.plugin.BlockState block = 1 [json_name = "block"];
inline bool LiquidState::has_block() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.block_ != nullptr);
  return value;
}
inline void LiquidState::clear_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_ != nullptr) _impl_.block_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::df::plugin::BlockState& LiquidState::_internal_block() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::BlockState* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::BlockState&>(::df::plugin::_BlockState_default_instance_);
}
inline const ::df::plugin::BlockState& LiquidState::block() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.LiquidState.block)
  return _internal_block();
}
inline void LiquidState::unsafe_arena_set_allocated_block(
    ::df::plugin::BlockState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = reinterpret_cast<::df::plugin::BlockState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.LiquidState.block)
}
inline ::df::plugin::BlockState* PROTOBUF_NULLABLE LiquidState::release_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::BlockState* released = _impl_.block_;
  _impl_.block_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::BlockState* PROTOBUF_NULLABLE LiquidState::unsafe_arena_release_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.LiquidState.block)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::BlockState* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::df::plugin::BlockState* PROTOBUF_NONNULL LiquidState::_internal_mutable_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::BlockState>(GetArena());
    _impl_.block_ = reinterpret_cast<::df::plugin::BlockState*>(p);
  }
  return _impl_.block_;
}
inline ::df::plugin::BlockState* PROTOBUF_NONNULL LiquidState::mutable_block()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::df::plugin::BlockState* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:df.plugin.LiquidState.block)
  return _msg;
}
inline void LiquidState::set_allocated_block(::df::plugin::BlockState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.block_ = reinterpret_cast<::df::plugin::BlockState*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.LiquidState.block)
}

// int32 depth = 2 [json_name = "depth"];
inline void LiquidState::clear_depth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.depth_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t LiquidState::depth() const {
  // @@protoc_insertion_point(field_get:df.plugin.LiquidState.depth)
  return _internal_depth();
}
inline void LiquidState::set_depth(::int32_t value) {
  _internal_set_depth(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:df.plugin.LiquidState.depth)
}
inline ::int32_t LiquidState::_internal_depth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.depth_;
}
inline void LiquidState::_internal_set_depth(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.depth_ = value;
}

// bool falling = 3 [json_name = "falling"];
inline void LiquidState::clear_falling() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.falling_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool LiquidState::falling() const {
  // @@protoc_insertion_point(field_get:df.plugin.LiquidState.falling)
  return _internal_falling();
}
inline void LiquidState::set_falling(bool value) {
  _internal_set_falling(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:df.plugin.LiquidState.falling)
}
inline bool LiquidState::_internal_falling() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.falling_;
}
inline void LiquidState::_internal_set_falling(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.falling_ = value;
}

// string liquid_type = 4 [json_name = "liquidType"];
inline void LiquidState::clear_liquid_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.liquid_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& LiquidState::liquid_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.LiquidState.liquid_type)
  return _internal_liquid_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void LiquidState::set_liquid_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.liquid_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.LiquidState.liquid_type)
}
inline ::std::string* PROTOBUF_NONNULL LiquidState::mutable_liquid_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_liquid_type();
  // @@protoc_insertion_point(field_mutable:df.plugin.LiquidState.liquid_type)
  return _s;
}
inline const ::std::string& LiquidState::_internal_liquid_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.liquid_type_.Get();
}
inline void LiquidState::_internal_set_liquid_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.liquid_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL LiquidState::_internal_mutable_liquid_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.liquid_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE LiquidState::release_liquid_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.LiquidState.liquid_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.liquid_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.liquid_type_.Set("", GetArena());
  }
  return released;
}
inline void LiquidState::set_allocated_liquid_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.liquid_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.liquid_type_.IsDefault()) {
    _impl_.liquid_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.LiquidState.liquid_type)
}

// -------------------------------------------------------------------

// WorldRef

// string name = 1 [json_name = "name"];
inline void WorldRef::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& WorldRef::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.WorldRef.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void WorldRef::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.WorldRef.name)
}
inline ::std::string* PROTOBUF_NONNULL WorldRef::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:df.plugin.WorldRef.name)
  return _s;
}
inline const ::std::string& WorldRef::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void WorldRef::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL WorldRef::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE WorldRef::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.WorldRef.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void WorldRef::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.WorldRef.name)
}

// string dimension = 2 [json_name = "dimension"];
inline void WorldRef::clear_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& WorldRef::dimension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.WorldRef.dimension)
  return _internal_dimension();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void WorldRef::set_dimension(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.dimension_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.WorldRef.dimension)
}
inline ::std::string* PROTOBUF_NONNULL WorldRef::mutable_dimension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_dimension();
  // @@protoc_insertion_point(field_mutable:df.plugin.WorldRef.dimension)
  return _s;
}
inline const ::std::string& WorldRef::_internal_dimension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dimension_.Get();
}
inline void WorldRef::_internal_set_dimension(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL WorldRef::_internal_mutable_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dimension_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE WorldRef::release_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.WorldRef.dimension)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.dimension_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dimension_.Set("", GetArena());
  }
  return released;
}
inline void WorldRef::set_allocated_dimension(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.dimension_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dimension_.IsDefault()) {
    _impl_.dimension_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.WorldRef.dimension)
}

// -------------------------------------------------------------------

// EntityRef

// string uuid = 1 [json_name = "uuid"];
inline void EntityRef::clear_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& EntityRef::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EntityRef.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EntityRef::set_uuid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.EntityRef.uuid)
}
inline ::std::string* PROTOBUF_NONNULL EntityRef::mutable_uuid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:df.plugin.EntityRef.uuid)
  return _s;
}
inline const ::std::string& EntityRef::_internal_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uuid_.Get();
}
inline void EntityRef::_internal_set_uuid(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EntityRef::_internal_mutable_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uuid_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EntityRef::release_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.EntityRef.uuid)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.uuid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.uuid_.Set("", GetArena());
  }
  return released;
}
inline void EntityRef::set_allocated_uuid(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.uuid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.EntityRef.uuid)
}

// string type = 2 [json_name = "type"];
inline void EntityRef::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& EntityRef::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EntityRef.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EntityRef::set_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.EntityRef.type)
}
inline ::std::string* PROTOBUF_NONNULL EntityRef::mutable_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:df.plugin.EntityRef.type)
  return _s;
}
inline const ::std::string& EntityRef::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void EntityRef::_internal_set_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EntityRef::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EntityRef::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.EntityRef.type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void EntityRef::set_allocated_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.EntityRef.type)
}

// optional string name = 3 [json_name = "name"];
inline bool EntityRef::has_name() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void EntityRef::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& EntityRef::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EntityRef.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EntityRef::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.EntityRef.name)
}
inline ::std::string* PROTOBUF_NONNULL EntityRef::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:df.plugin.EntityRef.name)
  return _s;
}
inline const ::std::string& EntityRef::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void EntityRef::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EntityRef::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EntityRef::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.EntityRef.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void EntityRef::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.EntityRef.name)
}

// optional .df.plugin.Vec3 position = 4 [json_name = "position"];
inline bool EntityRef::has_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void EntityRef::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::df::plugin::Vec3& EntityRef::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::Vec3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::Vec3&>(::df::plugin::_Vec3_default_instance_);
}
inline const ::df::plugin::Vec3& EntityRef::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EntityRef.position)
  return _internal_position();
}
inline void EntityRef::unsafe_arena_set_allocated_position(
    ::df::plugin::Vec3* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::df::plugin::Vec3*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EntityRef.position)
}
inline ::df::plugin::Vec3* PROTOBUF_NULLABLE EntityRef::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::df::plugin::Vec3* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::Vec3* PROTOBUF_NULLABLE EntityRef::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.EntityRef.position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::df::plugin::Vec3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::df::plugin::Vec3* PROTOBUF_NONNULL EntityRef::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::Vec3>(GetArena());
    _impl_.position_ = reinterpret_cast<::df::plugin::Vec3*>(p);
  }
  return _impl_.position_;
}
inline ::df::plugin::Vec3* PROTOBUF_NONNULL EntityRef::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::df::plugin::Vec3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:df.plugin.EntityRef.position)
  return _msg;
}
inline void EntityRef::set_allocated_position(::df::plugin::Vec3* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.position_ = reinterpret_cast<::df::plugin::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.EntityRef.position)
}

// optional .df.plugin.Rotation rotation = 5 [json_name = "rotation"];
inline bool EntityRef::has_rotation() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void EntityRef::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::df::plugin::Rotation& EntityRef::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::df::plugin::Rotation* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::df::plugin::Rotation&>(::df::plugin::_Rotation_default_instance_);
}
inline const ::df::plugin::Rotation& EntityRef::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.EntityRef.rotation)
  return _internal_rotation();
}
inline void EntityRef::unsafe_arena_set_allocated_rotation(
    ::df::plugin::Rotation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::df::plugin::Rotation*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:df.plugin.EntityRef.rotation)
}
inline ::df::plugin::Rotation* PROTOBUF_NULLABLE EntityRef::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::df::plugin::Rotation* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::df::plugin::Rotation* PROTOBUF_NULLABLE EntityRef::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.EntityRef.rotation)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::df::plugin::Rotation* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::df::plugin::Rotation* PROTOBUF_NONNULL EntityRef::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::df::plugin::Rotation>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::df::plugin::Rotation*>(p);
  }
  return _impl_.rotation_;
}
inline ::df::plugin::Rotation* PROTOBUF_NONNULL EntityRef::mutable_rotation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::df::plugin::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:df.plugin.EntityRef.rotation)
  return _msg;
}
inline void EntityRef::set_allocated_rotation(::df::plugin::Rotation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.rotation_ = reinterpret_cast<::df::plugin::Rotation*>(value);
  // @@protoc_insertion_point(field_set_allocated:df.plugin.EntityRef.rotation)
}

// -------------------------------------------------------------------

// DamageSource

// string type = 1 [json_name = "type"];
inline void DamageSource::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& DamageSource::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.DamageSource.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DamageSource::set_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.DamageSource.type)
}
inline ::std::string* PROTOBUF_NONNULL DamageSource::mutable_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:df.plugin.DamageSource.type)
  return _s;
}
inline const ::std::string& DamageSource::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void DamageSource::_internal_set_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DamageSource::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DamageSource::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.DamageSource.type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void DamageSource::set_allocated_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.DamageSource.type)
}

// optional string description = 2 [json_name = "description"];
inline bool DamageSource::has_description() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void DamageSource::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& DamageSource::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.DamageSource.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DamageSource::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.DamageSource.description)
}
inline ::std::string* PROTOBUF_NONNULL DamageSource::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:df.plugin.DamageSource.description)
  return _s;
}
inline const ::std::string& DamageSource::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void DamageSource::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DamageSource::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DamageSource::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.DamageSource.description)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void DamageSource::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.DamageSource.description)
}

// -------------------------------------------------------------------

// HealingSource

// string type = 1 [json_name = "type"];
inline void HealingSource::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& HealingSource::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.HealingSource.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HealingSource::set_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.HealingSource.type)
}
inline ::std::string* PROTOBUF_NONNULL HealingSource::mutable_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:df.plugin.HealingSource.type)
  return _s;
}
inline const ::std::string& HealingSource::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void HealingSource::_internal_set_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HealingSource::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HealingSource::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.HealingSource.type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void HealingSource::set_allocated_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.HealingSource.type)
}

// optional string description = 2 [json_name = "description"];
inline bool HealingSource::has_description() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void HealingSource::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& HealingSource::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.HealingSource.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HealingSource::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.HealingSource.description)
}
inline ::std::string* PROTOBUF_NONNULL HealingSource::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:df.plugin.HealingSource.description)
  return _s;
}
inline const ::std::string& HealingSource::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void HealingSource::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HealingSource::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HealingSource::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.HealingSource.description)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void HealingSource::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.HealingSource.description)
}

// -------------------------------------------------------------------

// Address

// string host = 1 [json_name = "host"];
inline void Address::clear_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& Address::host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.Address.host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Address::set_host(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.Address.host)
}
inline ::std::string* PROTOBUF_NONNULL Address::mutable_host()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:df.plugin.Address.host)
  return _s;
}
inline const ::std::string& Address::_internal_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.host_.Get();
}
inline void Address::_internal_set_host(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Address::_internal_mutable_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.host_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Address::release_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.Address.host)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.host_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.host_.Set("", GetArena());
  }
  return released;
}
inline void Address::set_allocated_host(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.host_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.Address.host)
}

// int32 port = 2 [json_name = "port"];
inline void Address::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t Address::port() const {
  // @@protoc_insertion_point(field_get:df.plugin.Address.port)
  return _internal_port();
}
inline void Address::set_port(::int32_t value) {
  _internal_set_port(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:df.plugin.Address.port)
}
inline ::int32_t Address::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void Address::_internal_set_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// CustomItemDefinition

// string id = 1 [json_name = "id"];
inline void CustomItemDefinition::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CustomItemDefinition::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.CustomItemDefinition.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CustomItemDefinition::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.CustomItemDefinition.id)
}
inline ::std::string* PROTOBUF_NONNULL CustomItemDefinition::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:df.plugin.CustomItemDefinition.id)
  return _s;
}
inline const ::std::string& CustomItemDefinition::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void CustomItemDefinition::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CustomItemDefinition::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CustomItemDefinition::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.CustomItemDefinition.id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void CustomItemDefinition::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.CustomItemDefinition.id)
}

// string display_name = 2 [json_name = "displayName"];
inline void CustomItemDefinition::clear_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& CustomItemDefinition::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.CustomItemDefinition.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CustomItemDefinition::set_display_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.CustomItemDefinition.display_name)
}
inline ::std::string* PROTOBUF_NONNULL CustomItemDefinition::mutable_display_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:df.plugin.CustomItemDefinition.display_name)
  return _s;
}
inline const ::std::string& CustomItemDefinition::_internal_display_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.display_name_.Get();
}
inline void CustomItemDefinition::_internal_set_display_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CustomItemDefinition::_internal_mutable_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.display_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CustomItemDefinition::release_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.CustomItemDefinition.display_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.display_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.display_name_.Set("", GetArena());
  }
  return released;
}
inline void CustomItemDefinition::set_allocated_display_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.display_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.CustomItemDefinition.display_name)
}

// bytes texture_data = 3 [json_name = "textureData"];
inline void CustomItemDefinition::clear_texture_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.texture_data_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& CustomItemDefinition::texture_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.CustomItemDefinition.texture_data)
  return _internal_texture_data();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CustomItemDefinition::set_texture_data(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.texture_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.CustomItemDefinition.texture_data)
}
inline ::std::string* PROTOBUF_NONNULL CustomItemDefinition::mutable_texture_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_texture_data();
  // @@protoc_insertion_point(field_mutable:df.plugin.CustomItemDefinition.texture_data)
  return _s;
}
inline const ::std::string& CustomItemDefinition::_internal_texture_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.texture_data_.Get();
}
inline void CustomItemDefinition::_internal_set_texture_data(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.texture_data_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CustomItemDefinition::_internal_mutable_texture_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.texture_data_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CustomItemDefinition::release_texture_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.CustomItemDefinition.texture_data)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.texture_data_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.texture_data_.Set("", GetArena());
  }
  return released;
}
inline void CustomItemDefinition::set_allocated_texture_data(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.texture_data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.texture_data_.IsDefault()) {
    _impl_.texture_data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.CustomItemDefinition.texture_data)
}

// .df.plugin.ItemCategory category = 4 [json_name = "category"];
inline void CustomItemDefinition::clear_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::df::plugin::ItemCategory CustomItemDefinition::category() const {
  // @@protoc_insertion_point(field_get:df.plugin.CustomItemDefinition.category)
  return _internal_category();
}
inline void CustomItemDefinition::set_category(::df::plugin::ItemCategory value) {
  _internal_set_category(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:df.plugin.CustomItemDefinition.category)
}
inline ::df::plugin::ItemCategory CustomItemDefinition::_internal_category() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::df::plugin::ItemCategory>(_impl_.category_);
}
inline void CustomItemDefinition::_internal_set_category(::df::plugin::ItemCategory value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_ = value;
}

// optional string group = 5 [json_name = "group"];
inline bool CustomItemDefinition::has_group() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void CustomItemDefinition::clear_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& CustomItemDefinition::group() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:df.plugin.CustomItemDefinition.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CustomItemDefinition::set_group(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:df.plugin.CustomItemDefinition.group)
}
inline ::std::string* PROTOBUF_NONNULL CustomItemDefinition::mutable_group()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:df.plugin.CustomItemDefinition.group)
  return _s;
}
inline const ::std::string& CustomItemDefinition::_internal_group() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_.Get();
}
inline void CustomItemDefinition::_internal_set_group(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CustomItemDefinition::_internal_mutable_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.group_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CustomItemDefinition::release_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:df.plugin.CustomItemDefinition.group)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.group_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.group_.Set("", GetArena());
  }
  return released;
}
inline void CustomItemDefinition::set_allocated_group(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.group_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:df.plugin.CustomItemDefinition.group)
}

// int32 meta = 6 [json_name = "meta"];
inline void CustomItemDefinition::clear_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meta_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::int32_t CustomItemDefinition::meta() const {
  // @@protoc_insertion_point(field_get:df.plugin.CustomItemDefinition.meta)
  return _internal_meta();
}
inline void CustomItemDefinition::set_meta(::int32_t value) {
  _internal_set_meta(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:df.plugin.CustomItemDefinition.meta)
}
inline ::int32_t CustomItemDefinition::_internal_meta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.meta_;
}
inline void CustomItemDefinition::_internal_set_meta(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meta_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace plugin
}  // namespace df


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::df::plugin::GameMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::df::plugin::GameMode>() {
  return ::df::plugin::GameMode_descriptor();
}
template <>
struct is_proto_enum<::df::plugin::Difficulty> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::df::plugin::Difficulty>() {
  return ::df::plugin::Difficulty_descriptor();
}
template <>
struct is_proto_enum<::df::plugin::EffectType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::df::plugin::EffectType>() {
  return ::df::plugin::EffectType_descriptor();
}
template <>
struct is_proto_enum<::df::plugin::Sound> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::df::plugin::Sound>() {
  return ::df::plugin::Sound_descriptor();
}
template <>
struct is_proto_enum<::df::plugin::ItemCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::df::plugin::ItemCategory>() {
  return ::df::plugin::ItemCategory_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // common_2eproto_2epb_2eh
