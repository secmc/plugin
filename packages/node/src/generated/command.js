// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: command.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export const protobufPackage = "df.plugin";
/** Supported parameter types for commands. */
export var ParamType;
(function (ParamType) {
    ParamType[ParamType["PARAM_STRING"] = 0] = "PARAM_STRING";
    ParamType[ParamType["PARAM_INT"] = 1] = "PARAM_INT";
    ParamType[ParamType["PARAM_FLOAT"] = 2] = "PARAM_FLOAT";
    ParamType[ParamType["PARAM_BOOL"] = 3] = "PARAM_BOOL";
    ParamType[ParamType["PARAM_VARARGS"] = 4] = "PARAM_VARARGS";
    ParamType[ParamType["PARAM_ENUM"] = 5] = "PARAM_ENUM";
    ParamType[ParamType["PARAM_TARGET"] = 6] = "PARAM_TARGET";
    ParamType[ParamType["PARAM_TARGETS"] = 7] = "PARAM_TARGETS";
    ParamType[ParamType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ParamType || (ParamType = {}));
export function paramTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "PARAM_STRING":
            return ParamType.PARAM_STRING;
        case 1:
        case "PARAM_INT":
            return ParamType.PARAM_INT;
        case 2:
        case "PARAM_FLOAT":
            return ParamType.PARAM_FLOAT;
        case 3:
        case "PARAM_BOOL":
            return ParamType.PARAM_BOOL;
        case 4:
        case "PARAM_VARARGS":
            return ParamType.PARAM_VARARGS;
        case 5:
        case "PARAM_ENUM":
            return ParamType.PARAM_ENUM;
        case 6:
        case "PARAM_TARGET":
            return ParamType.PARAM_TARGET;
        case 7:
        case "PARAM_TARGETS":
            return ParamType.PARAM_TARGETS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ParamType.UNRECOGNIZED;
    }
}
export function paramTypeToJSON(object) {
    switch (object) {
        case ParamType.PARAM_STRING:
            return "PARAM_STRING";
        case ParamType.PARAM_INT:
            return "PARAM_INT";
        case ParamType.PARAM_FLOAT:
            return "PARAM_FLOAT";
        case ParamType.PARAM_BOOL:
            return "PARAM_BOOL";
        case ParamType.PARAM_VARARGS:
            return "PARAM_VARARGS";
        case ParamType.PARAM_ENUM:
            return "PARAM_ENUM";
        case ParamType.PARAM_TARGET:
            return "PARAM_TARGET";
        case ParamType.PARAM_TARGETS:
            return "PARAM_TARGETS";
        case ParamType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseParamSpec() {
    return { name: "", type: 0, optional: false, suffix: "", enumValues: [] };
}
export const ParamSpec = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.type !== 0) {
            writer.uint32(16).int32(message.type);
        }
        if (message.optional !== false) {
            writer.uint32(24).bool(message.optional);
        }
        if (message.suffix !== "") {
            writer.uint32(34).string(message.suffix);
        }
        for (const v of message.enumValues) {
            writer.uint32(42).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParamSpec();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.optional = reader.bool();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.suffix = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.enumValues.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            type: isSet(object.type) ? paramTypeFromJSON(object.type) : 0,
            optional: isSet(object.optional) ? globalThis.Boolean(object.optional) : false,
            suffix: isSet(object.suffix) ? globalThis.String(object.suffix) : "",
            enumValues: globalThis.Array.isArray(object?.enumValues)
                ? object.enumValues.map((e) => globalThis.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.type !== 0) {
            obj.type = paramTypeToJSON(message.type);
        }
        if (message.optional !== false) {
            obj.optional = message.optional;
        }
        if (message.suffix !== "") {
            obj.suffix = message.suffix;
        }
        if (message.enumValues?.length) {
            obj.enumValues = message.enumValues;
        }
        return obj;
    },
    create(base) {
        return ParamSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParamSpec();
        message.name = object.name ?? "";
        message.type = object.type ?? 0;
        message.optional = object.optional ?? false;
        message.suffix = object.suffix ?? "";
        message.enumValues = object.enumValues?.map((e) => e) || [];
        return message;
    },
};
function createBaseCommandSpec() {
    return { name: "", description: "", aliases: [], params: [] };
}
export const CommandSpec = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        for (const v of message.aliases) {
            writer.uint32(26).string(v);
        }
        for (const v of message.params) {
            ParamSpec.encode(v, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandSpec();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.aliases.push(reader.string());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.params.push(ParamSpec.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            aliases: globalThis.Array.isArray(object?.aliases) ? object.aliases.map((e) => globalThis.String(e)) : [],
            params: globalThis.Array.isArray(object?.params) ? object.params.map((e) => ParamSpec.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.aliases?.length) {
            obj.aliases = message.aliases;
        }
        if (message.params?.length) {
            obj.params = message.params.map((e) => ParamSpec.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CommandSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandSpec();
        message.name = object.name ?? "";
        message.description = object.description ?? "";
        message.aliases = object.aliases?.map((e) => e) || [];
        message.params = object.params?.map((e) => ParamSpec.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCommandEvent() {
    return { playerUuid: "", name: "", raw: "", command: "", args: [] };
}
export const CommandEvent = {
    encode(message, writer = new BinaryWriter()) {
        if (message.playerUuid !== "") {
            writer.uint32(10).string(message.playerUuid);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.raw !== "") {
            writer.uint32(26).string(message.raw);
        }
        if (message.command !== "") {
            writer.uint32(34).string(message.command);
        }
        for (const v of message.args) {
            writer.uint32(42).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.playerUuid = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.raw = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.command = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.args.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            raw: isSet(object.raw) ? globalThis.String(object.raw) : "",
            command: isSet(object.command) ? globalThis.String(object.command) : "",
            args: globalThis.Array.isArray(object?.args) ? object.args.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.playerUuid !== "") {
            obj.playerUuid = message.playerUuid;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.raw !== "") {
            obj.raw = message.raw;
        }
        if (message.command !== "") {
            obj.command = message.command;
        }
        if (message.args?.length) {
            obj.args = message.args;
        }
        return obj;
    },
    create(base) {
        return CommandEvent.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandEvent();
        message.playerUuid = object.playerUuid ?? "";
        message.name = object.name ?? "";
        message.raw = object.raw ?? "";
        message.command = object.command ?? "";
        message.args = object.args?.map((e) => e) || [];
        return message;
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
