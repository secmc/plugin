// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: common.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export const protobufPackage = "df.plugin";
export var GameMode;
(function (GameMode) {
    GameMode[GameMode["SURVIVAL"] = 0] = "SURVIVAL";
    GameMode[GameMode["CREATIVE"] = 1] = "CREATIVE";
    GameMode[GameMode["ADVENTURE"] = 2] = "ADVENTURE";
    GameMode[GameMode["SPECTATOR"] = 3] = "SPECTATOR";
    GameMode[GameMode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(GameMode || (GameMode = {}));
export function gameModeFromJSON(object) {
    switch (object) {
        case 0:
        case "SURVIVAL":
            return GameMode.SURVIVAL;
        case 1:
        case "CREATIVE":
            return GameMode.CREATIVE;
        case 2:
        case "ADVENTURE":
            return GameMode.ADVENTURE;
        case 3:
        case "SPECTATOR":
            return GameMode.SPECTATOR;
        case -1:
        case "UNRECOGNIZED":
        default:
            return GameMode.UNRECOGNIZED;
    }
}
export function gameModeToJSON(object) {
    switch (object) {
        case GameMode.SURVIVAL:
            return "SURVIVAL";
        case GameMode.CREATIVE:
            return "CREATIVE";
        case GameMode.ADVENTURE:
            return "ADVENTURE";
        case GameMode.SPECTATOR:
            return "SPECTATOR";
        case GameMode.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var Difficulty;
(function (Difficulty) {
    Difficulty[Difficulty["PEACEFUL"] = 0] = "PEACEFUL";
    Difficulty[Difficulty["EASY"] = 1] = "EASY";
    Difficulty[Difficulty["NORMAL"] = 2] = "NORMAL";
    Difficulty[Difficulty["HARD"] = 3] = "HARD";
    Difficulty[Difficulty["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Difficulty || (Difficulty = {}));
export function difficultyFromJSON(object) {
    switch (object) {
        case 0:
        case "PEACEFUL":
            return Difficulty.PEACEFUL;
        case 1:
        case "EASY":
            return Difficulty.EASY;
        case 2:
        case "NORMAL":
            return Difficulty.NORMAL;
        case 3:
        case "HARD":
            return Difficulty.HARD;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Difficulty.UNRECOGNIZED;
    }
}
export function difficultyToJSON(object) {
    switch (object) {
        case Difficulty.PEACEFUL:
            return "PEACEFUL";
        case Difficulty.EASY:
            return "EASY";
        case Difficulty.NORMAL:
            return "NORMAL";
        case Difficulty.HARD:
            return "HARD";
        case Difficulty.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/**
 * EffectType mirrors Dragonfly's registered effect IDs for straightforward mapping.
 * Keep numeric values aligned with dragonfly/server/entity/effect/register.go.
 */
export var EffectType;
(function (EffectType) {
    EffectType[EffectType["EFFECT_UNKNOWN"] = 0] = "EFFECT_UNKNOWN";
    EffectType[EffectType["SPEED"] = 1] = "SPEED";
    EffectType[EffectType["SLOWNESS"] = 2] = "SLOWNESS";
    EffectType[EffectType["HASTE"] = 3] = "HASTE";
    EffectType[EffectType["MINING_FATIGUE"] = 4] = "MINING_FATIGUE";
    EffectType[EffectType["STRENGTH"] = 5] = "STRENGTH";
    EffectType[EffectType["INSTANT_HEALTH"] = 6] = "INSTANT_HEALTH";
    EffectType[EffectType["INSTANT_DAMAGE"] = 7] = "INSTANT_DAMAGE";
    EffectType[EffectType["JUMP_BOOST"] = 8] = "JUMP_BOOST";
    EffectType[EffectType["NAUSEA"] = 9] = "NAUSEA";
    EffectType[EffectType["REGENERATION"] = 10] = "REGENERATION";
    EffectType[EffectType["RESISTANCE"] = 11] = "RESISTANCE";
    EffectType[EffectType["FIRE_RESISTANCE"] = 12] = "FIRE_RESISTANCE";
    EffectType[EffectType["WATER_BREATHING"] = 13] = "WATER_BREATHING";
    EffectType[EffectType["INVISIBILITY"] = 14] = "INVISIBILITY";
    EffectType[EffectType["BLINDNESS"] = 15] = "BLINDNESS";
    EffectType[EffectType["NIGHT_VISION"] = 16] = "NIGHT_VISION";
    EffectType[EffectType["HUNGER"] = 17] = "HUNGER";
    EffectType[EffectType["WEAKNESS"] = 18] = "WEAKNESS";
    EffectType[EffectType["POISON"] = 19] = "POISON";
    EffectType[EffectType["WITHER"] = 20] = "WITHER";
    EffectType[EffectType["HEALTH_BOOST"] = 21] = "HEALTH_BOOST";
    EffectType[EffectType["ABSORPTION"] = 22] = "ABSORPTION";
    EffectType[EffectType["SATURATION"] = 23] = "SATURATION";
    EffectType[EffectType["LEVITATION"] = 24] = "LEVITATION";
    EffectType[EffectType["FATAL_POISON"] = 25] = "FATAL_POISON";
    EffectType[EffectType["CONDUIT_POWER"] = 26] = "CONDUIT_POWER";
    EffectType[EffectType["SLOW_FALLING"] = 27] = "SLOW_FALLING";
    /** DARKNESS - 28, 29 intentionally omitted (Bad Omen, Hero of the Village - not implemented) */
    EffectType[EffectType["DARKNESS"] = 30] = "DARKNESS";
    EffectType[EffectType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EffectType || (EffectType = {}));
export function effectTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "EFFECT_UNKNOWN":
            return EffectType.EFFECT_UNKNOWN;
        case 1:
        case "SPEED":
            return EffectType.SPEED;
        case 2:
        case "SLOWNESS":
            return EffectType.SLOWNESS;
        case 3:
        case "HASTE":
            return EffectType.HASTE;
        case 4:
        case "MINING_FATIGUE":
            return EffectType.MINING_FATIGUE;
        case 5:
        case "STRENGTH":
            return EffectType.STRENGTH;
        case 6:
        case "INSTANT_HEALTH":
            return EffectType.INSTANT_HEALTH;
        case 7:
        case "INSTANT_DAMAGE":
            return EffectType.INSTANT_DAMAGE;
        case 8:
        case "JUMP_BOOST":
            return EffectType.JUMP_BOOST;
        case 9:
        case "NAUSEA":
            return EffectType.NAUSEA;
        case 10:
        case "REGENERATION":
            return EffectType.REGENERATION;
        case 11:
        case "RESISTANCE":
            return EffectType.RESISTANCE;
        case 12:
        case "FIRE_RESISTANCE":
            return EffectType.FIRE_RESISTANCE;
        case 13:
        case "WATER_BREATHING":
            return EffectType.WATER_BREATHING;
        case 14:
        case "INVISIBILITY":
            return EffectType.INVISIBILITY;
        case 15:
        case "BLINDNESS":
            return EffectType.BLINDNESS;
        case 16:
        case "NIGHT_VISION":
            return EffectType.NIGHT_VISION;
        case 17:
        case "HUNGER":
            return EffectType.HUNGER;
        case 18:
        case "WEAKNESS":
            return EffectType.WEAKNESS;
        case 19:
        case "POISON":
            return EffectType.POISON;
        case 20:
        case "WITHER":
            return EffectType.WITHER;
        case 21:
        case "HEALTH_BOOST":
            return EffectType.HEALTH_BOOST;
        case 22:
        case "ABSORPTION":
            return EffectType.ABSORPTION;
        case 23:
        case "SATURATION":
            return EffectType.SATURATION;
        case 24:
        case "LEVITATION":
            return EffectType.LEVITATION;
        case 25:
        case "FATAL_POISON":
            return EffectType.FATAL_POISON;
        case 26:
        case "CONDUIT_POWER":
            return EffectType.CONDUIT_POWER;
        case 27:
        case "SLOW_FALLING":
            return EffectType.SLOW_FALLING;
        case 30:
        case "DARKNESS":
            return EffectType.DARKNESS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return EffectType.UNRECOGNIZED;
    }
}
export function effectTypeToJSON(object) {
    switch (object) {
        case EffectType.EFFECT_UNKNOWN:
            return "EFFECT_UNKNOWN";
        case EffectType.SPEED:
            return "SPEED";
        case EffectType.SLOWNESS:
            return "SLOWNESS";
        case EffectType.HASTE:
            return "HASTE";
        case EffectType.MINING_FATIGUE:
            return "MINING_FATIGUE";
        case EffectType.STRENGTH:
            return "STRENGTH";
        case EffectType.INSTANT_HEALTH:
            return "INSTANT_HEALTH";
        case EffectType.INSTANT_DAMAGE:
            return "INSTANT_DAMAGE";
        case EffectType.JUMP_BOOST:
            return "JUMP_BOOST";
        case EffectType.NAUSEA:
            return "NAUSEA";
        case EffectType.REGENERATION:
            return "REGENERATION";
        case EffectType.RESISTANCE:
            return "RESISTANCE";
        case EffectType.FIRE_RESISTANCE:
            return "FIRE_RESISTANCE";
        case EffectType.WATER_BREATHING:
            return "WATER_BREATHING";
        case EffectType.INVISIBILITY:
            return "INVISIBILITY";
        case EffectType.BLINDNESS:
            return "BLINDNESS";
        case EffectType.NIGHT_VISION:
            return "NIGHT_VISION";
        case EffectType.HUNGER:
            return "HUNGER";
        case EffectType.WEAKNESS:
            return "WEAKNESS";
        case EffectType.POISON:
            return "POISON";
        case EffectType.WITHER:
            return "WITHER";
        case EffectType.HEALTH_BOOST:
            return "HEALTH_BOOST";
        case EffectType.ABSORPTION:
            return "ABSORPTION";
        case EffectType.SATURATION:
            return "SATURATION";
        case EffectType.LEVITATION:
            return "LEVITATION";
        case EffectType.FATAL_POISON:
            return "FATAL_POISON";
        case EffectType.CONDUIT_POWER:
            return "CONDUIT_POWER";
        case EffectType.SLOW_FALLING:
            return "SLOW_FALLING";
        case EffectType.DARKNESS:
            return "DARKNESS";
        case EffectType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/**
 * Sound is a curated list of common sounds that don't require extra parameters.
 * For sounds that require additional context (e.g., BlockPlace, Note), adapters
 * may use sensible defaults or ignore extra semantics for now.
 */
export var Sound;
(function (Sound) {
    Sound[Sound["SOUND_UNKNOWN"] = 0] = "SOUND_UNKNOWN";
    Sound[Sound["ATTACK"] = 1] = "ATTACK";
    Sound[Sound["DROWNING"] = 2] = "DROWNING";
    Sound[Sound["BURNING"] = 3] = "BURNING";
    Sound[Sound["FALL"] = 4] = "FALL";
    Sound[Sound["BURP"] = 5] = "BURP";
    Sound[Sound["POP"] = 6] = "POP";
    Sound[Sound["EXPLOSION"] = 7] = "EXPLOSION";
    Sound[Sound["THUNDER"] = 8] = "THUNDER";
    Sound[Sound["LEVEL_UP"] = 9] = "LEVEL_UP";
    Sound[Sound["EXPERIENCE"] = 10] = "EXPERIENCE";
    Sound[Sound["FIREWORK_LAUNCH"] = 11] = "FIREWORK_LAUNCH";
    Sound[Sound["FIREWORK_HUGE_BLAST"] = 12] = "FIREWORK_HUGE_BLAST";
    Sound[Sound["FIREWORK_BLAST"] = 13] = "FIREWORK_BLAST";
    Sound[Sound["FIREWORK_TWINKLE"] = 14] = "FIREWORK_TWINKLE";
    Sound[Sound["TELEPORT"] = 15] = "TELEPORT";
    Sound[Sound["ARROW_HIT"] = 16] = "ARROW_HIT";
    Sound[Sound["ITEM_BREAK"] = 17] = "ITEM_BREAK";
    Sound[Sound["ITEM_THROW"] = 18] = "ITEM_THROW";
    Sound[Sound["TOTEM"] = 19] = "TOTEM";
    Sound[Sound["FIRE_EXTINGUISH"] = 20] = "FIRE_EXTINGUISH";
    Sound[Sound["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Sound || (Sound = {}));
export function soundFromJSON(object) {
    switch (object) {
        case 0:
        case "SOUND_UNKNOWN":
            return Sound.SOUND_UNKNOWN;
        case 1:
        case "ATTACK":
            return Sound.ATTACK;
        case 2:
        case "DROWNING":
            return Sound.DROWNING;
        case 3:
        case "BURNING":
            return Sound.BURNING;
        case 4:
        case "FALL":
            return Sound.FALL;
        case 5:
        case "BURP":
            return Sound.BURP;
        case 6:
        case "POP":
            return Sound.POP;
        case 7:
        case "EXPLOSION":
            return Sound.EXPLOSION;
        case 8:
        case "THUNDER":
            return Sound.THUNDER;
        case 9:
        case "LEVEL_UP":
            return Sound.LEVEL_UP;
        case 10:
        case "EXPERIENCE":
            return Sound.EXPERIENCE;
        case 11:
        case "FIREWORK_LAUNCH":
            return Sound.FIREWORK_LAUNCH;
        case 12:
        case "FIREWORK_HUGE_BLAST":
            return Sound.FIREWORK_HUGE_BLAST;
        case 13:
        case "FIREWORK_BLAST":
            return Sound.FIREWORK_BLAST;
        case 14:
        case "FIREWORK_TWINKLE":
            return Sound.FIREWORK_TWINKLE;
        case 15:
        case "TELEPORT":
            return Sound.TELEPORT;
        case 16:
        case "ARROW_HIT":
            return Sound.ARROW_HIT;
        case 17:
        case "ITEM_BREAK":
            return Sound.ITEM_BREAK;
        case 18:
        case "ITEM_THROW":
            return Sound.ITEM_THROW;
        case 19:
        case "TOTEM":
            return Sound.TOTEM;
        case 20:
        case "FIRE_EXTINGUISH":
            return Sound.FIRE_EXTINGUISH;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Sound.UNRECOGNIZED;
    }
}
export function soundToJSON(object) {
    switch (object) {
        case Sound.SOUND_UNKNOWN:
            return "SOUND_UNKNOWN";
        case Sound.ATTACK:
            return "ATTACK";
        case Sound.DROWNING:
            return "DROWNING";
        case Sound.BURNING:
            return "BURNING";
        case Sound.FALL:
            return "FALL";
        case Sound.BURP:
            return "BURP";
        case Sound.POP:
            return "POP";
        case Sound.EXPLOSION:
            return "EXPLOSION";
        case Sound.THUNDER:
            return "THUNDER";
        case Sound.LEVEL_UP:
            return "LEVEL_UP";
        case Sound.EXPERIENCE:
            return "EXPERIENCE";
        case Sound.FIREWORK_LAUNCH:
            return "FIREWORK_LAUNCH";
        case Sound.FIREWORK_HUGE_BLAST:
            return "FIREWORK_HUGE_BLAST";
        case Sound.FIREWORK_BLAST:
            return "FIREWORK_BLAST";
        case Sound.FIREWORK_TWINKLE:
            return "FIREWORK_TWINKLE";
        case Sound.TELEPORT:
            return "TELEPORT";
        case Sound.ARROW_HIT:
            return "ARROW_HIT";
        case Sound.ITEM_BREAK:
            return "ITEM_BREAK";
        case Sound.ITEM_THROW:
            return "ITEM_THROW";
        case Sound.TOTEM:
            return "TOTEM";
        case Sound.FIRE_EXTINGUISH:
            return "FIRE_EXTINGUISH";
        case Sound.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/** Category for creative inventory */
export var ItemCategory;
(function (ItemCategory) {
    ItemCategory[ItemCategory["ITEM_CATEGORY_CONSTRUCTION"] = 0] = "ITEM_CATEGORY_CONSTRUCTION";
    ItemCategory[ItemCategory["ITEM_CATEGORY_NATURE"] = 1] = "ITEM_CATEGORY_NATURE";
    ItemCategory[ItemCategory["ITEM_CATEGORY_EQUIPMENT"] = 2] = "ITEM_CATEGORY_EQUIPMENT";
    ItemCategory[ItemCategory["ITEM_CATEGORY_ITEMS"] = 3] = "ITEM_CATEGORY_ITEMS";
    ItemCategory[ItemCategory["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ItemCategory || (ItemCategory = {}));
export function itemCategoryFromJSON(object) {
    switch (object) {
        case 0:
        case "ITEM_CATEGORY_CONSTRUCTION":
            return ItemCategory.ITEM_CATEGORY_CONSTRUCTION;
        case 1:
        case "ITEM_CATEGORY_NATURE":
            return ItemCategory.ITEM_CATEGORY_NATURE;
        case 2:
        case "ITEM_CATEGORY_EQUIPMENT":
            return ItemCategory.ITEM_CATEGORY_EQUIPMENT;
        case 3:
        case "ITEM_CATEGORY_ITEMS":
            return ItemCategory.ITEM_CATEGORY_ITEMS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ItemCategory.UNRECOGNIZED;
    }
}
export function itemCategoryToJSON(object) {
    switch (object) {
        case ItemCategory.ITEM_CATEGORY_CONSTRUCTION:
            return "ITEM_CATEGORY_CONSTRUCTION";
        case ItemCategory.ITEM_CATEGORY_NATURE:
            return "ITEM_CATEGORY_NATURE";
        case ItemCategory.ITEM_CATEGORY_EQUIPMENT:
            return "ITEM_CATEGORY_EQUIPMENT";
        case ItemCategory.ITEM_CATEGORY_ITEMS:
            return "ITEM_CATEGORY_ITEMS";
        case ItemCategory.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseVec3() {
    return { x: 0, y: 0, z: 0 };
}
export const Vec3 = {
    encode(message, writer = new BinaryWriter()) {
        if (message.x !== 0) {
            writer.uint32(9).double(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(17).double(message.y);
        }
        if (message.z !== 0) {
            writer.uint32(25).double(message.z);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVec3();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 9) {
                        break;
                    }
                    message.x = reader.double();
                    continue;
                }
                case 2: {
                    if (tag !== 17) {
                        break;
                    }
                    message.y = reader.double();
                    continue;
                }
                case 3: {
                    if (tag !== 25) {
                        break;
                    }
                    message.z = reader.double();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            x: isSet(object.x) ? globalThis.Number(object.x) : 0,
            y: isSet(object.y) ? globalThis.Number(object.y) : 0,
            z: isSet(object.z) ? globalThis.Number(object.z) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.x !== 0) {
            obj.x = message.x;
        }
        if (message.y !== 0) {
            obj.y = message.y;
        }
        if (message.z !== 0) {
            obj.z = message.z;
        }
        return obj;
    },
    create(base) {
        return Vec3.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVec3();
        message.x = object.x ?? 0;
        message.y = object.y ?? 0;
        message.z = object.z ?? 0;
        return message;
    },
};
function createBaseRotation() {
    return { yaw: 0, pitch: 0 };
}
export const Rotation = {
    encode(message, writer = new BinaryWriter()) {
        if (message.yaw !== 0) {
            writer.uint32(13).float(message.yaw);
        }
        if (message.pitch !== 0) {
            writer.uint32(21).float(message.pitch);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRotation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 13) {
                        break;
                    }
                    message.yaw = reader.float();
                    continue;
                }
                case 2: {
                    if (tag !== 21) {
                        break;
                    }
                    message.pitch = reader.float();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            yaw: isSet(object.yaw) ? globalThis.Number(object.yaw) : 0,
            pitch: isSet(object.pitch) ? globalThis.Number(object.pitch) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.yaw !== 0) {
            obj.yaw = message.yaw;
        }
        if (message.pitch !== 0) {
            obj.pitch = message.pitch;
        }
        return obj;
    },
    create(base) {
        return Rotation.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRotation();
        message.yaw = object.yaw ?? 0;
        message.pitch = object.pitch ?? 0;
        return message;
    },
};
function createBaseBBox() {
    return { min: undefined, max: undefined };
}
export const BBox = {
    encode(message, writer = new BinaryWriter()) {
        if (message.min !== undefined) {
            Vec3.encode(message.min, writer.uint32(10).fork()).join();
        }
        if (message.max !== undefined) {
            Vec3.encode(message.max, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBBox();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.min = Vec3.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.max = Vec3.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            min: isSet(object.min) ? Vec3.fromJSON(object.min) : undefined,
            max: isSet(object.max) ? Vec3.fromJSON(object.max) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.min !== undefined) {
            obj.min = Vec3.toJSON(message.min);
        }
        if (message.max !== undefined) {
            obj.max = Vec3.toJSON(message.max);
        }
        return obj;
    },
    create(base) {
        return BBox.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBBox();
        message.min = (object.min !== undefined && object.min !== null) ? Vec3.fromPartial(object.min) : undefined;
        message.max = (object.max !== undefined && object.max !== null) ? Vec3.fromPartial(object.max) : undefined;
        return message;
    },
};
function createBaseBlockPos() {
    return { x: 0, y: 0, z: 0 };
}
export const BlockPos = {
    encode(message, writer = new BinaryWriter()) {
        if (message.x !== 0) {
            writer.uint32(8).int32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(16).int32(message.y);
        }
        if (message.z !== 0) {
            writer.uint32(24).int32(message.z);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockPos();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.x = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.y = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.z = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            x: isSet(object.x) ? globalThis.Number(object.x) : 0,
            y: isSet(object.y) ? globalThis.Number(object.y) : 0,
            z: isSet(object.z) ? globalThis.Number(object.z) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.x !== 0) {
            obj.x = Math.round(message.x);
        }
        if (message.y !== 0) {
            obj.y = Math.round(message.y);
        }
        if (message.z !== 0) {
            obj.z = Math.round(message.z);
        }
        return obj;
    },
    create(base) {
        return BlockPos.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockPos();
        message.x = object.x ?? 0;
        message.y = object.y ?? 0;
        message.z = object.z ?? 0;
        return message;
    },
};
function createBaseItemStack() {
    return { name: "", meta: 0, count: 0 };
}
export const ItemStack = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.meta !== 0) {
            writer.uint32(16).int32(message.meta);
        }
        if (message.count !== 0) {
            writer.uint32(24).int32(message.count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseItemStack();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.meta = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.count = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            meta: isSet(object.meta) ? globalThis.Number(object.meta) : 0,
            count: isSet(object.count) ? globalThis.Number(object.count) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.meta !== 0) {
            obj.meta = Math.round(message.meta);
        }
        if (message.count !== 0) {
            obj.count = Math.round(message.count);
        }
        return obj;
    },
    create(base) {
        return ItemStack.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseItemStack();
        message.name = object.name ?? "";
        message.meta = object.meta ?? 0;
        message.count = object.count ?? 0;
        return message;
    },
};
function createBaseBlockState() {
    return { name: "", properties: {} };
}
export const BlockState = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        Object.entries(message.properties).forEach(([key, value]) => {
            BlockState_PropertiesEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = BlockState_PropertiesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.properties[entry2.key] = entry2.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            properties: isObject(object.properties)
                ? Object.entries(object.properties).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.properties) {
            const entries = Object.entries(message.properties);
            if (entries.length > 0) {
                obj.properties = {};
                entries.forEach(([k, v]) => {
                    obj.properties[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return BlockState.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockState();
        message.name = object.name ?? "";
        message.properties = Object.entries(object.properties ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseBlockState_PropertiesEntry() {
    return { key: "", value: "" };
}
export const BlockState_PropertiesEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockState_PropertiesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return BlockState_PropertiesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockState_PropertiesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseLiquidState() {
    return { block: undefined, depth: 0, falling: false, liquidType: "" };
}
export const LiquidState = {
    encode(message, writer = new BinaryWriter()) {
        if (message.block !== undefined) {
            BlockState.encode(message.block, writer.uint32(10).fork()).join();
        }
        if (message.depth !== 0) {
            writer.uint32(16).int32(message.depth);
        }
        if (message.falling !== false) {
            writer.uint32(24).bool(message.falling);
        }
        if (message.liquidType !== "") {
            writer.uint32(34).string(message.liquidType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.block = BlockState.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.depth = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.falling = reader.bool();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.liquidType = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            block: isSet(object.block) ? BlockState.fromJSON(object.block) : undefined,
            depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0,
            falling: isSet(object.falling) ? globalThis.Boolean(object.falling) : false,
            liquidType: isSet(object.liquidType) ? globalThis.String(object.liquidType) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.block !== undefined) {
            obj.block = BlockState.toJSON(message.block);
        }
        if (message.depth !== 0) {
            obj.depth = Math.round(message.depth);
        }
        if (message.falling !== false) {
            obj.falling = message.falling;
        }
        if (message.liquidType !== "") {
            obj.liquidType = message.liquidType;
        }
        return obj;
    },
    create(base) {
        return LiquidState.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLiquidState();
        message.block = (object.block !== undefined && object.block !== null)
            ? BlockState.fromPartial(object.block)
            : undefined;
        message.depth = object.depth ?? 0;
        message.falling = object.falling ?? false;
        message.liquidType = object.liquidType ?? "";
        return message;
    },
};
function createBaseWorldRef() {
    return { name: "", dimension: "" };
}
export const WorldRef = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.dimension !== "") {
            writer.uint32(18).string(message.dimension);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorldRef();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.dimension = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            dimension: isSet(object.dimension) ? globalThis.String(object.dimension) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.dimension !== "") {
            obj.dimension = message.dimension;
        }
        return obj;
    },
    create(base) {
        return WorldRef.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWorldRef();
        message.name = object.name ?? "";
        message.dimension = object.dimension ?? "";
        return message;
    },
};
function createBaseEntityRef() {
    return { uuid: "", type: "", name: undefined, position: undefined, rotation: undefined };
}
export const EntityRef = {
    encode(message, writer = new BinaryWriter()) {
        if (message.uuid !== "") {
            writer.uint32(10).string(message.uuid);
        }
        if (message.type !== "") {
            writer.uint32(18).string(message.type);
        }
        if (message.name !== undefined) {
            writer.uint32(26).string(message.name);
        }
        if (message.position !== undefined) {
            Vec3.encode(message.position, writer.uint32(34).fork()).join();
        }
        if (message.rotation !== undefined) {
            Rotation.encode(message.rotation, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEntityRef();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.uuid = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.position = Vec3.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.rotation = Rotation.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : undefined,
            position: isSet(object.position) ? Vec3.fromJSON(object.position) : undefined,
            rotation: isSet(object.rotation) ? Rotation.fromJSON(object.rotation) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uuid !== "") {
            obj.uuid = message.uuid;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.position !== undefined) {
            obj.position = Vec3.toJSON(message.position);
        }
        if (message.rotation !== undefined) {
            obj.rotation = Rotation.toJSON(message.rotation);
        }
        return obj;
    },
    create(base) {
        return EntityRef.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEntityRef();
        message.uuid = object.uuid ?? "";
        message.type = object.type ?? "";
        message.name = object.name ?? undefined;
        message.position = (object.position !== undefined && object.position !== null)
            ? Vec3.fromPartial(object.position)
            : undefined;
        message.rotation = (object.rotation !== undefined && object.rotation !== null)
            ? Rotation.fromPartial(object.rotation)
            : undefined;
        return message;
    },
};
function createBaseDamageSource() {
    return { type: "", description: undefined };
}
export const DamageSource = {
    encode(message, writer = new BinaryWriter()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.description !== undefined) {
            writer.uint32(18).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDamageSource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return DamageSource.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDamageSource();
        message.type = object.type ?? "";
        message.description = object.description ?? undefined;
        return message;
    },
};
function createBaseHealingSource() {
    return { type: "", description: undefined };
}
export const HealingSource = {
    encode(message, writer = new BinaryWriter()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.description !== undefined) {
            writer.uint32(18).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHealingSource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return HealingSource.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHealingSource();
        message.type = object.type ?? "";
        message.description = object.description ?? undefined;
        return message;
    },
};
function createBaseAddress() {
    return { host: "", port: 0 };
}
export const Address = {
    encode(message, writer = new BinaryWriter()) {
        if (message.host !== "") {
            writer.uint32(10).string(message.host);
        }
        if (message.port !== 0) {
            writer.uint32(16).int32(message.port);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddress();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.host = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.port = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            host: isSet(object.host) ? globalThis.String(object.host) : "",
            port: isSet(object.port) ? globalThis.Number(object.port) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.host !== "") {
            obj.host = message.host;
        }
        if (message.port !== 0) {
            obj.port = Math.round(message.port);
        }
        return obj;
    },
    create(base) {
        return Address.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAddress();
        message.host = object.host ?? "";
        message.port = object.port ?? 0;
        return message;
    },
};
function createBaseCustomItemDefinition() {
    return { id: "", displayName: "", textureData: new Uint8Array(0), category: 0, group: undefined, meta: 0 };
}
export const CustomItemDefinition = {
    encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.displayName !== "") {
            writer.uint32(18).string(message.displayName);
        }
        if (message.textureData.length !== 0) {
            writer.uint32(26).bytes(message.textureData);
        }
        if (message.category !== 0) {
            writer.uint32(32).int32(message.category);
        }
        if (message.group !== undefined) {
            writer.uint32(42).string(message.group);
        }
        if (message.meta !== 0) {
            writer.uint32(48).int32(message.meta);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCustomItemDefinition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.displayName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.textureData = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.category = reader.int32();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.group = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.meta = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
            textureData: isSet(object.textureData) ? bytesFromBase64(object.textureData) : new Uint8Array(0),
            category: isSet(object.category) ? itemCategoryFromJSON(object.category) : 0,
            group: isSet(object.group) ? globalThis.String(object.group) : undefined,
            meta: isSet(object.meta) ? globalThis.Number(object.meta) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.displayName !== "") {
            obj.displayName = message.displayName;
        }
        if (message.textureData.length !== 0) {
            obj.textureData = base64FromBytes(message.textureData);
        }
        if (message.category !== 0) {
            obj.category = itemCategoryToJSON(message.category);
        }
        if (message.group !== undefined) {
            obj.group = message.group;
        }
        if (message.meta !== 0) {
            obj.meta = Math.round(message.meta);
        }
        return obj;
    },
    create(base) {
        return CustomItemDefinition.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCustomItemDefinition();
        message.id = object.id ?? "";
        message.displayName = object.displayName ?? "";
        message.textureData = object.textureData ?? new Uint8Array(0);
        message.category = object.category ?? 0;
        message.group = object.group ?? undefined;
        message.meta = object.meta ?? 0;
        return message;
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
