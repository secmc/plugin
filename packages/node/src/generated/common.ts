// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "df.plugin";

export enum GameMode {
  SURVIVAL = 0,
  CREATIVE = 1,
  ADVENTURE = 2,
  SPECTATOR = 3,
  UNRECOGNIZED = -1,
}

export function gameModeFromJSON(object: any): GameMode {
  switch (object) {
    case 0:
    case "SURVIVAL":
      return GameMode.SURVIVAL;
    case 1:
    case "CREATIVE":
      return GameMode.CREATIVE;
    case 2:
    case "ADVENTURE":
      return GameMode.ADVENTURE;
    case 3:
    case "SPECTATOR":
      return GameMode.SPECTATOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameMode.UNRECOGNIZED;
  }
}

export function gameModeToJSON(object: GameMode): string {
  switch (object) {
    case GameMode.SURVIVAL:
      return "SURVIVAL";
    case GameMode.CREATIVE:
      return "CREATIVE";
    case GameMode.ADVENTURE:
      return "ADVENTURE";
    case GameMode.SPECTATOR:
      return "SPECTATOR";
    case GameMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Difficulty {
  PEACEFUL = 0,
  EASY = 1,
  NORMAL = 2,
  HARD = 3,
  UNRECOGNIZED = -1,
}

export function difficultyFromJSON(object: any): Difficulty {
  switch (object) {
    case 0:
    case "PEACEFUL":
      return Difficulty.PEACEFUL;
    case 1:
    case "EASY":
      return Difficulty.EASY;
    case 2:
    case "NORMAL":
      return Difficulty.NORMAL;
    case 3:
    case "HARD":
      return Difficulty.HARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Difficulty.UNRECOGNIZED;
  }
}

export function difficultyToJSON(object: Difficulty): string {
  switch (object) {
    case Difficulty.PEACEFUL:
      return "PEACEFUL";
    case Difficulty.EASY:
      return "EASY";
    case Difficulty.NORMAL:
      return "NORMAL";
    case Difficulty.HARD:
      return "HARD";
    case Difficulty.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * EffectType mirrors Dragonfly's registered effect IDs for straightforward mapping.
 * Keep numeric values aligned with dragonfly/server/entity/effect/register.go.
 */
export enum EffectType {
  EFFECT_UNKNOWN = 0,
  SPEED = 1,
  SLOWNESS = 2,
  HASTE = 3,
  MINING_FATIGUE = 4,
  STRENGTH = 5,
  INSTANT_HEALTH = 6,
  INSTANT_DAMAGE = 7,
  JUMP_BOOST = 8,
  NAUSEA = 9,
  REGENERATION = 10,
  RESISTANCE = 11,
  FIRE_RESISTANCE = 12,
  WATER_BREATHING = 13,
  INVISIBILITY = 14,
  BLINDNESS = 15,
  NIGHT_VISION = 16,
  HUNGER = 17,
  WEAKNESS = 18,
  POISON = 19,
  WITHER = 20,
  HEALTH_BOOST = 21,
  ABSORPTION = 22,
  SATURATION = 23,
  LEVITATION = 24,
  FATAL_POISON = 25,
  CONDUIT_POWER = 26,
  SLOW_FALLING = 27,
  /** DARKNESS - 28, 29 intentionally omitted (Bad Omen, Hero of the Village - not implemented) */
  DARKNESS = 30,
  UNRECOGNIZED = -1,
}

export function effectTypeFromJSON(object: any): EffectType {
  switch (object) {
    case 0:
    case "EFFECT_UNKNOWN":
      return EffectType.EFFECT_UNKNOWN;
    case 1:
    case "SPEED":
      return EffectType.SPEED;
    case 2:
    case "SLOWNESS":
      return EffectType.SLOWNESS;
    case 3:
    case "HASTE":
      return EffectType.HASTE;
    case 4:
    case "MINING_FATIGUE":
      return EffectType.MINING_FATIGUE;
    case 5:
    case "STRENGTH":
      return EffectType.STRENGTH;
    case 6:
    case "INSTANT_HEALTH":
      return EffectType.INSTANT_HEALTH;
    case 7:
    case "INSTANT_DAMAGE":
      return EffectType.INSTANT_DAMAGE;
    case 8:
    case "JUMP_BOOST":
      return EffectType.JUMP_BOOST;
    case 9:
    case "NAUSEA":
      return EffectType.NAUSEA;
    case 10:
    case "REGENERATION":
      return EffectType.REGENERATION;
    case 11:
    case "RESISTANCE":
      return EffectType.RESISTANCE;
    case 12:
    case "FIRE_RESISTANCE":
      return EffectType.FIRE_RESISTANCE;
    case 13:
    case "WATER_BREATHING":
      return EffectType.WATER_BREATHING;
    case 14:
    case "INVISIBILITY":
      return EffectType.INVISIBILITY;
    case 15:
    case "BLINDNESS":
      return EffectType.BLINDNESS;
    case 16:
    case "NIGHT_VISION":
      return EffectType.NIGHT_VISION;
    case 17:
    case "HUNGER":
      return EffectType.HUNGER;
    case 18:
    case "WEAKNESS":
      return EffectType.WEAKNESS;
    case 19:
    case "POISON":
      return EffectType.POISON;
    case 20:
    case "WITHER":
      return EffectType.WITHER;
    case 21:
    case "HEALTH_BOOST":
      return EffectType.HEALTH_BOOST;
    case 22:
    case "ABSORPTION":
      return EffectType.ABSORPTION;
    case 23:
    case "SATURATION":
      return EffectType.SATURATION;
    case 24:
    case "LEVITATION":
      return EffectType.LEVITATION;
    case 25:
    case "FATAL_POISON":
      return EffectType.FATAL_POISON;
    case 26:
    case "CONDUIT_POWER":
      return EffectType.CONDUIT_POWER;
    case 27:
    case "SLOW_FALLING":
      return EffectType.SLOW_FALLING;
    case 30:
    case "DARKNESS":
      return EffectType.DARKNESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectType.UNRECOGNIZED;
  }
}

export function effectTypeToJSON(object: EffectType): string {
  switch (object) {
    case EffectType.EFFECT_UNKNOWN:
      return "EFFECT_UNKNOWN";
    case EffectType.SPEED:
      return "SPEED";
    case EffectType.SLOWNESS:
      return "SLOWNESS";
    case EffectType.HASTE:
      return "HASTE";
    case EffectType.MINING_FATIGUE:
      return "MINING_FATIGUE";
    case EffectType.STRENGTH:
      return "STRENGTH";
    case EffectType.INSTANT_HEALTH:
      return "INSTANT_HEALTH";
    case EffectType.INSTANT_DAMAGE:
      return "INSTANT_DAMAGE";
    case EffectType.JUMP_BOOST:
      return "JUMP_BOOST";
    case EffectType.NAUSEA:
      return "NAUSEA";
    case EffectType.REGENERATION:
      return "REGENERATION";
    case EffectType.RESISTANCE:
      return "RESISTANCE";
    case EffectType.FIRE_RESISTANCE:
      return "FIRE_RESISTANCE";
    case EffectType.WATER_BREATHING:
      return "WATER_BREATHING";
    case EffectType.INVISIBILITY:
      return "INVISIBILITY";
    case EffectType.BLINDNESS:
      return "BLINDNESS";
    case EffectType.NIGHT_VISION:
      return "NIGHT_VISION";
    case EffectType.HUNGER:
      return "HUNGER";
    case EffectType.WEAKNESS:
      return "WEAKNESS";
    case EffectType.POISON:
      return "POISON";
    case EffectType.WITHER:
      return "WITHER";
    case EffectType.HEALTH_BOOST:
      return "HEALTH_BOOST";
    case EffectType.ABSORPTION:
      return "ABSORPTION";
    case EffectType.SATURATION:
      return "SATURATION";
    case EffectType.LEVITATION:
      return "LEVITATION";
    case EffectType.FATAL_POISON:
      return "FATAL_POISON";
    case EffectType.CONDUIT_POWER:
      return "CONDUIT_POWER";
    case EffectType.SLOW_FALLING:
      return "SLOW_FALLING";
    case EffectType.DARKNESS:
      return "DARKNESS";
    case EffectType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Sound is a curated list of common sounds that don't require extra parameters.
 * For sounds that require additional context (e.g., BlockPlace, Note), adapters
 * may use sensible defaults or ignore extra semantics for now.
 */
export enum Sound {
  SOUND_UNKNOWN = 0,
  ATTACK = 1,
  DROWNING = 2,
  BURNING = 3,
  FALL = 4,
  BURP = 5,
  POP = 6,
  EXPLOSION = 7,
  THUNDER = 8,
  LEVEL_UP = 9,
  EXPERIENCE = 10,
  FIREWORK_LAUNCH = 11,
  FIREWORK_HUGE_BLAST = 12,
  FIREWORK_BLAST = 13,
  FIREWORK_TWINKLE = 14,
  TELEPORT = 15,
  ARROW_HIT = 16,
  ITEM_BREAK = 17,
  ITEM_THROW = 18,
  TOTEM = 19,
  FIRE_EXTINGUISH = 20,
  UNRECOGNIZED = -1,
}

export function soundFromJSON(object: any): Sound {
  switch (object) {
    case 0:
    case "SOUND_UNKNOWN":
      return Sound.SOUND_UNKNOWN;
    case 1:
    case "ATTACK":
      return Sound.ATTACK;
    case 2:
    case "DROWNING":
      return Sound.DROWNING;
    case 3:
    case "BURNING":
      return Sound.BURNING;
    case 4:
    case "FALL":
      return Sound.FALL;
    case 5:
    case "BURP":
      return Sound.BURP;
    case 6:
    case "POP":
      return Sound.POP;
    case 7:
    case "EXPLOSION":
      return Sound.EXPLOSION;
    case 8:
    case "THUNDER":
      return Sound.THUNDER;
    case 9:
    case "LEVEL_UP":
      return Sound.LEVEL_UP;
    case 10:
    case "EXPERIENCE":
      return Sound.EXPERIENCE;
    case 11:
    case "FIREWORK_LAUNCH":
      return Sound.FIREWORK_LAUNCH;
    case 12:
    case "FIREWORK_HUGE_BLAST":
      return Sound.FIREWORK_HUGE_BLAST;
    case 13:
    case "FIREWORK_BLAST":
      return Sound.FIREWORK_BLAST;
    case 14:
    case "FIREWORK_TWINKLE":
      return Sound.FIREWORK_TWINKLE;
    case 15:
    case "TELEPORT":
      return Sound.TELEPORT;
    case 16:
    case "ARROW_HIT":
      return Sound.ARROW_HIT;
    case 17:
    case "ITEM_BREAK":
      return Sound.ITEM_BREAK;
    case 18:
    case "ITEM_THROW":
      return Sound.ITEM_THROW;
    case 19:
    case "TOTEM":
      return Sound.TOTEM;
    case 20:
    case "FIRE_EXTINGUISH":
      return Sound.FIRE_EXTINGUISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Sound.UNRECOGNIZED;
  }
}

export function soundToJSON(object: Sound): string {
  switch (object) {
    case Sound.SOUND_UNKNOWN:
      return "SOUND_UNKNOWN";
    case Sound.ATTACK:
      return "ATTACK";
    case Sound.DROWNING:
      return "DROWNING";
    case Sound.BURNING:
      return "BURNING";
    case Sound.FALL:
      return "FALL";
    case Sound.BURP:
      return "BURP";
    case Sound.POP:
      return "POP";
    case Sound.EXPLOSION:
      return "EXPLOSION";
    case Sound.THUNDER:
      return "THUNDER";
    case Sound.LEVEL_UP:
      return "LEVEL_UP";
    case Sound.EXPERIENCE:
      return "EXPERIENCE";
    case Sound.FIREWORK_LAUNCH:
      return "FIREWORK_LAUNCH";
    case Sound.FIREWORK_HUGE_BLAST:
      return "FIREWORK_HUGE_BLAST";
    case Sound.FIREWORK_BLAST:
      return "FIREWORK_BLAST";
    case Sound.FIREWORK_TWINKLE:
      return "FIREWORK_TWINKLE";
    case Sound.TELEPORT:
      return "TELEPORT";
    case Sound.ARROW_HIT:
      return "ARROW_HIT";
    case Sound.ITEM_BREAK:
      return "ITEM_BREAK";
    case Sound.ITEM_THROW:
      return "ITEM_THROW";
    case Sound.TOTEM:
      return "TOTEM";
    case Sound.FIRE_EXTINGUISH:
      return "FIRE_EXTINGUISH";
    case Sound.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Category for creative inventory */
export enum ItemCategory {
  ITEM_CATEGORY_CONSTRUCTION = 0,
  ITEM_CATEGORY_NATURE = 1,
  ITEM_CATEGORY_EQUIPMENT = 2,
  ITEM_CATEGORY_ITEMS = 3,
  UNRECOGNIZED = -1,
}

export function itemCategoryFromJSON(object: any): ItemCategory {
  switch (object) {
    case 0:
    case "ITEM_CATEGORY_CONSTRUCTION":
      return ItemCategory.ITEM_CATEGORY_CONSTRUCTION;
    case 1:
    case "ITEM_CATEGORY_NATURE":
      return ItemCategory.ITEM_CATEGORY_NATURE;
    case 2:
    case "ITEM_CATEGORY_EQUIPMENT":
      return ItemCategory.ITEM_CATEGORY_EQUIPMENT;
    case 3:
    case "ITEM_CATEGORY_ITEMS":
      return ItemCategory.ITEM_CATEGORY_ITEMS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ItemCategory.UNRECOGNIZED;
  }
}

export function itemCategoryToJSON(object: ItemCategory): string {
  switch (object) {
    case ItemCategory.ITEM_CATEGORY_CONSTRUCTION:
      return "ITEM_CATEGORY_CONSTRUCTION";
    case ItemCategory.ITEM_CATEGORY_NATURE:
      return "ITEM_CATEGORY_NATURE";
    case ItemCategory.ITEM_CATEGORY_EQUIPMENT:
      return "ITEM_CATEGORY_EQUIPMENT";
    case ItemCategory.ITEM_CATEGORY_ITEMS:
      return "ITEM_CATEGORY_ITEMS";
    case ItemCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Vec3 {
  x: number;
  y: number;
  z: number;
}

export interface Rotation {
  yaw: number;
  pitch: number;
}

export interface BBox {
  min: Vec3 | undefined;
  max: Vec3 | undefined;
}

export interface BlockPos {
  x: number;
  y: number;
  z: number;
}

export interface ItemStack {
  name: string;
  meta: number;
  count: number;
}

export interface BlockState {
  name: string;
  properties: { [key: string]: string };
}

export interface BlockState_PropertiesEntry {
  key: string;
  value: string;
}

export interface LiquidState {
  block: BlockState | undefined;
  depth: number;
  falling: boolean;
  liquidType: string;
}

export interface WorldRef {
  name: string;
  dimension: string;
}

export interface EntityRef {
  uuid: string;
  type: string;
  name?: string | undefined;
  position?: Vec3 | undefined;
  rotation?: Rotation | undefined;
}

export interface DamageSource {
  type: string;
  description?: string | undefined;
}

export interface HealingSource {
  type: string;
  description?: string | undefined;
}

export interface Address {
  host: string;
  port: number;
}

/**
 * CustomItemDefinition defines a custom (non-vanilla) item that requires
 * a resource pack and client-side registration
 */
export interface CustomItemDefinition {
  /** Unique identifier for the custom item (e.g., "my_plugin:custom_sword") */
  id: string;
  /** Display name shown to players */
  displayName: string;
  /** Texture data encoded as PNG bytes */
  textureData: Uint8Array;
  /** Creative inventory category */
  category: ItemCategory;
  /** Optional subgroup within the category (e.g., "sword", "pickaxe", "food") */
  group?:
    | string
    | undefined;
  /** Metadata value for this item (defaults to 0) */
  meta: number;
}

function createBaseVec3(): Vec3 {
  return { x: 0, y: 0, z: 0 };
}

export const Vec3: MessageFns<Vec3> = {
  encode(message: Vec3, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(25).double(message.z);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vec3 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVec3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.z = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vec3 {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: Vec3): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    return obj;
  },

  create(base?: DeepPartial<Vec3>): Vec3 {
    return Vec3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vec3>): Vec3 {
    const message = createBaseVec3();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBaseRotation(): Rotation {
  return { yaw: 0, pitch: 0 };
}

export const Rotation: MessageFns<Rotation> = {
  encode(message: Rotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.yaw !== 0) {
      writer.uint32(13).float(message.yaw);
    }
    if (message.pitch !== 0) {
      writer.uint32(21).float(message.pitch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.yaw = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.pitch = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rotation {
    return {
      yaw: isSet(object.yaw) ? globalThis.Number(object.yaw) : 0,
      pitch: isSet(object.pitch) ? globalThis.Number(object.pitch) : 0,
    };
  },

  toJSON(message: Rotation): unknown {
    const obj: any = {};
    if (message.yaw !== 0) {
      obj.yaw = message.yaw;
    }
    if (message.pitch !== 0) {
      obj.pitch = message.pitch;
    }
    return obj;
  },

  create(base?: DeepPartial<Rotation>): Rotation {
    return Rotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rotation>): Rotation {
    const message = createBaseRotation();
    message.yaw = object.yaw ?? 0;
    message.pitch = object.pitch ?? 0;
    return message;
  },
};

function createBaseBBox(): BBox {
  return { min: undefined, max: undefined };
}

export const BBox: MessageFns<BBox> = {
  encode(message: BBox, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== undefined) {
      Vec3.encode(message.min, writer.uint32(10).fork()).join();
    }
    if (message.max !== undefined) {
      Vec3.encode(message.max, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.min = Vec3.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max = Vec3.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BBox {
    return {
      min: isSet(object.min) ? Vec3.fromJSON(object.min) : undefined,
      max: isSet(object.max) ? Vec3.fromJSON(object.max) : undefined,
    };
  },

  toJSON(message: BBox): unknown {
    const obj: any = {};
    if (message.min !== undefined) {
      obj.min = Vec3.toJSON(message.min);
    }
    if (message.max !== undefined) {
      obj.max = Vec3.toJSON(message.max);
    }
    return obj;
  },

  create(base?: DeepPartial<BBox>): BBox {
    return BBox.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BBox>): BBox {
    const message = createBaseBBox();
    message.min = (object.min !== undefined && object.min !== null) ? Vec3.fromPartial(object.min) : undefined;
    message.max = (object.max !== undefined && object.max !== null) ? Vec3.fromPartial(object.max) : undefined;
    return message;
  },
};

function createBaseBlockPos(): BlockPos {
  return { x: 0, y: 0, z: 0 };
}

export const BlockPos: MessageFns<BlockPos> = {
  encode(message: BlockPos, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(24).int32(message.z);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockPos {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockPos();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.z = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockPos {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: BlockPos): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.z !== 0) {
      obj.z = Math.round(message.z);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockPos>): BlockPos {
    return BlockPos.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockPos>): BlockPos {
    const message = createBaseBlockPos();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBaseItemStack(): ItemStack {
  return { name: "", meta: 0, count: 0 };
}

export const ItemStack: MessageFns<ItemStack> = {
  encode(message: ItemStack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.meta !== 0) {
      writer.uint32(16).int32(message.meta);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemStack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemStack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.meta = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemStack {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      meta: isSet(object.meta) ? globalThis.Number(object.meta) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: ItemStack): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.meta !== 0) {
      obj.meta = Math.round(message.meta);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<ItemStack>): ItemStack {
    return ItemStack.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ItemStack>): ItemStack {
    const message = createBaseItemStack();
    message.name = object.name ?? "";
    message.meta = object.meta ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseBlockState(): BlockState {
  return { name: "", properties: {} };
}

export const BlockState: MessageFns<BlockState> = {
  encode(message: BlockState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      BlockState_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = BlockState_PropertiesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.properties[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockState {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BlockState): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<BlockState>): BlockState {
    return BlockState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockState>): BlockState {
    const message = createBaseBlockState();
    message.name = object.name ?? "";
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseBlockState_PropertiesEntry(): BlockState_PropertiesEntry {
  return { key: "", value: "" };
}

export const BlockState_PropertiesEntry: MessageFns<BlockState_PropertiesEntry> = {
  encode(message: BlockState_PropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockState_PropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockState_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockState_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BlockState_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BlockState_PropertiesEntry>): BlockState_PropertiesEntry {
    return BlockState_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockState_PropertiesEntry>): BlockState_PropertiesEntry {
    const message = createBaseBlockState_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLiquidState(): LiquidState {
  return { block: undefined, depth: 0, falling: false, liquidType: "" };
}

export const LiquidState: MessageFns<LiquidState> = {
  encode(message: LiquidState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== undefined) {
      BlockState.encode(message.block, writer.uint32(10).fork()).join();
    }
    if (message.depth !== 0) {
      writer.uint32(16).int32(message.depth);
    }
    if (message.falling !== false) {
      writer.uint32(24).bool(message.falling);
    }
    if (message.liquidType !== "") {
      writer.uint32(34).string(message.liquidType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiquidState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiquidState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.block = BlockState.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.depth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.falling = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.liquidType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LiquidState {
    return {
      block: isSet(object.block) ? BlockState.fromJSON(object.block) : undefined,
      depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0,
      falling: isSet(object.falling) ? globalThis.Boolean(object.falling) : false,
      liquidType: isSet(object.liquidType) ? globalThis.String(object.liquidType) : "",
    };
  },

  toJSON(message: LiquidState): unknown {
    const obj: any = {};
    if (message.block !== undefined) {
      obj.block = BlockState.toJSON(message.block);
    }
    if (message.depth !== 0) {
      obj.depth = Math.round(message.depth);
    }
    if (message.falling !== false) {
      obj.falling = message.falling;
    }
    if (message.liquidType !== "") {
      obj.liquidType = message.liquidType;
    }
    return obj;
  },

  create(base?: DeepPartial<LiquidState>): LiquidState {
    return LiquidState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LiquidState>): LiquidState {
    const message = createBaseLiquidState();
    message.block = (object.block !== undefined && object.block !== null)
      ? BlockState.fromPartial(object.block)
      : undefined;
    message.depth = object.depth ?? 0;
    message.falling = object.falling ?? false;
    message.liquidType = object.liquidType ?? "";
    return message;
  },
};

function createBaseWorldRef(): WorldRef {
  return { name: "", dimension: "" };
}

export const WorldRef: MessageFns<WorldRef> = {
  encode(message: WorldRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dimension !== "") {
      writer.uint32(18).string(message.dimension);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dimension = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorldRef {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dimension: isSet(object.dimension) ? globalThis.String(object.dimension) : "",
    };
  },

  toJSON(message: WorldRef): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dimension !== "") {
      obj.dimension = message.dimension;
    }
    return obj;
  },

  create(base?: DeepPartial<WorldRef>): WorldRef {
    return WorldRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorldRef>): WorldRef {
    const message = createBaseWorldRef();
    message.name = object.name ?? "";
    message.dimension = object.dimension ?? "";
    return message;
  },
};

function createBaseEntityRef(): EntityRef {
  return { uuid: "", type: "", name: undefined, position: undefined, rotation: undefined };
}

export const EntityRef: MessageFns<EntityRef> = {
  encode(message: EntityRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.position !== undefined) {
      Vec3.encode(message.position, writer.uint32(34).fork()).join();
    }
    if (message.rotation !== undefined) {
      Rotation.encode(message.rotation, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.position = Vec3.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rotation = Rotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityRef {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      position: isSet(object.position) ? Vec3.fromJSON(object.position) : undefined,
      rotation: isSet(object.rotation) ? Rotation.fromJSON(object.rotation) : undefined,
    };
  },

  toJSON(message: EntityRef): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.position !== undefined) {
      obj.position = Vec3.toJSON(message.position);
    }
    if (message.rotation !== undefined) {
      obj.rotation = Rotation.toJSON(message.rotation);
    }
    return obj;
  },

  create(base?: DeepPartial<EntityRef>): EntityRef {
    return EntityRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityRef>): EntityRef {
    const message = createBaseEntityRef();
    message.uuid = object.uuid ?? "";
    message.type = object.type ?? "";
    message.name = object.name ?? undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? Vec3.fromPartial(object.position)
      : undefined;
    message.rotation = (object.rotation !== undefined && object.rotation !== null)
      ? Rotation.fromPartial(object.rotation)
      : undefined;
    return message;
  },
};

function createBaseDamageSource(): DamageSource {
  return { type: "", description: undefined };
}

export const DamageSource: MessageFns<DamageSource> = {
  encode(message: DamageSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DamageSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDamageSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DamageSource {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
    };
  },

  toJSON(message: DamageSource): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<DamageSource>): DamageSource {
    return DamageSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DamageSource>): DamageSource {
    const message = createBaseDamageSource();
    message.type = object.type ?? "";
    message.description = object.description ?? undefined;
    return message;
  },
};

function createBaseHealingSource(): HealingSource {
  return { type: "", description: undefined };
}

export const HealingSource: MessageFns<HealingSource> = {
  encode(message: HealingSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealingSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealingSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealingSource {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
    };
  },

  toJSON(message: HealingSource): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<HealingSource>): HealingSource {
    return HealingSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealingSource>): HealingSource {
    const message = createBaseHealingSource();
    message.type = object.type ?? "";
    message.description = object.description ?? undefined;
    return message;
  },
};

function createBaseAddress(): Address {
  return { host: "", port: 0 };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create(base?: DeepPartial<Address>): Address {
    return Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Address>): Address {
    const message = createBaseAddress();
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseCustomItemDefinition(): CustomItemDefinition {
  return { id: "", displayName: "", textureData: new Uint8Array(0), category: 0, group: undefined, meta: 0 };
}

export const CustomItemDefinition: MessageFns<CustomItemDefinition> = {
  encode(message: CustomItemDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.textureData.length !== 0) {
      writer.uint32(26).bytes(message.textureData);
    }
    if (message.category !== 0) {
      writer.uint32(32).int32(message.category);
    }
    if (message.group !== undefined) {
      writer.uint32(42).string(message.group);
    }
    if (message.meta !== 0) {
      writer.uint32(48).int32(message.meta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomItemDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomItemDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.textureData = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.group = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.meta = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomItemDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      textureData: isSet(object.textureData) ? bytesFromBase64(object.textureData) : new Uint8Array(0),
      category: isSet(object.category) ? itemCategoryFromJSON(object.category) : 0,
      group: isSet(object.group) ? globalThis.String(object.group) : undefined,
      meta: isSet(object.meta) ? globalThis.Number(object.meta) : 0,
    };
  },

  toJSON(message: CustomItemDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.textureData.length !== 0) {
      obj.textureData = base64FromBytes(message.textureData);
    }
    if (message.category !== 0) {
      obj.category = itemCategoryToJSON(message.category);
    }
    if (message.group !== undefined) {
      obj.group = message.group;
    }
    if (message.meta !== 0) {
      obj.meta = Math.round(message.meta);
    }
    return obj;
  },

  create(base?: DeepPartial<CustomItemDefinition>): CustomItemDefinition {
    return CustomItemDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomItemDefinition>): CustomItemDefinition {
    const message = createBaseCustomItemDefinition();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.textureData = object.textureData ?? new Uint8Array(0);
    message.category = object.category ?? 0;
    message.group = object.group ?? undefined;
    message.meta = object.meta ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
